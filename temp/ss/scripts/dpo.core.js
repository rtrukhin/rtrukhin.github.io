//
// Avery Design & Print Online Core v8.0.30709
// 
// Copyright (c) 2014 Avery Products Corporation. All rights reserved.
// 
// Build: Tue Oct 25 2016
//
// noinspection ThisExpressionReferencesGlobalObjectJS, FunctionTooLongJS, JSUnusedGlobalSymbols
(function (root, factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Define as an anonymous module
        define(['Snap', 'opentype'], function(Snap, opentype) {
            return factory(root, Snap, opentype);
        });
    } else {
        root.DPO = factory(root, root.Snap, root.opentype);
    }
}(this, function (root, Snap, opentype) {
'use strict';

/**
 * @file Defines Design & Print Online namespace
 * @author Avery Products Corporation. All rights reserved
 */

/**
 * DPO point type
 * @typedef {Object} DPO.Point
 * @property {boolean} x x coordinate
 * @property {boolean} y x coordinate
 */

/**
 * DPO field's bounding points
 * @typedef {Object} DPO.BoundingPoints
 * @property {DPO.Point} nw North-west point
 * @property {DPO.Point} ne North-east point
 * @property {DPO.Point} se South-east point
 * @property {DPO.Point} sw South-west point
 */

/**
 * @namespace DPO
 */
var DPO = (function () {
    var idCounter = 0,
        DPO = {};

    /**
     * Defines new class of function in specified namespace
     * @memberof DPO
     * @param {string} ns Class/function namespace
     * @param {function} fn Construction functions
     */
    DPO.def = function def(ns, fn) {
        var array = ns.split('.'),
            className = array.pop(),
            namespace = DPO;
        for (var i = 0; i < array.length; i++) {
            namespace[array[i]] = namespace[array[i]] || {};
            namespace = namespace[array[i]];
        }

        var obj = fn(namespace, DPO);
        namespace[className] = obj;

        if (obj.prototype) {
            obj.prototype.dpoName = 'DPO.' + ns;
        }
    };

    /**
     * Creates inheritance of child class from parent
     * @memberof DPO
     * @param {function} child
     * @param {function} parent
     * @returns {object}
     */
    DPO.inherit = function inherit(child, parent) {
        var prototype = Object.create(parent.prototype);
        prototype.constructor = child;
        prototype.$super = parent.prototype;
        child.prototype = prototype;
        return child;
    };

    /**
     * Copies all properties from specified object to first argument
     * @memberof DPO
     * @template T
     * @param {T} to
     * @param {...object}
     * @returns {T}
     */
    DPO.mixin = function mixin(to) {
        for (var i = 1; i < arguments.length; i++) {
            var from = arguments[i] || {};
            for (var name in from) {
                if (from.hasOwnProperty(name)) {
                    to[name] = from[name];
                }
            }
        }
        return to;
    };

    /**
     * Generates new unique identifier
     * @memberof DPO
     * @returns {string}
     */
    DPO.id = function id() {
        return 'dpo8-id-' + idCounter++;
    };

    /**
     * Stable sort
     * @memberof DPO
     * @param {object[]|Array} array
     * @param {function} comparator
     */
    DPO.stableSort = function stableSort(array, comparator) {
        var repeat;
        do {
            repeat = false;
            for (var i = 1; i < array.length; i++) {
                var a = array[i - 1],
                    b = array[i];
                if (comparator(a, b) > 0) {
                    array[i - 1] = b;
                    array[i] = a;
                    repeat = true;
                }
            }
        } while (repeat);
    };

    /**
     * Check if two values are close to each other
     * @memberof DPO
     * @param {number} v1
     * @param {number} v2
     * @param {number} [delta=0.00001]
     * @returns {boolean}
     */
    DPO.closeTo = function closeTo(v1, v2, delta) {
        if (delta === 0) {
            return v1 === v2;
        }

        delta = delta || 0.00001;
        return Math.abs(v1 - v2) < Math.abs(delta);
    };

    /**
     * Converts inches to twips
     * @memberof DPO
     * @param {number} inches
     * @returns {number}
     */
    DPO.inchesToTwips = function inchesToTwips(inches) {
        return inches * 1440;
    };

    /**
     * Converts millimeters to twips
     * @memberof DPO
     * @param {number} mm
     * @returns {number}
     */
    DPO.mmToTwips = function mmToTwips(mm) {
        return mm * 56.6929;
    };

    /**
     * Converts mils to points
     * @memberof DPO
     * @param {number} mils
     * @returns {number}
     */
    DPO.milsToPoints = function milsToPoints(mils) {
        return mils * 0.005;
    };

    /**
     * Converts inches to points
     * @memberof DPO
     * @param {number} inches
     * @returns {number}
     */
    DPO.inchesToPoints = function inchesToPoints(inches) {
        return inches * 72;
    };

    /**
     * Converts points to inches
     * @memberof DPO
     * @param {number} points
     * @returns {number}
     */
    DPO.pointsToTwips = function pointsToTwips(points) {
        return points * 20;
    };

    //DPO.base64ArrayBuffer = function base64ArrayBuffer(arrayBuffer) {
    //    var base64 = '',
    //        encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    //        bytes = new Uint8Array(arrayBuffer),
    //        byteLength = bytes.byteLength,
    //        byteRemainder = byteLength % 3,
    //        mainLength = byteLength - byteRemainder,
    //        a, b, c, d,
    //        chunk;
    //
    //    // Main loop deals with bytes in chunks of 3
    //    for (var i = 0; i < mainLength; i += 3) {
    //        // Combine the three bytes into a single integer
    //        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
    //
    //        // Use bitmasks to extract 6-bit segments from the triplet
    //        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
    //        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
    //        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
    //        d = chunk & 63;               // 63       = 2^6 - 1
    //
    //        // Convert the raw binary segments to the appropriate ASCII encoding
    //        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    //    }
    //
    //    // Deal with the remaining bytes and padding
    //    if (byteRemainder === 1) {
    //        chunk = bytes[mainLength];
    //
    //        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
    //
    //        // Set the 4 least significant bits to zero
    //        b = (chunk & 3) << 4; // 3   = 2^2 - 1
    //
    //        base64 += encodings[a] + encodings[b] + '==';
    //    } else if (byteRemainder === 2) {
    //        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
    //
    //        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
    //        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
    //
    //        // Set the 2 least significant bits to zero
    //        c = (chunk & 15) << 2; // 15    = 2^4 - 1
    //
    //        base64 += encodings[a] + encodings[b] + encodings[c] + '=';
    //    }
    //
    //    return base64;
    //};

    /**
     * Empty function
     * @memberof DPO
     * @param {...*}
     */
    DPO.emptyFn = function emptyFn() {
    };

    /**
     * Converts string/date to number
     * @memberof DPO
     * @param {string|Date} a
     * @returns {number}
     */
    DPO.toNumber = function toNumber(a) {
        return +a;
    };

    /**
     * Ascending number comparator for Array.sort method
     * @memberof DPO
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    DPO.compareNumbersAsc = function compareNumbersAsc(a, b) {
        return a - b;
    };

    /**
     * Descending number comparator for Array.sort method
     * @memberof DPO
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    DPO.compareNumbersDesc = function compareNumbersDesc(a, b) {
        return b - a;
    };

    /**
     * Base DPO exception inherited from {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Ecma Script Error}
     * @class DPO.Exception
     * @extends Error
     * @memberof DPO
     * @param {string} [msg] Human readable error message
     * @param {number} [id] Error identifier
     * @constructor
     */
    DPO.Exception = function Exception(msg, id) {
        Error.call(this, msg, id);
    };

    DPO.inherit(DPO.Exception.prototype, Error);

    /**
     * InvalidArgumentException exception from {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error|Ecma Script Error}
     * @class DPO.InvalidArgumentException
     * @extends Error
     * @memberof DPO
     * @property paramName Parameter name
     * @property reason Exception reason
     * @param {string} paramName Parameter name
     * @param {string} reason Exception reason
     * @constructor
     */
    DPO.InvalidArgumentException = function InvalidParameterException(paramName, reason) {
        DPO.Exception.call(this, paramName + ' ' + reason, 1);
        this.paramName = paramName;
        this.reason = reason;
    };

    /**
     * Convert base64/URLEncoded data component to raw binary data held in a string
     * @memberof DPO
     * @param {string} dataURI Base64 string
     * @returns {Blob || undefined}
     */
    DPO.dataURItoBlob = function dataURItoBlob(dataURI) {
        var byteString,
            blob;
        if (dataURI.split(',')[0].indexOf('base64') >= 0) {
            byteString = atob(dataURI.split(',')[1]);

            // separate out the mime component
            var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

            // write the bytes of the string to a typed array
            var ia = new Uint8Array(byteString.length);
            for (var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }

            blob = new Blob([ia], {type: mimeString});
        }

        return blob;
    };

    /**
     * Emulates progress status
     * @param {function} onProgress
     * @param {number} [speed]
     * @returns {{done: function}}
     */
    DPO.progressCalculator = function progressCalculator(onProgress, speed) {
        speed = speed || 350;
        var status = 0,
            total = 1,
            progressing = true;

        function increase() {
            var amount = 0;

            if (status < 0.25) {
                amount = (Math.random() * 3 + 3) / 100;
            } else if (status < 0.55) {
                amount = (Math.random() * 3) / 100;
            } else if (status < 0.75) {
                amount = (Math.random() * 2) / 100;
            } else if (status < 0.9) {
                amount = 0.005;
            } else if (status < 0.99) {
                amount = 0.002;
            }

            status += amount;
        }

        function trigger() {
            status = Math.min(status, total);
            status = Math.max(status, 0);

            onProgress(status, total);
        }

        function run() {
            trigger();

            setTimeout(function () {
                if (progressing) {
                    increase();
                    run();
                }
            }, speed);
        }

        run();

        return {
            done: function done(onDone) {
                progressing = false;
                status = total;

                setTimeout(function () {
                    onDone();
                }, speed);
            }
        };
    };

    /**
     * Applies aspect to specified target
     * @memberof DPO
     * @param {object} aspectMap
     * @param {*} target
     * @returns {*}
     */
    DPO.applyAspect = function applyAspect(aspectMap, target) {
        var keys = Object.keys(aspectMap);

        function beforeAdvice() {
        }

        function afterAdvice(ctx) {
        }

        function wrap(aspect, method) {
            var beforeFn = aspect.before || beforeAdvice,
                afterFn = aspect.after || afterAdvice,
                scope = aspect.scope;
            return function aopWrapper() {
                var ctx = {
                    target: this,
                    method: method,
                    args: Array.prototype.slice.call(arguments)
                };
                beforeFn.call(scope || this, ctx);
                ctx.result = method.apply(this, arguments);
                afterFn.call(scope || this, ctx);
                return ctx.result;
            };
        }

        target.aopWrappers = target.aopWrappers || [];
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i],
                original = target[key];
            target[key] = wrap(aspectMap[key], original);
            target[key].aopOriginal = original;
            target.aopWrappers.push(key);
        }

        return target;
    };

    /**
     * Resets applied aspects for specified target
     * @memberof DPO
     * @param {...object}
     */
    DPO.resetAspect = function resetAspect() {
        for (var i = 0; i < arguments.length; i++) {
            var target = arguments[i],
                wrappers = target.aopWrappers || [];
            delete target.aopWrappers;
            for (var j = wrappers.length - 1; j >= 0; j--) {
                var key = wrappers[j],
                    aopWrapper = target[key];
                if (aopWrapper && aopWrapper.aopOriginal) {
                    target[key] = aopWrapper.aopOriginal;
                    delete aopWrapper.aopOriginal; // Help garbage collector
                }
            }
        }
    };

    /**
     * Decodes Data URLs string
     * @memberof DPO
     * @param {string} url
     * @returns {object}
     */
    DPO.decodeDataURL = function decodeDataURL(url) {
        var res = null,
            dataUrlRegex = /(data:(application\/dpo8.+);(charset=.*?,)([0-9A-Za-z%.-]*))/i,
            mimeRegex = /(application\/dpo8.*?)(?:;)/i,
            charsetRegex = /(charset=.*?)(?:,)/i,
            dataRegex = /(?:charset=.*?,)(.*)/i,
            mime = mimeRegex.exec(url),
            charset = charsetRegex.exec(url),
            data = dataRegex.exec(url);

        if (url.match(dataUrlRegex)) {
            res = {
                mime: mime[1],
                data: decodeURIComponent(data[1]),
                charset: charset[1]
            }
        }

        return res;
    };

    /**
     * Encodes Data URLs string
     * @memberof DPO
     * @param {string} type
     * @param {string} data
     * @returns {string}
     */
    DPO.encodeDataURL = function encodeDataURL(type, data) {
        return 'data:' + type + ';charset=utf-8,' + encodeURIComponent(data);
    };

    /**
     * Set parameters of DataTransfer object depends on browser
     * @param {DataTransfer} object
     * @param {string} mime
     * @param {string} data
     */
    DPO.prepareDataTransferObject = function (object, mime, data) {
        if (window) {
            object.clearData();
            object.dropEffect = 'copy';
            if (object.setDragImage) {
                // Chrome & Firefox
                object.setData(mime, data);
                return;
            }

            if (/(msie|trident |rv:).?(10|11\.\d)/i.test(window.navigator.userAgent)) {
                // IE supports only "text" parameter
                if (mime.toLowerCase() === 'text') {
                    object.setData('text', data);
                } else {
                    object.setData('text', DPO.encodeDataURL(mime, data));
                }
                return;
            }

            object.items.clear();
            // MS Edge browser uses add method instead of setData
            object.items.add(DPO.encodeDataURL(mime, data), 'URL');

        }
        object.setData(mime, data);
    };

    DPO.inherit(DPO.InvalidArgumentException.prototype, DPO.Exception);

    return DPO;
})();

DPO.def('mixins.Observable', function (ns) {
    /**
     * Provides methods for event listening & firing.
     * @property {object} eventMap
     * @memberof DPO.mixins
     * @mixin DPO.mixins.Observable
     */
    var Observable = {
        /**
         * Initializes Observable mixin
         * @memberof DPO.mixins.Observable#
         */
        resetObservable: function resetObservable() {
            var me = this;
            me.eventMap = {};
            me.suspendedEvent = [];
        },

        /**
         * Suspends events for specified observer
         * @memberof DPO.mixins.Observable#
         * @param {object} observer
         * @param {RegExp} [events]
         */
        suspendEvents: function suspendEvent(observer, events) {
            var me = this,
                index = -1;
            for (var i = 0; i < me.suspendedEvent.length; i++) {
                if (me.suspendedEvent[i].observer === observer) {
                    index = i;
                }
            }

            if (index === -1) {
                me.suspendedEvent.push({
                    observer: observer,
                    events: events || /.*/
                });
            } else {
                me.suspendedEvent[index].events = events || /.*/;
            }
        },

        /**
         * Resumes events for specified observer
         * @memberof DPO.mixins.Observable#
         * @param observer
         */
        resumeEvents: function suspendEvent(observer) {
            var me = this,
                index = -1;
            for (var i = 0; i < me.suspendedEvent.length; i++) {
                if (me.suspendedEvent[i].observer === observer) {
                    index = i;
                }
            }

            if (index !== -1) {
                me.suspendedEvent.splice(index, 1);
            }
        },

        /**
         * Register a handler function to be called whenever this event is fired
         * @memberof DPO.mixins.Observable#
         * @param {string|RegExp} event
         * @param {function|*} fn
         * @param {object} [scope]
         */
        on: function on(event, fn, scope) {
            var name = event instanceof RegExp ? '' : event,
                listeners = this.eventMap[name];
            if (!listeners) {
                listeners = [];
                this.eventMap[name] = listeners;
            }

            listeners.push({
                regExp: event,
                fn : fn,
                scope: scope
            });
        },

        /**
         * Removes event listener
         * @memberof DPO.mixins.Observable#
         * @param {string|RegExp} event
         * @param {function|*} fn
         * @param {object} scope
         */
        un: function un(event, fn, scope) {
            var name = event instanceof RegExp ? '' : event,
                listeners = this.eventMap[name] || [];
            for (var i = 0; i < listeners.length; i++) {
                var listener = listeners[i];
                if (listener.fn === fn && listener.scope === scope) {
                    listeners.splice(i, 1);
                }
            }
        },

        /**
         * Fire an event, causing all handlers for that event name to run
         * @memberof DPO.mixins.Observable#
         * @param {string|RegExp} event
         * @param {object[]} [args]
         */
        fire: function fire(event, args) {
            var me = this,
                listeners = [].concat(me.eventMap[event] || []),
                listener, i, scope;

            function isSuspended(e, observer) {
                var suspended = false;
                for (var i = 0; i < me.suspendedEvent.length; i++) {
                    var obj = me.suspendedEvent[i];
                    if (obj.observer === observer) {
                        suspended = e.match(obj.events);
                    }
                }
                return suspended;
            }

            for (i = 0; i < listeners.length; i++) {
                listener = listeners[i];
                scope = listener.scope || me;
                if (!isSuspended(event, scope)) {
                    listener.fn.apply(scope, args || []);
                }
            }

            listeners = [].concat(this.eventMap[''] || []);
            for (i = 0; i < listeners.length; i++) {
                listener = listeners[i];
                scope = listener.scope || me;
                if (listener.regExp.test(event) && !isSuspended(event, scope)) {
                    listener.fn.apply(scope, args || []);
                }
            }
        }
    };

    ns.Observable = Observable;
    return Observable;
});
DPO.def('mixins.TimeMachine', function () {
    /**
     * Provides methods for history implementation.
     * @memberof DPO.mixins
     * @mixin DPO.mixins.TimeMachine
     */
    var TimeMachine = {},
        microsecondsCounter = 0;
    DPO.mixin(TimeMachine, {
        /**
         * Returns current timestamp + counter number as microseconds
         * @memberof DPO.mixins.TimeMachine#
         * @returns {number}
         */
        currentTimestamp: function currentTimestamp() {
            microsecondsCounter = (microsecondsCounter + 0.001) % 1;
            return +new Date() + microsecondsCounter;
        },

        /**
         * Initialize time machine
         * @memberof DPO.mixins.TimeMachine#
         * @param [fallback]
         */
        initTimeMachine: function initTimeMachine(fallback) {
            fallback = fallback || {};

            var me = this,
                timestamp = me.currentTimestamp();
            me.timeMachine = me.timeMachine || {
                    beginning: timestamp,
                    timestamp: timestamp,
                    resources: {}
                };
            me.timeMachine.snapshots = {};
            me.timeMachine.fallback = fallback;
        },

        /**
         * Iterates snapshots from beginning to current timestamp
         * @memberof DPO.mixins.TimeMachine#
         * @param {function} fn
         * @param {?number} [from]
         * @param {?number} [to]
         */
        foreachSnapshot: function foreachSnapshot(fn, from, to) {
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber).sort(DPO.compareNumbersAsc),
                stop = false;
            from = from == null ? -Infinity : from;
            to = to == null ? tm.timestamp : to;
            times.sort(DPO.compareNumbersAsc);
            for (var i = 0; !stop && i < times.length; i++) {
                var t = times[i];
                if (t >= from && t <= to) {
                    stop = !!fn(tm.snapshots[t], t);
                }
            }
        },

        /**
         * Returns closest snapshot timestamp
         * @memberof DPO.mixins.TimeMachine#
         * @param {number} steps
         * @returns {number}
         */
        getTimestamp: function getTimestamp(steps) {
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber).sort(DPO.compareNumbersAsc),
                index = 0;
            for (var i = 0; i < times.length; i++) {
                var t = times[i];
                if (tm.timestamp >= t) {
                    index = i;
                }
            }

            return times[index + steps];
        },

        /**
         * Performs sequence cleanup
         * @memberof DPO.mixins.TimeMachine#
         * @param {number[]} times
         * @param {number} last
         */
        doCleanupSnapshots: function doCleanupSequence(times, last) {
            var me = this,
                tm = me.timeMachine,
                state = {},
                lastState = tm.snapshots[last];
            for (var i = 0; i < times.length; i++) {
                var time = times[i];
                DPO.mixin(state, tm.snapshots[time]);
                delete tm.snapshots[time];
            }

            tm.snapshots[last] = DPO.mixin(state, lastState);
        },

        /**
         * Removes snapshots if timestamp difference is less then timeDiff
         * @memberof DPO.mixins.TimeMachine#
         * @param {number} timeDiff
         * @returns {*}
         */
        cleanupSequence: function cleanupSequence(timeDiff) {
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber).sort(DPO.compareNumbersAsc),
                array = [],
                t1, t2;
            for (var i = 0; i < times.length - 1; i++) {
                t1 = times[i];
                t2 = times[i + 1];
                if (t2 - t1 < timeDiff) {
                    array.push(t1);
                    continue;
                }

                if (array.length) {
                    me.doCleanupSnapshots(array, t2);
                    array = [];
                }
            }

            if (array.length) {
                me.doCleanupSnapshots(array, t2);
            }

            return me;
        },

        /**
         * Limit snapshots count
         * @memberof DPO.mixins.TimeMachine#
         * @param {number} limit
         * @returns {*}
         */
        limitSnapshots: function limitSnapshots(limit) {
            limit = Math.max(limit, 1);
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber).sort(DPO.compareNumbersDesc),
                array = [],
                index;
            for (index = limit; index < times.length; index++) {
                var time = times[index];
                array.push(time);
            }

            if (array.length) {
                array.sort(DPO.compareNumbersAsc);
                me.doCleanupSnapshots(array, times[limit - 1]);
            }
            return me;
        },

        /**
         * Returns shapshot count
         * @memberof DPO.mixins.TimeMachine#
         * @returns {number}
         */
        getSnapshotCount: function getSnapshotCount() {
            return Object.keys(this.timeMachine.snapshots).length;
        },

        /**
         * Changes current timestamp
         * @memberof DPO.mixins.TimeMachine#
         * @param {number} [timestamp]
         */
        timeTravel: function timeTravel(timestamp) {
            timestamp = timestamp === undefined ? this.currentTimestamp() : timestamp;
            this.timeMachine.timestamp = timestamp;
        },

        /**
         * Removed future state
         * @memberof DPO.mixins.TimeMachine#
         */
        forgetFuture: function forgetFuture() {
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber).sort(DPO.compareNumbersDesc);
            for (var i = 0; i < times.length; i++) {
                var t = times[i];
                if (t > tm.timestamp) {
                    delete tm.snapshots[t];
                }
            }
        },

        /**
         * Registers time resource
         * @memberof DPO.mixins.TimeMachine#
         * @param {string} name
         * @param {function} [accessor]
         */
        registerTimeResource: function registerTimeResource(name, accessor) {
            this.timeMachine.resources[name] = accessor || function (obj) {
                    return obj;
                };
        },

        /**
         * Returns resource timestamps
         * @memberof DPO.mixins.TimeMachine#
         * @param {string} name
         * @param {*} [ctx]
         * @returns {number[]}
         */
        getResourceTimestamps: function getResourceTimestamps(name, ctx) {
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber),
                accessor = tm.resources[name];
            for (var i = times.length - 1; i >= 0; i--) {
                var t = times[i],
                    s = tm.snapshots[t][name],
                    res = accessor.call(me, s, ctx);
                if (res === undefined) {
                    times.splice(i, 1);
                }
            }

            return times;
        },

        /**
         * Check if resource exists if past
         * @memberof DPO.mixins.TimeMachine#
         * @param {string} name
         * @param {*} [ctx]
         * @param {number} [timestamp]
         * @returns {boolean}
         */
        hasPastResource: function hasPastResource(name, ctx, timestamp) {
            var me = this,
                times = me.getResourceTimestamps(name, ctx);
            timestamp = timestamp === undefined ? me.timeMachine.timestamp : timestamp;
            return times.some(function (time) {
                return time < timestamp;
            });
        },

        /**
         * Check if resource exists if future
         * @memberof DPO.mixins.TimeMachine#
         * @param {string} name
         * @param {*} [ctx]
         * @param {number} [timestamp]
         * @returns {boolean}
         */
        hasFutureResource: function hasPastResource(name, ctx, timestamp) {
            var me = this,
                times = me.getResourceTimestamps(name, ctx);
            timestamp = timestamp === undefined ? me.timeMachine.timestamp : timestamp;
            return times.some(function (time) {
                return time > timestamp;
            });
        },

        /**
         * Lookup time resource for specified timestamp
         * @memberof DPO.mixins.TimeMachine#
         * @param {string} name
         * @param {*} [ctx]
         * @param {number} [timestamp]
         * @returns {*}
         */
        lookupTimeResource: function lookupTimeResource(name, ctx, timestamp) {
            var me = this,
                tm = me.timeMachine,
                times = Object.keys(tm.snapshots).map(DPO.toNumber).sort(DPO.compareNumbersDesc),
                accessor = tm.resources[name];
            timestamp = timestamp === undefined ? tm.timestamp : timestamp;

            for (var i = 0; i < times.length; i++) {
                var t = times[i];
                if (t > timestamp) {
                    continue;
                }

                var s = tm.snapshots[t][name],
                    res = accessor.call(me, s, ctx);
                if (res !== undefined) {
                    return res;
                }
            }

            return accessor.call(me, tm.fallback[name], ctx);
        },

        /**
         * Stores time resource
         * @memberof DPO.mixins.TimeMachine#
         * @param {string} name
         * @param {*} obj
         * @param {number} [timestamp]
         */
        storeTimeResource: function storeTimeResource(name, obj, timestamp) {
            var me = this,
                tm = me.timeMachine;
            timestamp = timestamp === undefined ? tm.timestamp : timestamp;

            var state = tm.snapshots[timestamp] || {};
            state[name] = obj;
            tm.snapshots[timestamp] = state;
        }
    });

    return TimeMachine;
});

DPO.def('math', function () {
    /**
     * @memberof DPO
     * @type {object}
     * @namespace DPO.math
     */
    var math = {};

    /**
     * Returns number sign
     * @param {number} x
     * @returns {number}
     */
    math.sign = function sign(x) {
        return x < 0 ? -1 : 1;
    };

    /**
     * Converts degrees to radians
     * @memberof DPO.math
     * @function rad
     * @param {number} deg degrees
     * @returns {number}
     */
    math.rad = function rad(deg) {
        return (Math.PI / 180) * deg;
    };

    /**
     * Converts radians to degrees
     * @memberof DPO.math
     * @function deg
     * @param {number} rad radians
     * @returns {number}
     */
    math.deg = function deg(rad) {
        return rad / Math.PI * 180;
    };

    /**
     * Resolves quadratic equation a*x^2 + b*x + x = 0
     * @memberof DPO.math
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @returns {*}
     */
    math.resolveQuadraticEquation = function resolveQuadraticEquation(a, b, c) {
        var d = b * b - 4 * a * c;
        if (d < 0) {
            return null;
        }

        var s = Math.sqrt(d);
        return {
            v1: (-b + s) / 2 / a,
            v2: (-b - s) / 2 / a
        };
    };

    /**
     * Resolves cubic equation a*x^3 + b*x^2 + c*x + d = 0
     * @memberof DPO.math
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @param {number} d
     * @returns {number[]}
     */
    math.resolveCubicEquation = function resolveCubicEquation(a, b, c, d) {
        function cubeRoot(x) {
            var y = Math.pow(Math.abs(x), 1 / 3);
            return x < 0 ? -y : y;
        }

        var discriminant;
        if (Math.abs(a) < 1e-8) { // Quadratic case, ax^2+bx+c=0
            a = b;
            b = c;
            c = d;
            if (Math.abs(a) < 1e-8) { // Linear case, ax+b=0
                a = b;
                b = c;
                if (Math.abs(a) < 1e-8) { // Degenerate case
                    return [];
                }
                return [-b / a];
            }

            discriminant = b * b - 4 * a * c;
            if (Math.abs(discriminant) < 1e-8) {
                return [-b / (2 * a)];
            } else if (discriminant > 0) {
                return [(-b + Math.sqrt(discriminant)) / (2 * a), (-b - Math.sqrt(discriminant)) / (2 * a)];
            }
            return [];
        }

        // Convert to depressed cubic t^3+pt+q = 0 (subst x = t - b/3a)
        var p = (3 * a * c - b * b) / (3 * a * a),
            q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a),
            u, t, k, roots;

        if (Math.abs(p) < 1e-8) { // p = 0 -> t^3 = -q -> t = -q^1/3
            roots = [cubeRoot(-q)];
        } else if (Math.abs(q) < 1e-8) { // q = 0 -> t^3 + pt = 0 -> t(t^2+p)=0
            roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
        } else {
            discriminant = q * q / 4 + p * p * p / 27;
            if (Math.abs(discriminant) < 1e-8) {       // D = 0 -> two roots
                roots = [-1.5 * q / p, 3 * q / p];
            } else if (discriminant > 0) {             // Only one real root
                u = cubeRoot(-q / 2 - Math.sqrt(discriminant));
                roots = [u - p / (3 * u)];
            } else {                        // D < 0, three roots, but needs to use complex numbers/trigonometric solution
                u = 2 * Math.sqrt(-p / 3);
                t = Math.acos(3 * q / p / u) / 3;  // D < 0 implies p < 0 and acos argument in [-1..1]
                k = 2 * Math.PI / 3;
                roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)];
            }
        }

        // Convert back from depressed cubic
        for (var i = 0; i < roots.length; i++) {
            roots[i] -= b / (3 * a);
        }

        return roots;
    };

    return math;
});

DPO.def('math.Line', function () {
    /**
     * Creates new immutable line from implicit line equation a*x + b*y + c = 0
     * @class DPO.math.Line
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @constructor
     */
    function Line(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    DPO.mixin(Line.prototype, {
        /**
         * Returns value at specified coordinates
         * @memberof DPO.math.Line#
         * @param {number|DPO.math.Point|{x: number, y: number}} x
         * @param {number} [y]
         * @returns {*}
         */
        value: function value(x, y) {
            if (y === undefined) {
                y = x.y;
                x = x.x;
            }
            return this.a * x + this.b * y + this.c;
        },

        /**
         * Returns x value
         * @memberof DPO.math.Line#
         * @param {number} y
         * @returns {number}
         */
        x: function x(y) {
            var me = this;
            return me.a === 0 ? null : -(me.b * y + me.c) / me.a;
        },

        /**
         * Returns y value
         * @memberof DPO.math.Line#
         * @param {number} x
         * @returns {number}
         */
        y: function y(x) {
            var me = this;
            return me.b === 0 ? null : -(me.a * x + me.c) / me.b;
        },

        /**
         * Calculates deviation from specified point
         * @memberof DPO.math.Line#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @returns {number}
         */
        deviationFromPoint: function deviationFromPoint(point) {
            var me = this,
                v = me.value(point),
                sign = me.c > 0 ? -1 : 1,
                radix = sign * Math.sqrt(me.a * me.a + me.b * me.b);
            return v / radix;
        },

        /**
         * Calculates distance to specified point
         * @memberof DPO.math.Line#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @returns {number}
         */
        distanceToPoint: function distanceToPoint(point) {
            return Math.abs(this.deviationFromPoint(point));
        },

        /**
         * Returns perpendicular line to specified point
         * @memberof DPO.math.Line#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @returns {DPO.math.Line}
         */
        perpendicularToPoint: function perpendicularToPoint(point) {
            return new DPO.math.Line(-this.b, this.a, this.b * point.x - this.a * point.y);
        },

        /**
         * Return intersection with rectangle
         * @memberof DPO.math.Line#
         * @param {DPO.math.Rect} rect
         * @returns {DPO.math.LineSegment}
         */
        intersectWithRect: function intersectWithRect(rect) {
            var me = this,
                points = [
                    {x: rect.x1, y: me.y(rect.x1)},
                    {x: rect.x2, y: me.y(rect.x2)},
                    {x: me.x(rect.y1), y: rect.y1},
                    {x: me.x(rect.y2), y: rect.y2}
                ],
                seg = [];
            for (var i = 0; i < points.length; i++) {
                var p = points[i];
                if (p.x !== null && p.y !== null && rect.containsPoint(p)) {
                    seg.push(p);
                }
            }

            return seg.length ? new DPO.math.LineSegment(seg[0], seg[1]) : null;
        },

        /**
         * Creates clone of current object
         * @memberof DPO.math.Line#
         * @returns {DPO.math.Line}
         */
        clone: function clone() {
            return new Line(this.a, this.b, this.c);
        },

        /**
         * Finds the closest point on the line to the specific point
         * @memberof DPO.math.Line#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @returns {DPO.math.Point}
         */
        projectPoint: function projectPoint(point) {
            var me = this,
                perpendicular = me.perpendicularToPoint(point);
            return me.intersectionWithLine(perpendicular);
        },

        /**
         * Returns intersection with specified line
         * @memberof DPO.math.Line#
         * @param {DPO.math.Line} line
         * @returns {DPO.math.Point}
         */
        intersectionWithLine: function intersectionWithLine(line) {
            // Used Kramer's formula see : http://e-maxx.ru/algo/lines_intersection
            var x, y,
                me = this,
                denominator;

            function determinant(a, b, c, d) {
                return a * d - b * c;
            }

            denominator = determinant(me.a, me.b, line.a, line.b);
            if (denominator === 0) {
                return null;
            } else {
                x = -determinant(me.c, me.b, line.c, line.b) / denominator;
                y = -determinant(me.a, me.c, line.a, line.c) / denominator;
                return new DPO.math.Point(x, y);
            }
        }
    });

    /**
     * Creates line object from two points
     * @memberof DPO.math.Line
     * @param {DPO.math.Point|{x: number, y: number}} a
     * @param {DPO.math.Point|{x: number, y: number}} b
     * @returns {DPO.math.Line}
     */
    Line.fromPoints = function fromPoints(a, b) {
        return new Line(a.y - b.y, b.x - a.x, a.x * b.y - b.x * a.y);
    };

    return Line;
});

DPO.def('math.Point', function () {
    /**
     * Creates new point
     * @class DPO.math.Point
     * @memberof DPO.math
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @property {number} x
     * @property {number} y
     * @constructor
     */
    function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }

    DPO.mixin(Point.prototype, {
        /**
         * Translates point by dx and dy
         * @memberof DPO.math.Point#
         * @param {number} dx
         * @param {number} [dy]
         * @returns {DPO.math.Point}
         */
        translate: function translate(dx, dy) {
            dy = dy === undefined ? dx : dy;
            return new Point(this.x + dx, this.y + dy);
        },

        /**
         * Calculates distance to specified point
         * @memberof DPO.math.Point#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @returns {number}
         */
        distanceToPoint: function distanceToPoint(point) {
            var me = this,
                xx = Math.pow(me.x - point.x, 2),
                yy = Math.pow(me.y - point.y, 2);
            return Math.sqrt(xx + yy);
        },

        /**
         * Returns clone
         * @memberof DPO.math.Point#
         * @returns {DPO.math.Point}
         */
        clone: function clone() {
            return new Point(this.x, this.y);
        }
    });

    return Point;
});

DPO.def('math.LineSegment', function () {
    /**
     * @class DPO.math.LineSegment
     * @extends DPO.math.Line
     * @memberof DPO.math
     * @property {DPO.math.Point} start
     * @property {DPO.math.Point} end
     * @param {DPO.math.Point|{x: number, y: number}} start
     * @param {DPO.math.Point|{x: number, y: number}} end
     * @constructor
     */
    function LineSegment(start, end) {
        this.start = new DPO.math.Point(start.x, start.y);
        this.end = new DPO.math.Point(end.x, end.y);

        var l = DPO.math.Line.fromPoints(start, end);
        DPO.math.Line.apply(this, [l.a, l.b, l.c]);
    }

    DPO.inherit(LineSegment, DPO.math.Line);
    DPO.mixin(LineSegment.prototype, {
        /**
         * @memberof DPO.math.LineSegment#
         * @param {DPO.math.Point} point
         * @param {number} [tolerance=0.0001]
         * @returns {boolean}
         */
        containsPoint: function containsPoint(point, tolerance) {
            tolerance = tolerance || 0.000001;
            var me = this,
                x1 = me.start.x,
                y1 = me.start.y,
                x2 = me.end.x,
                y2 = me.end.y,
                boundingBox = new DPO.math.Rect(x1, y1, x2, y2);
            return !(!boundingBox.containsPoint(point) || me.distanceToPoint(point) > tolerance);
        },

        /**
         * Returns segment length
         * @memberof DPO.math.LineSegment#
         * @returns {number}
         */
        length: function () {
            return this.start.distanceToPoint(this.end);
        },

        /**
         * Finds the closest point on the line segment to the specific point
         * @memberof DPO.math.LineSegment#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @returns {DPO.math.Point}
         */
        projectPoint: function projectPoint(point) {
            var me = this,
                perpendicular = me.perpendicularToPoint(point),
                intersection = me.intersectionWithLine(perpendicular);
            if (intersection) {
                return intersection;
            }

            var d1 = me.start.distanceToPoint(point),
                d2 = me.end.distanceToPoint(point),
                p = d1 < d2 ? me.start : me.end;
            return new DPO.math.Point(p.x, p.y);
        },

        /**
         *
         * @memberof DPO.math.LineSegment#
         * @param {DPO.math.Line} line
         * @returns {DPO.math.Point}
         */
        intersectionWithLine: function intersectionWithLine(line) {
            var point = DPO.math.Line.prototype.intersectionWithLine.call(this, line);
            return point && this.containsPoint(point) ? point : null;
        }
    });

    return LineSegment;
});

// Original source https://github.com/adobe-webplatform/Snap.svg/blob/master/src/matrix.js commit 8d75bb48814900b4b9d21ba53201de03fb13cfae
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
DPO.def('math.Matrix', function () {
    /**
     * Create new Matrix object
     * @class DPO.math.Matrix
     * @memberof DPO.math
     * @param {Number} [a]
     * @param {Number} [b]
     * @param {Number} [c]
     * @param {Number} [d]
     * @param {Number} [e]
     * @param {Number} [f]
     * @property {Number} a
     * @property {Number} b
     * @property {Number} c
     * @property {Number} d
     * @property {Number} e
     * @property {Number} f
     * @constructor
     */
    function Matrix(a, b, c, d, e, f) {
        var me = this;
        if (a != null) {
            me.a = +a;
            me.b = +b;
            me.c = +c;
            me.d = +d;
            me.e = +e;
            me.f = +f;
        } else {
            me.a = 1;
            me.b = 0;
            me.c = 0;
            me.d = 1;
            me.e = 0;
            me.f = 0;
        }
    }

    DPO.mixin(Matrix.prototype, {
        /**
         * Adds the given matrix to existing one
         * @memberof DPO.math.Matrix#
         * @param {Number|DPO.math.Matrix} a
         * @param {Number} b
         * @param {Number} c
         * @param {Number} d
         * @param {Number} e
         * @param {Number} f
         */
        add: function add(a, b, c, d, e, f) {
            var me = this,
                out = [[], [], []],
                m = [[me.a, me.c, me.e], [me.b, me.d, me.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            me.a = out[0][0];
            me.b = out[1][0];
            me.c = out[0][1];
            me.d = out[1][1];
            me.e = out[0][2];
            me.f = out[1][2];
            return me;
        },

        /**
         * Returns transformed x coordinate
         * @memberof DPO.math.Matrix#
         * @param {number} x
         * @param {number} y
         * @returns number
         */
        x: function getX(x, y) {
            return x * this.a + y * this.c + this.e;
        },

        /**
         * Returns transformed y coordinate
         * @memberof DPO.math.Matrix#
         * @param {number} x
         * @param {number} y
         * @returns number
         */
        y: function getY(x, y) {
            return x * this.b + y * this.d + this.f;
        },

        /**
         * Returns transformed point
         * @memberof DPO.math.Matrix#
         * @param {number} x
         * @param {number} y
         * @returns {{x: number, y: number}}
         */
        point: function point(x, y) {
            var me = this;
            return {
                x: x * me.a + y * me.c + me.e,
                y: x * me.b + y * me.d + me.f
            };
        },

        /**
         * Returns an inverted version of the matrix
         * @memberof DPO.math.Matrix#
         * @returns {DPO.math.Matrix}
         */
        invert: function invert() {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        },

        /**
         * Returns a copy of the matrix
         * @memberof DPO.math.Matrix#
         * @returns {DPO.math.Matrix}
         */
        clone: function clone() {
            var me = this;
            return new Matrix(me.a, me.b, me.c, me.d, me.e, me.f);
        },

        /**
         * Translate the matrix
         * @memberof DPO.math.Matrix#
         * @param {Number} x horizontal offset distance
         * @param {Number} y vertical offset distance
         * @returns {DPO.math.Matrix}
         */
        translate: function translate(x, y) {
            return this.add(1, 0, 0, 1, x, y);
        },

        /**
         * Scales the matrix
         * @memberof DPO.math.Matrix#
         * @param {Number} x amount to be scaled, with `1` resulting in no change
         * @param {Number} [y]  amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
         * @param {Number} [cx] horizontal origin point from which to scale
         * @param {Number} [cy] vertical origin point from which to scale
         */
        scale: function scale(x, y, cx, cy) {
            if (y == null) {
                //noinspection JSSuspiciousNameCombination
                y = x;
            }
            if (cx || cy) {
                this.add(1, 0, 0, 1, cx, cy);
            }
            this.add(x, 0, 0, y, 0, 0);
            if (cx || cy) {
                this.add(1, 0, 0, 1, -cx, -cy);
            }
            return this;
        },

        /**
         * Rotates the matrix
         * @memberof DPO.math.Matrix#
         * @param {Number} a angle of rotation, in degrees
         * @param {Number} [x] horizontal origin point from which to rotate
         * @param {Number} [y] vertical origin point from which to rotate
         */
        rotate: function rotate(a, x, y) {
            a = DPO.math.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +Math.cos(a).toFixed(9),
                sin = +Math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            return this.add(1, 0, 0, 1, -x, -y);
        }
    });

    return Matrix;
});
DPO.def('math.Polygon', function () {
    /**
     * Create new Polygon object
     * @class DPO.math.Polygon
     * @memberof DPO.math
     * @property {number[]} points
     * @param {number[]} points
     * @constructor
     */
    function Polygon(points) {
        this.points = points;
    }

    DPO.mixin(Polygon.prototype, {
        /**
         * Reverses current polygon
         * @memberof DPO.math.Polygon#
         * @returns {DPO.math.Polygon}
         */
        reverse: function reverse() {
            var me = this,
                p = [],
                points = me.points;
            for (var i = points.length - 1; i > 0; i -= 2) {
                p.push(points[i - 1], points[i]);
            }
            me.points = p;
            return me;
        },

        /**
         * Concatenates two polygons
         * @memberof DPO.math.Polygon#
         * @param polygon
         * @returns {DPO.math.Polygon}
         */
        concat: function concat(polygon) {
            var me = this;
            me.points = me.points.concat(polygon.points);
            return me;
        },

        /**
         * Returns polygons bounds
         * @memberof DPO.math.Polygon#
         * @returns {{x1: number, y1: number, x2: number, y2: number, cx: number, cy: number, width: number, height: number}}
         */
        bounds: function bounds() {
            var x1 = +Infinity,
                y1 = +Infinity,
                x2 = -Infinity,
                y2 = -Infinity,
                points = this.points,
                i, x, y;
            for (i = 1; i < points.length; i += 2) {
                x = points[i - 1];
                y = points[i];
                x1 = Math.min(x1, x);
                y1 = Math.min(y1, y);
                x2 = Math.max(x2, x);
                y2 = Math.max(y2, y);
            }
            return {
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2,
                cx: (x2 + x1) / 2,
                cy: (y2 + y1) / 2,
                width: x2 - x1,
                height: y2 - y1
            };
        },

        /**
         * Transform polygon's points using provided matrix
         * @memberof DPO.math.Polygon#
         * @param {DPO.math.Matrix} matrix
         * @returns {DPO.math.Polygon}
         */
        transform: function transformPoints(matrix) {
            var points = this.points;
            for (var i = 1; i < points.length; i += 2) {
                var p = matrix.point(points[i - 1], points[i]);
                points[i - 1] = p.x;
                points[i] = p.y;
            }
            return this;
        },

        /**
         * Splits polygon to segments
         * @memberof DPO.math.Polygon#
         * @returns {object}
         */
        cutToSegments: function cutToSegments() {
            var me = this,
                points = me.points,
                segments = [],
                p1, p2;

            for (var i = 0, j = 2; i < points.length - 2, j < points.length; i += 2, j += 2) {
                p1 = new DPO.math.Point(points[i], points[i + 1]);
                p2 = new DPO.math.Point(points[j], points[j + 1]);
                segments.push(new DPO.math.LineSegment(p1, p2));
            }
            p1 = new DPO.math.Point(points[points.length - 2], points[points.length - 1]);
            p2 = new DPO.math.Point(points[0], points[1]);
            segments.push(new DPO.math.LineSegment(p1, p2));

            return segments;
        },

        /**
         * Checks if polygon contains point
         * @memberof DPO.math.Polygon#
         * @param {DPO.math.Point|{x:number, y: number}} point
         * @returns {object}
         */
        containsPoint: function containsPoint(point) {
            var segments = this.cutToSegments(),
                inside = false;

            var newPoint = new DPO.math.Point(point.x + 1, point.y),
                lineFromPoint = DPO.math.Line.fromPoints(point, newPoint),
                intersectionLeft = 0,
                intersectionRight = 0;
            for (var k = 0; k < segments.length; k++) {
                var pointIntersection = segments[k].intersectionWithLine(lineFromPoint);
                if (pointIntersection && pointIntersection.x > point.x) {
                    intersectionRight++;
                }
                if (pointIntersection && pointIntersection.x < point.x) {
                    intersectionLeft++;
                }
            }
            if (intersectionLeft === 0 && intersectionRight === 0) {
                inside = false;
            } else if (intersectionLeft % 2 === 1 || intersectionRight % 2 === 1) {
                inside = true;
            }

            return inside;
        },

        /**
         * Returns intersections with line segment
         * @memberof DPO.math.Polygon#
         * @param {DPO.math.LineSegment} lineSegment
         * @returns {DPO.math.Point[]}
         */
        intersectionsWithLineSegment: function intersectionsWithLineSegment(lineSegment) {
            var me = this,
                intersections = [],
                segments = me.cutToSegments();
            for (var i = 0; i < segments.length; i++) {
                var s = segments[i],
                    p = s.intersectionWithLine(lineSegment) && lineSegment.intersectionWithLine(s);
                if (p) {
                    intersections.push(p);
                }
            }
            return intersections;
        },

        /**
         * Returns intersection results
         * @memberof DPO.math.Polygon#
         * @param {DPO.math.Polygon} polygon
         * @returns {object}
         */
        intersectsWithPolygon: function intersectsWithPolygon(polygon) {
            var me = this,
                intersection = null,
                points = polygon.points,
                s1 = me.cutToSegments(),
                s2 = polygon.cutToSegments();

            for (var i = 0; !intersection && i < s1.length; i++) {
                for (var j = 0; !intersection && j < s2.length; j++) {
                    intersection = s1[i].intersectionWithLine(s2[j]) && s2[j].intersectionWithLine(s1[i]);
                }
            }

            var outside = !intersection;
            for (var k = 0; outside && k < points.length - 1; k += 2) {
                outside = !me.containsPoint(new DPO.math.Point(points[k], points[k + 1]));
            }

            return {
                intersection: intersection,
                outside: outside
            };
        },

        /**
         * Finds the closest point on the line segment to the specific point
         * @memberof DPO.math.CubicBezier#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @param {boolean} closed
         * @returns {DPO.math.Point}
         */
        projectPoint: function projectPoint(point, closed) {
            var points = this.points,
                distance = Infinity,
                projectPoint = null,
                p1, p2, lineSegment, pp, d;

            for (var i = 0; i < points.length - 2; i += 2) {
                p1 = {x: points[i], y: points[i + 1]};
                p2 = {x: points[i + 2], y: points[i + 3]};
                lineSegment = new DPO.math.LineSegment(p1, p2);
                pp = lineSegment.projectPoint(point);
                d = pp.distanceToPoint(point);
                if (distance > d) {
                    distance = d;
                    projectPoint = pp;
                }
            }

            if (closed) {
                p1 = {x: points[0], y: points[1]};
                p2 = {x: points[points.length - 2], y: points[points.length - 1]};
                lineSegment = new DPO.math.LineSegment(p1, p2);
                pp = lineSegment.projectPoint(point);
                d = pp.distanceToPoint(point);
                if (distance > d) {
                    projectPoint = pp;
                }
            }

            return projectPoint;
        },

        lengthAtPoint: function lengthAtPoint(point) {
            var points = this.points,
                length = 0,
                p1, p2, lineSegment;

            for (var i = 0; i < points.length - 2; i += 2) {
                p1 = {x: points[i], y: points[i + 1]};
                p2 = {x: points[i + 2], y: points[i + 3]};
                lineSegment = new DPO.math.LineSegment(p1, p2);
                if (lineSegment.containsPoint(point)) {
                    return length + lineSegment.start.distanceToPoint(point);
                } else {
                    length += lineSegment.length();
                }
            }

            return -1;
        }
    });

    return Polygon;
});
DPO.def('math.Rect', function () {
    /**
     * @class DPO.math.Rect
     * @memberof DPO.math
     * @param {number|DPO.math.Rect} x1
     * @param {number} [y1]
     * @param {number} [x2]
     * @param {number} [y2]
     * @property {number} x
     * @property {number} y
     * @property {number} x1
     * @property {number} y1
     * @property {number} x2
     * @property {number} y2
     * @property {number} width
     * @property {number} height
     * @constructor
     */
    function Rect(x1, y1, x2, y2) {
        var me = this;
        if (x1 instanceof DPO.math.Rect) {
            me.x1 = x1.x1;
            me.y1 = x1.y1;
            me.x2 = x1.x2;
            me.y2 = x1.y2;
        } else {
            me.x1 = Math.min(x1 || 0, x2 || 0);
            me.y1 = Math.min(y1 || 0, y2 || 0);
            me.x2 = Math.max(x1 || 0, x2 || 0);
            me.y2 = Math.max(y1 || 0, y2 || 0);
        }
    }

    Object.defineProperty(Rect.prototype, 'x', {
        get: function get() {
            return this.x1;
        },
        set: function set(value) {
            this.x1 = value;
        }
    });

    Object.defineProperty(Rect.prototype, 'y', {
        get: function get() {
            return this.y1;
        },
        set: function set(value) {
            this.y1 = value;
        }
    });

    Object.defineProperty(Rect.prototype, 'width', {
        get: function get() {
            return this.x2 - this.x1;
        }
    });

    Object.defineProperty(Rect.prototype, 'height', {
        get: function get() {
            return this.y2 - this.y1;
        }
    });

    DPO.mixin(Rect.prototype, {
        /**
         * Inflate current rectangle by specified width & height
         * @memberof DPO.math.Rect#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.math.Rect}
         */
        inflate: function inflate(width, height) {
            var me = this;
            me.x1 -= width;
            me.y1 -= height;
            me.x2 += width;
            me.y2 += height;
            return me;
        },

        /**
         * Translate rect by dx & dy
         * @memberof DPO.math.Rect#
         * @param {number} dx
         * @param {number} dy
         * @returns DPO.math.Rect
         */
        translate: function translate(dx, dy) {
            var me = this;
            me.x1 += dx;
            me.y1 += dy;
            me.x2 += dx;
            me.y2 += dy;
            return me;
        },

        /**
         * Creates intersection of rectangles
         * @memberof DPO.math.Rect#
         * @param {DPO.math.Rect} rect
         */
        intersection: function intersection(rect) {
            var me = this,
                x = Math.max(me.x, rect.x),
                x1 = Math.min(me.x2, rect.x2),
                y = Math.max(me.y, rect.y),
                y1 = Math.min(me.y2, rect.y2);
            return x1 >= x && y1 >= y ? new Rect(x1, y1, x, y) : null;
        },

        /**
         * Creates clone of existing rectangle
         * @memberof DPO.math.Rect#
         * @returns {DPO.math.Rect}
         */
        clone: function clone() {
            return new Rect(this);
        },

        /**
         * Check if rectangle contains specified point
         * @memberof DPO.math.Rect#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @param {number} [tolerance]
         * @returns {boolean}
         */
        containsPoint: function containsPoint(point, tolerance) {
            var me = this,
                fn = DPO.closeTo,
                c = true;
            c = c && (me.x1 < point.x || fn(me.x1, point.x, tolerance));
            c = c && (me.x2 > point.x || fn(me.x2, point.x, tolerance));
            c = c && (me.y1 < point.y || fn(me.y1, point.y, tolerance));
            c = c && (me.y2 > point.y || fn(me.y2, point.y, tolerance));
            return c;
        },

        /**
         * Check if rectangle contains specified rectangle
         * @memberof DPO.math.Rect#
         * @param {DPO.math.Rect} rect
         * @param {number} [delta]
         * @returns {boolean}
         */
        containsRect: function containsRect(rect, delta) {
            var me = this,
                points = [ new DPO.math.Point(rect.x1, rect.y1),
                    new DPO.math.Point(rect.x2, rect.y2),
                    new DPO.math.Point(rect.x2, rect.y1),
                    new DPO.math.Point(rect.x1, rect.y2)
                ];
            var contains = true;
            for (var i = 0; i < points.length; i++) {
                contains = contains && me.containsPoint(points[i], delta);
            }
            return contains;
        },

        /**
         * Converts rectangle to polygon
         * @memberof DPO.math.Rect#
         * @returns {DPO.math.Polygon}
         */
        polygonize: function polygonize() {
            var me = this;
            return new DPO.math.Polygon([
                me.x1, me.y1,
                me.x2, me.y1,
                me.x2, me.y2,
                me.x1, me.y2
            ]);
        }
    });

    return Rect;
});
DPO.def('math.Ellipse', function () {
    /**
     * Creates new ellipse object
     * @class DPO.math.Ellipse
     * @param {DPO.math.Point|{x: number, y: number}} center
     * @param {number} a
     * @param {number} b
     * @property {DPO.math.Point} center
     * @property {number} a
     * @property {number} b
     * @constructor
     */
    function Ellipse(center, a, b) {
        var me = this;
        me.center = new DPO.math.Point(center.x, center.y);
        me.a = a;
        me.b = b;
    }

    DPO.mixin(Ellipse.prototype, {
        /**
         * @memberof DPO.math.Ellipse#
         * @param {number} start start angle in degrees
         * @param {number} end end angle in degrees
         * @param {number} steps number of polygonization steps
         * @returns {DPO.math.Polygon}
         */
        polygonize: function polygonize(start, end, steps) {
            var me = this,
                points = [],
                step;

            if (start > end) {
                end += 360;
            }
            step = (end - start) / steps;
            for (var i = start; i < end + step / 2; i += step) {
                var angle = -i * Math.PI / 180;
                points.push(me.a * Math.cos(angle) + me.center.x);
                points.push(me.b * Math.sin(angle) + me.center.y);
            }
            return new DPO.math.Polygon(points);
        },

        /**
         * Returns intersection with specified line
         * @memberof DPO.math.Ellipse#
         * @param {DPO.math.Line} line
         * @returns {DPO.math.Point[]}
         */
        intersectionWithLine: function intersectionWithLine(line) {
            var result = [];
            var me = this,
                x = me.center.x,
                y = me.center.y,
                ea2 = me.a * me.a,
                eb2 = me.b * me.b,
                la2 = line.a * line.a,
                lb2 = line.b * line.b,
                lc2 = line.c * line.c,
                ecx2 = me.center.x * me.center.x,
                ecy2 = me.center.y * me.center.y,
                a = eb2 * lb2 + ea2 * la2,
                b, c, y1, y2, x1, x2;

            if (line.a !== 0) {
                b = 2 * (line.c * line.b * eb2 + eb2 * x * line.a * line.b - y * ea2 * la2);
                c = 2 * x * line.a * line.c * eb2 + ecx2 * eb2 * la2 + ecy2 * la2 * ea2 - la2 * ea2 * eb2 + eb2 * lc2;
                result = DPO.math.resolveQuadraticEquation(a, b, c);
                if (result) {
                    y1 = result.v1;
                    y2 = result.v2;
                    x1 = line.x(y1);
                    x2 = line.x(y2);
                    return [
                        new DPO.math.Point(x1, y1),
                        new DPO.math.Point(x2, y2)
                    ];
                }
            } else {
                b = 2 * (line.c * line.a * ea2 + y * line.a * line.b * ea2 - x * eb2 * lb2);
                c = 2 * y * line.a * line.c * ea2 + ecx2 * eb2 * lb2 + ecy2 * lb2 * ea2 - lb2 * ea2 * eb2 + ea2 * lc2;
                result = DPO.math.resolveQuadraticEquation(a, b, c);
                if (result) {
                    x1 = result.v1;
                    x2 = result.v2;
                    y1 = line.y(x1);
                    y2 = line.y(x2);
                    return [
                        new DPO.math.Point(x1, y1),
                        new DPO.math.Point(x2, y2)
                    ];
                }
            }
            return [];
        },

        /**
         * Return approximations for the ellipse circumference. Max inaccuracy ~0.63%
         * @memberof DPO.math.Ellipse#
         * @returns {number}
         */
        perimeterApproximation: function perimeterApproximation() {
            var me = this,
                s = Math.pow(me.a - me.b, 2),
                l = 4 * (Math.PI * me.a * me.b + s);
            return l / (me.a + me.b);
        },

        /**
         * Return end angle of circumference
         * @memberof DPO.math.Ellipse#
         * @param {number} start start angle of circumference in radians
         * @param {number} length length of circumference
         * @param {number} [accuracy]
         * @returns {number}
         */
        endOfCircumference: function endOfCircumference(start, length, accuracy) {
            var me = this;
            if (me.b > me.a) {
                var e = new DPO.math.Ellipse(me.center, me.b, me.a);
                return e.endOfCircumference(start + Math.PI / 2, length, accuracy) - Math.PI / 2;
            }

            accuracy = accuracy || me.a * 0.01;

            function dt(t) {
                var alpha = t % Math.PI,
                    x = me.a * Math.cos(alpha),
                    next = x + accuracy;
                if (next > me.a) {
                    next = x - accuracy;
                }

                var betta = Math.acos(next / me.a);
                return Math.abs(alpha - betta);
            }

            var value = 0,
                a2 = me.a * me.a,
                b2 = me.b * me.b,
                t = start,
                step = 0,
                p = Math.sqrt((a2 + b2) / 2),
                q = (a2 - b2) / (a2 + b2);

            while (value < length) {
                step = dt(t);

                var w = 1 - q * Math.cos(2 * t),
                    f = p * Math.sqrt(w);
                value += f * step;

                if (value >= length) {
                    return t;
                }

                t += step;
            }

            return t;
        }
    });

    return Ellipse;
});

DPO.def('math.CubicBezier', function () {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    var Tvalues = [
        -0.0640568928626056260850430826247450385909,
        0.0640568928626056260850430826247450385909,
        -0.1911188674736163091586398207570696318404,
        0.1911188674736163091586398207570696318404,
        -0.3150426796961633743867932913198102407864,
        0.3150426796961633743867932913198102407864,
        -0.4337935076260451384870842319133497124524,
        0.4337935076260451384870842319133497124524,
        -0.5454214713888395356583756172183723700107,
        0.5454214713888395356583756172183723700107,
        -0.6480936519369755692524957869107476266696,
        0.6480936519369755692524957869107476266696,
        -0.7401241915785543642438281030999784255232,
        0.7401241915785543642438281030999784255232,
        -0.8200019859739029219539498726697452080761,
        0.8200019859739029219539498726697452080761,
        -0.8864155270044010342131543419821967550873,
        0.8864155270044010342131543419821967550873,
        -0.9382745520027327585236490017087214496548,
        0.9382745520027327585236490017087214496548,
        -0.9747285559713094981983919930081690617411,
        0.9747285559713094981983919930081690617411,
        -0.9951872199970213601799974097007368118745,
        0.9951872199970213601799974097007368118745
    ];

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    var Cvalues = [
        0.1279381953467521569740561652246953718517,
        0.1279381953467521569740561652246953718517,
        0.1258374563468282961213753825111836887264,
        0.1258374563468282961213753825111836887264,
        0.1216704729278033912044631534762624256070,
        0.1216704729278033912044631534762624256070,
        0.1155056680537256013533444839067835598622,
        0.1155056680537256013533444839067835598622,
        0.1074442701159656347825773424466062227946,
        0.1074442701159656347825773424466062227946,
        0.0976186521041138882698806644642471544279,
        0.0976186521041138882698806644642471544279,
        0.0861901615319532759171852029837426671850,
        0.0861901615319532759171852029837426671850,
        0.0733464814110803057340336152531165181193,
        0.0733464814110803057340336152531165181193,
        0.0592985849154367807463677585001085845412,
        0.0592985849154367807463677585001085845412,
        0.0442774388174198061686027482113382288593,
        0.0442774388174198061686027482113382288593,
        0.0285313886289336631813078159518782864491,
        0.0285313886289336631813078159518782864491,
        0.0123412297999871995468056670700372915759,
        0.0123412297999871995468056670700372915759
    ];

    /**
     * @class DPO.math.CubicBezier
     * @memberof DPO.math
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {number} x4
     * @param {number} y4
     * @property {object} points
     * @property {object} dpoints
     * @constructor
     */
    function CubicBezier(x1, y1, x2, y2, x3, y3, x4, y4) {
        var me = this;
        me.points = [{
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        }, {
            x: x3,
            y: y3
        }, {
            x: x4,
            y: y4
        }];
        me.update();
    }

    DPO.mixin(CubicBezier.prototype, {
        update: function update() {
            var me = this;
            me.dpoints = [];

            for (var p = me.points, d = p.length, c = d - 1; d > 1; d--, c--) {
                var list = [];
                for (var j = 0; j < c; j++) {
                    list.push({
                        x: c * (p[j + 1].x - p[j].x),
                        y: c * (p[j + 1].y - p[j].y)
                    });
                }
                me.dpoints.push(list);
                p = list;
            }
        },

        /**
         * Calculates the curve tangent at the specified t value
         * @memberof DPO.math.CubicBezier#
         * @param {number} t
         * @returns {{x: number, y: number}} a not-normalized vector {x: dx, y: dy}
         */
        derivative: function derivative(t) {
            var mt = 1 - t,
                p = this.dpoints[0],
                a = mt * mt,
                b = mt * t * 2,
                c = t * t;
            return {
                x: a * p[0].x + b * p[1].x + c * p[2].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y
            };
        },

        /**
         * Calculates the curve normal at the specified t value
         * @memberof DPO.math.CubicBezier#
         * @param {number} t
         * @returns {{x: number, y: number}} normalised vector {x: nx, y: ny}.
         */
        normal: function normal(t) {
            var d = this.derivative(t),
                q = Math.sqrt(d.x * d.x + d.y * d.y);
            return {x: -d.y / q, y: d.x / q};
        },

        /**
         * Calculates a point on the curve
         * @memberof DPO.math.CubicBezier#
         * @param {number} t
         * @returns {{x: number, y : number}}
         */
        compute: function compute(t) {
            var me = this;
            switch (t) {
                case 0:
                    return me.points[0];
                case 1:
                    return me.points[me.points.length - 1];
            }

            var mt = 1 - t,
                mt2 = mt * mt,
                t2 = t * t,
                p = me.points,
                a = mt2 * mt,
                b = mt2 * t * 3,
                c = mt * t2 * 3,
                d = t * t2;

            return {
                x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
            };
        },

        /**
         * Return t value at specific length
         * @memberof DPO.math.CubicBezier#
         * @param {number} length
         * @param {number} [e]
         * @returns {number}
         */
        getValueAtLength: function getValueAtLength(length, e) {
            var me = this,
                totalLength = me.getLength();
            e = e || 0.01;
            if (length <= 0) {
                return 0;
            }

            if (length >= totalLength) {
                return 1;
            }

            var step = 0.5,
                t2 = length / totalLength,
                currentLength = me.getLength(t2);
            while (Math.abs(currentLength - length) > e) {
                step /= 2;
                t2 += (currentLength < length ? 1 : -1) * step;
                currentLength = me.getLength(t2);
            }
            return t2;
        },

        /**
         * Returns curve length
         * @memberof DPO.math.CubicBezier#
         * @param {number} [end]
         * @returns {number}
         */
        getLength: function getLength(end) {
            if (end === undefined) {
                end = 1;
            }

            var z = end / 2,
                sum = 0,
                len = Tvalues.length,
                i, t, d;
            for (i = 0; i < len; i++) {
                t = z * Tvalues[i] + z;
                d = this.derivative(t);
                sum += Cvalues[i] * Math.sqrt(d.x * d.x + d.y * d.y);
            }
            return z * sum;
        },

        /**
         * Finds the closest point on the line segment to the specific point
         * @memberof DPO.math.CubicBezier#
         * @param {DPO.math.Point|{x: number, y: number}} point
         * @param {number} [steps]
         * @returns {DPO.math.Point}
         */
        projectPoint: function projectPoint(point, steps) {
            steps = steps || 64;
            var me = this,
                points = [],
                dt = 1 / steps;
            for (var t = 0; t < 1; t += dt) {
                points.push(me.compute(t));
            }
            points.push(me.compute(1));

            var distance = Infinity,
                projectPoint = null;
            for (var i = 1; i < points.length; i++) {
                var p1 = points[i - 1],
                    p2 = points[i],
                    lineSegment = new DPO.math.LineSegment(p1, p2),
                    pp = lineSegment.projectPoint(point),
                    d = pp.distanceToPoint(point);
                if (distance > d) {
                    distance = d;
                    projectPoint = pp;
                }
            }

            return projectPoint;
        },

        toSVG: function toSVG() {
            function p(point) {
                return point.x + ' ' + point.y;
            }

            var pt = this.points;
            return 'M' + p(pt[0]) + ' C' + p(pt[1]) + ' ' + p(pt[2]) + ' ' + p(pt[3]);
        }
    });

    DPO.mixin(CubicBezier.prototype, {
        roots: function roots(a, b, c, d) {
            if (Math.abs(a) < 1e-8) { // Quadratic case, ax^2+bx+c=0
                a = b;
                b = c;
                c = d;
                if (Math.abs(a) < 1e-8) { // Linear case, ax+b=0
                    a = b;
                    b = c;
                    if (Math.abs(a) < 1e-8) { // Degenerate case
                        return [];
                    }
                    return [-b / a];
                }

                var discriminant = b * b - 4 * a * c;
                if (Math.abs(discriminant) < 1e-8) {
                    return [-b / (2 * a)];
                } else if (discriminant > 0) {
                    return [(-b + Math.sqrt(discriminant)) / (2 * a), (-b - Math.sqrt(discriminant)) / (2 * a)];
                }
                return [];
            }

            // Base source here https://www.particleincell.com/2013/cubic-line-intersection/
            var sgn = DPO.math.sign,
                A = b / a,
                B = c / a,
                C = d / a,
                Q = (3 * B - Math.pow(A, 2)) / 9,
                R = (9 * A * B - 27 * C - 2 * Math.pow(A, 3)) / 54,
                D = Math.pow(Q, 3) + Math.pow(R, 2),
                t = [-1, -1, -1],
                Im;

            if (D >= 0) {
                var S = sgn(R + Math.sqrt(D)) * Math.pow(Math.abs(R + Math.sqrt(D)), (1 / 3)),
                    T = sgn(R - Math.sqrt(D)) * Math.pow(Math.abs(R - Math.sqrt(D)), (1 / 3));
                t[0] = -A / 3 + (S + T);
                t[1] = -A / 3 - (S + T) / 2;
                t[2] = -A / 3 - (S + T) / 2;
                Im = Math.abs(Math.sqrt(3) * (S - T) / 2);

                if (Im !== 0) {
                    t[1] = -1;
                    t[2] = -1;
                }
            } else {
                var th = Math.acos(R / Math.sqrt(-Math.pow(Q, 3)));
                t[0] = 2 * Math.sqrt(-Q) * Math.cos(th / 3) - A / 3;
                t[1] = 2 * Math.sqrt(-Q) * Math.cos((th + 2 * Math.PI) / 3) - A / 3;
                t[2] = 2 * Math.sqrt(-Q) * Math.cos((th + 4 * Math.PI) / 3) - A / 3;
            }

            return t;
        },

        /**
         * Returns intersections with line
         * @memberof DPO.math.CubicBezier#
         * @param {DPO.math.Line} line
         * @returns {number[]}
         */
        intersectionsWithLine: function intersectionsWithLine(line) {
            function bezierCoefficients(a, b, c, d) {
                return [-a + 3 * b + -3 * c + d, 3 * a - 6 * b + 3 * c, -3 * a + 3 * b, a];
            }

            var me = this,
                a = -line.a,
                b = -line.b,
                c = -line.c,
                p = me.points,
                bxc = bezierCoefficients(p[0].x, p[1].x, p[2].x, p[3].x),
                byc = bezierCoefficients(p[0].y, p[1].y, p[2].y, p[3].y),
                ea = a * bxc[0] + b * byc[0],
                eb = a * bxc[1] + b * byc[1],
                ec = a * bxc[2] + b * byc[2],
                ed = a * bxc[3] + b * byc[3] + c,
                roots = me.roots(ea, eb, ec, ed);
            return roots.filter(function (t) {
                return 0 <= t && t <= 1;
            }).sort();
        }
    });

    CubicBezier.fromLinear = function fromLinear(x1, y1, x2, y2) {
        var dx = x2 - x1,
            dy = y2 - y1;
        return new CubicBezier(x1, y1, x1 + dx / 3, y1 + dy / 3, x1 + dx * 2 / 3, y1 + dy * 2 / 3, x2, y2);
    };

    CubicBezier.fromQuadratic = function fromQuadratic(x1, y1, x2, y2, x3, y3) {
        var x2q = x1 + 2 / 3 * (x2 - x1),
            y2q = y1 + 2 / 3 * (y2 - y1),
            x3q = x3 + 2 / 3 * (x2 - x3),
            y3q = y3 + 2 / 3 * (y2 - y3);
        return new CubicBezier(x1, y1, x2q, y2q, x3q, y3q, x3, y3);
    };

    return CubicBezier;
});
DPO.def('crypto.SHA1', function () {
    function safeAdd(x, y) {
        //noinspection NonShortCircuitBooleanExpressionJS
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        //noinspection NonShortCircuitBooleanExpressionJS
        return (msw << 16) | (lsw & 0xFFFF);
    }

    function rol(num, cnt) {
        //noinspection NonShortCircuitBooleanExpressionJS
        return (num << cnt) | (num >>> (32 - cnt));
    }

    function tripletCombination(t, b, c, d) {
        if (t < 20) {
            //noinspection NonShortCircuitBooleanExpressionJS
            return (b & c) | ((~b) & d);
        }
        if (t < 40) {
            return b ^ c ^ d;
        }
        if (t < 60) {
            //noinspection NonShortCircuitBooleanExpressionJS
            return (b & c) | (b & d) | (c & d);
        }
        return b ^ c ^ d;
    }

    function additiveConstant(t) {
        //noinspection NestedConditionalExpressionJS
        return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514;
    }

    /**
     * @class DPO.crypto.SHA1
     * @memberof DPO.crypto
     * @param {object} [cfg]
     * @constructor
     */
    function SHA1(cfg) {
        cfg = cfg || {};
        DPO.mixin(this, cfg);
    }

    DPO.mixin(SHA1.prototype, {
        /**
         * Converts string to big-endian word array
         * @param {string} str
         * @returns {Array}
         */
        strToBigEndianWords: function strToBigEndianWords(str) {
            var bin = [],
                mask = (1 << 8) - 1;
            for (var i = 0; i < str.length * 8; i += 8) {
                //noinspection NonShortCircuitBooleanExpressionJS
                bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << (32 - 8 - i % 32);
            }
            return bin;
        },

        sha1Core: function sha1Core(x, len) {
            x[len >> 5] |= 0x80 << (24 - len % 32);
            x[((len + 64 >> 9) << 4) + 15] = len;

            var w = new Int32Array(80),
                a = 1732584193,
                b = -271733879,
                c = -1732584194,
                d = 271733878,
                e = -1009589776;

            for (var i = 0; i < x.length; i += 16) {
                var oldA = a,
                    oldB = b,
                    oldC = c,
                    oldD = d,
                    oldE = e;

                for (var j = 0; j < 80; j++) {
                    w[j] = j < 16 ? x[i + j] : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);

                    var t = safeAdd(safeAdd(rol(a, 5), tripletCombination(j, b, c, d)), safeAdd(safeAdd(e, w[j]), additiveConstant(j)));
                    e = d;
                    d = c;
                    c = rol(b, 30);
                    b = a;
                    a = t;
                }

                a = safeAdd(a, oldA);
                b = safeAdd(b, oldB);
                c = safeAdd(c, oldC);
                d = safeAdd(d, oldD);
                e = safeAdd(e, oldE);
            }
            return [a, b, c, d, e];
        },

        /**
         * Converts hash to HEX string
         * @memberof DPO.crypto.SHA1#
         * @param {array} bin
         * @returns {string}
         */
        hex: function hex(bin) {
            var haxTable = '0123456789abcdef',
                str = '';
            for (var i = 0; i < bin.length * 4; i++) {
                //noinspection NonShortCircuitBooleanExpressionJS
                str += haxTable.charAt((bin[i >> 2] >> ((3 - i % 4) * 8 + 4)) & 0xF) + haxTable.charAt((bin[i >> 2] >> ((3 - i % 4) * 8  )) & 0xF);
            }
            return str;
        },

        /**
         * Converts hash Base64 string
         * @param {string} bin
         * @returns {string}
         */
        base64: function base64(bin) {
            var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                b64pad = '=',
                str = '';
            for (var i = 0; i < bin.length * 4; i += 3) {
                //noinspection NonShortCircuitBooleanExpressionJS
                var triplet = (((bin[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16)
                    | (((bin[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8 )
                    | ((bin[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
                for (var j = 0; j < 4; j++) {
                    if (i * 8 + j * 6 > bin.length * 32) {
                        str += b64pad;
                    }
                    else {
                        //noinspection NonShortCircuitBooleanExpressionJS
                        str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);
                    }
                }
            }
            return str;
        },

        /**
         * Computes SHA1 hash
         * @param {string} str
         * @returns {array}
         */
        sha1: function sha1(str) {
            var me = this,
                binStr = me.strToBigEndianWords(str);
            return me.sha1Core(binStr, str.length * 8);
        },

        /**
         * Computes a Hash-based message authentication code (HMAC) using a secret key
         * @memberof DPO.crypto.SHA1#
         * @param {string} key
         * @param {string} data
         * @returns {array}
         */
        hmac: function hmac(key, data) {
            var me = this,
                binKey = me.strToBigEndianWords(key);
            if (binKey.length > 16) {
                binKey = me.sha1Core(binKey, key.length * 8);
            }

            var innerPadding = new Array(16),
                outerPadding = new Array(16);
            for (var i = 0; i < 16; i++) {
                innerPadding[i] = binKey[i] ^ 0x36363636;
                outerPadding[i] = binKey[i] ^ 0x5C5C5C5C;
            }

            var binData = me.strToBigEndianWords(data),
                hash = me.sha1Core(innerPadding.concat(binData), 512 + data.length * 8);
            return me.sha1Core(outerPadding.concat(hash), 512 + 160);
        }
    });

    return SHA1;
});

DPO.def('xml.Model', function() {
    /**
     * @class DPO.xml.Model
     * @memberof DPO.xml
     * @property {string} internalId
     * @property {*} value
     * @property {object[]} items
     * @property {object} valueBinding
     * @property {string} dpoName
     * @constructor
     */
    function Model() {
    }

    DPO.mixin(Model.prototype, {
        attributesBinding: null,
        elementBinding: null,
        modelsBinding: null,
        itemsBinding: null,
        valueBinding: null
    });

    return Model;
});
DPO.def('xml.Introspector', function () {
    /**
     * @class DPO.xml.Introspector
     * @memberof DPO.model
     * @param {object} [cfg]
     * @constructor
     */
    function Introspector(cfg) {
        DPO.mixin(this, cfg);
    }

    DPO.mixin(Introspector.prototype, {
        modelLookupTable: null,
        initializeDefaultsValues: true,

        mataDataCache: {
            models: {},
            attributes: {},
            items: {},
            elements: {}
        },

        types: {
            'string': {
                fromStr: function fromStr(value) {
                    return value;
                },

                toStr: function toStr(value) {
                    return value;
                }
            },

            'number': {
                fromStr: function fromStr(value) {
                    return value - 0;
                },

                toStr: function toStr(value) {
                    return value + '';
                }
            },

            'bool': {
                fromStr: function fromStr(value) {
                    return value === 'true';
                },

                toStr: function toStr(value) {
                    return value ? 'true' : 'false';
                }
            }
        }
    });

    DPO.mixin(Introspector.prototype, {
        /**
         * Returns attributes' metadata
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         */
        collectAttributesMetadata: function collectAttributesMetadata(model) {
            var attributes = this.mataDataCache.attributes[model.dpoName];
            if (attributes) {
                return attributes;
            }

            var prototype = Object.getPrototypeOf(model);
            for (attributes = []; prototype !== null; prototype = Object.getPrototypeOf(prototype)) {
                if (prototype.hasOwnProperty('attributesBinding')) {
                    attributes = (prototype.attributesBinding || []).concat(attributes);
                }
            }

            this.mataDataCache.attributes[model.dpoName] = attributes;
            return attributes;
        },

        /**
         * Returns models  metadata
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         */
        collectModelsMetadata: function collectModelsMetadata(model) {
            var models = this.mataDataCache.models[model.dpoName];
            if (models) {
                return models;
            }

            var prototype = Object.getPrototypeOf(model);
            for (models = []; prototype !== null; prototype = Object.getPrototypeOf(prototype)) {
                if (prototype.hasOwnProperty('modelsBinding')) {
                    models = (prototype.modelsBinding || []).concat(models);
                }
            }

            this.mataDataCache.models[model.dpoName] = models;
            return models;
        },

        /**
         * Returns model's items metadata
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         */
        collectItemsMetadata: function collectItemsMetadata(model) {
            var items = this.mataDataCache.items[model.dpoName];
            if (items) {
                return items;
            }

            var prototype = Object.getPrototypeOf(model);
            for (items = []; prototype !== null; prototype = Object.getPrototypeOf(prototype)) {
                if (prototype.hasOwnProperty('itemsBinding')) {
                    items = (prototype.itemsBinding || []).concat(items);
                }
            }

            this.mataDataCache.items[model.dpoName] = items;
            return items;
        },

        /**
         * Returns model's elements metadata
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         */
        collectElementsMetadata: function collectElementsMetadata(model) {
            var elements = this.mataDataCache.elements[model.dpoName];
            if (elements) {
                return elements;
            }

            var prototype = Object.getPrototypeOf(model);
            for (elements = []; prototype !== null; prototype = Object.getPrototypeOf(prototype)) {
                if (prototype.hasOwnProperty('elementBinding')) {
                    elements = (prototype.elementBinding || []).concat(elements);
                }
            }

            this.mataDataCache.elements[model.dpoName] = elements;
            return elements;
        },

        /**
         * Initializes model's collections
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         * @returns {DPO.xml.Introspector}
         */
        initCollection: function initCollection(model) {
            var me = this,
                models = me.collectModelsMetadata(model),
                i, binding;
            for (i = 0; i < models.length; i++) {
                binding = models[i];
                if (binding.collection) {
                    model[binding.name] = [];
                }
            }

            var items = me.collectItemsMetadata(model);
            if (items.length) {
                model.items = [];
            }

            return me;
        },

        /**
         * Initializes model's attributes
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         * @returns {DPO.xml.Introspector}
         */
        initAttributes: function initAttributes(model) {
            var me = this,
                attributes = me.collectAttributesMetadata(model),
                elements = me.collectElementsMetadata(model),
                i, binding;

            for (i = 0; i < attributes.length; i++) {
                binding = attributes[i];
                if (binding.defaultValue !== undefined) {
                    model[binding.propName || binding.name] = binding.defaultValue;
                }
            }

            for (i = 0; i < elements.length; i++) {
                binding = elements[i];
                if (binding.defaultValue !== undefined) {
                    model[binding.propName || binding.name] = binding.defaultValue;
                }
            }

            return me;
        },

        /**
         * Initializes required nested models
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} model
         * @returns {DPO.xml.Introspector}
         */
        initRequiredModels: function initRequiredModels(model) {
            var models = this.collectModelsMetadata(model),
                i, binding;
            for (i = 0; i < models.length; i++) {
                binding = models[i];
                if (binding.required) {
                    model[binding.propName || binding.name] = this.instantiate(binding.cls);
                }
            }

            return this;
        },

        /**
         * Performs deep model copying
         * @memberof DPO.xml.Introspector#
         * @param {DPO.xml.Model} from
         * @param {DPO.xml.Model} to
         * @returns {DPO.xml.Introspector}
         */
        deepModelCopy: function deepCopy(from, to) {
            var me = this,
                models = me.collectModelsMetadata(from),
                attributes = me.collectAttributesMetadata(from),
                elements = me.collectElementsMetadata(from),
                items = me.collectItemsMetadata(from),
                i, binding, value;
            for (i = 0; i < attributes.length; i++) {
                binding = attributes[i];
                value = from[binding.name];
                if (value !== undefined) {
                    to[binding.propName || binding.name] = me.clone(value);
                }
            }

            for (i = 0; i < elements.length; i++) {
                binding = elements[i];
                value = from[binding.name];
                if (value !== undefined) {
                    to[binding.propName || binding.name] = me.clone(value);
                }
            }

            for (i = 0; i < models.length; i++) {
                binding = models[i];
                value = from[binding.name];
                if (value === undefined) {
                    continue;
                }

                to[binding.name] = me.clone(value);
            }

            if (from.valueBinding && from.value !== undefined) {
                to.value = me.clone(from.value);
            }

            if (items.length === 0) {
                return me;
            }

            to.items = [];
            for (i = 0; i < from.items.length; i++) {
                to.items.push(me.clone(from.items[i]));
            }

            return me;
        },

        /**
         /**
         * Deep object clone
         * @memberof DPO.xml.Introspector#
         * @template T
         * @param {T} obj
         * @returns {T}
         */
        clone: function clone_(obj) {
            var me = this, cln, keys, i;
            if (obj instanceof DPO.xml.Model) {
                cln = /** @type DPO.xml.Model */ new obj.constructor();
                if (me.initializeDefaultsValues) {
                    me.initAttributes(cln);
                }
                me.initCollection(cln);
                me.deepModelCopy(obj, cln);
                return cln;
            }

            if (obj instanceof Array) {
                cln = [];
                for (i = 0; i < obj.length; i++) {
                    cln[i] = me.clone(obj[i]);
                }
                return cln;
            }

            if (obj instanceof Object) {
                keys = Object.keys(obj);
                cln = {};
                for (i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    cln[key] = me.clone(obj[key]);
                }
                return cln;
            }

            return obj;
        },

        /**
         * Creates model object and initializes default values.
         * @memberof DPO.xml.Introspector#
         * @param {function|string} cls Model constructor or model name
         * @returns {*}
         */
        instantiate: function instantiate(cls) {
            cls = typeof cls === 'string' ? this.modelLookupTable[cls] : cls;
            var obj = /** @type DPO.xml.Model */ new cls();
            this.initCollection(obj).initAttributes(obj).initRequiredModels(obj);
            return obj;
        }
    });

    return Introspector;
});
DPO.def('xml.Deserializer', function () {
    /**
     * @class DPO.xml.Deserializer
     * @memberof DPO.model
     * @param cls
     * @param cfg
     * @constructor
     */
    function Deserializer(cls, cfg) {
        this.introspector = new DPO.xml.Introspector(cfg);
        this.cls = cls;
        DPO.mixin(this, cfg);
    }

    DPO.inherit(Deserializer, DPO.xml.Introspector);
    DPO.mixin(Deserializer.prototype, {
        /**
         * Deserializes model's attributes
         * @memberof DPO.xml.Deserializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        deserializeAttributes: function deserializeAttributes(obj, el) {
            var me = this,
                introspector = me.introspector,
                attributes = introspector.collectAttributesMetadata(obj);
            for (var i = 0; i < attributes.length; i++) {
                var binding = attributes[i],
                    type = introspector.types[binding.type || 'string'],
                    node = el.getAttributeNode(binding.name);
                if (node) {
                    obj[binding.propName || binding.name] = type.fromStr(node.value);
                }
            }
        },

        /**
         * Deserializes nested model
         * @memberof DPO.xml.Deserializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        deserializeModels: function deserializeModels(obj, el) {
            var me = this,
                introspector = me.introspector,
                elements = introspector.collectModelsMetadata(obj);
            if (elements.length === 0) {
                return;
            }
            var children = el.childNodes,
                child, binding, model, nodes;

            function findNodes(nodeName) {
                var nodes = [];
                for (var i = 0; i < children.length; i++) {
                    var node = children[i];
                    if (node.nodeName === nodeName) {
                        nodes.push(node);
                    }
                }

                return nodes;
            }

            for (var i = 0; i < elements.length; i++) {
                binding = elements[i];
                nodes = findNodes(binding.el);
                for (var j = 0; j < nodes.length; j++) {
                    child = nodes[j];
                    model = new binding.cls();
                    me.deserializeModel(model, child);
                    if (binding.collection) {
                        obj[binding.name].push(model);
                    } else {
                        obj[binding.name] = model;
                    }
                }
            }
        },

        /**
         * Deserializes model items
         * @memberof DPO.xml.Deserializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        deserializeItems: function deserializeItems(obj, el) {
            var me = this,
                introspector = me.introspector,
                items = introspector.collectItemsMetadata(obj);
            if (items.length === 0) {
                return;
            }

            function find(name) {
                for (var i = 0; i < items.length; i++) {
                    var binding = items[i];
                    if (binding.el === name) {
                        return binding;
                    }
                }

                return null;
            }

            obj.items = [];

            var children = el.childNodes,
                child, binding, model;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                binding = find(child.nodeName);
                if (!binding) {
                    continue;
                }

                model = new binding.cls();
                me.deserializeModel(model, child);
                obj.items.push(model);
            }
        },

        /**
         * Deserializes model value
         * @memberof DPO.xml.Deserializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        deserializeValue: function deserializeValue(obj, el) {
            var me = this,
                introspector = me.introspector;
            if (obj.valueBinding) {
                var type = introspector.types[obj.valueBinding.type || 'string'];
                obj.value = type.fromStr(el.textContent);
            }
        },

        /**
         * Deserializes model elements
         * @memberof DPO.xml.Deserializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        deserializeElements: function deserializeElements(obj, el) {
            var me = this,
                introspector = me.introspector,
                elements = introspector.collectElementsMetadata(obj);
            if (elements.length === 0) {
                return;
            }
            var children = el.childNodes,
                type, value, child, binding, nodes;

            function findNodes(nodeName) {
                var nodes = [];
                for (var i = 0; i < children.length; i++) {
                    var node = children[i];
                    if (node.nodeName === nodeName) {
                        nodes.push(node);
                    }
                }

                return nodes;
            }

            for (var i = 0; i < elements.length; i++) {
                binding = elements[i];
                type = introspector.types[binding.type || 'string'];
                nodes = findNodes(binding.el);
                for (var j = 0; j < nodes.length; j++) {
                    child = nodes[j];
                    value = child.textContent;
                    obj[binding.propName || binding.el] = type.fromStr(child.textContent);
                }
            }
        },

        /**
         * Deserializes xml
         * @memberof DPO.xml.Deserializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         * @returns {*}
         */
        deserializeModel: function deserializeModel(obj, el) {
            var me = this;
            if (me.initializeDefaultsValues) {
                me.initAttributes(obj);
            }
            me.initCollection(obj);
            me.initRequiredModels(obj);
            me.deserializeValue(obj, el);
            me.deserializeAttributes(obj, el);
            me.deserializeModels(obj, el);
            me.deserializeElements(obj, el);
            me.deserializeItems(obj, el);
        },

        /**
         * Deserializes xml
         * @memberof DPO.xml.Deserializer#
         * @param {Document} doc
         * @returns {*}
         */
        deserialize: function deserialize(doc) {
            var me = this,
                introspector = me.introspector,
                model = introspector.instantiate(me.cls),
                el = doc.documentElement;
            me.deserializeModel(model, el);
            return model;
        }
    });

    return Deserializer;
});
DPO.def('xml.Serializer', function () {
    /**
     * @class DPO.xml.Serializer
     * @memberof DPO.xml
     * @param cfg
     * @constructor
     */
    function Serializer(cfg) {
        this.introspector = new DPO.xml.Introspector(cfg);
        DPO.mixin(this, cfg);
    }

    DPO.mixin(Serializer.prototype, {
        normalizeDefaultsValues: true,

        /**
         * Serializes model's attributes
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        serializeAttributes: function serializeAttributes(obj, el) {
            var me = this,
                introspector = me.introspector,
                attributes = introspector.collectAttributesMetadata(obj);
            for (var i = 0; i < attributes.length; i++) {
                var binding = attributes[i],
                    type = introspector.types[binding.type || 'string'],
                    value = obj[binding.propName || binding.name];
                if (value == null) {
                    continue;
                }

                if (value !== binding.defaultValue || !me.normalizeDefaultsValues) {
                    el.setAttribute(binding.name, type.toStr(value));
                }
            }
        },

        /**
         * Serializes nested attributes
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        serializeModels: function serializeModels(obj, el) {
            var me = this,
                introspector = me.introspector,
                elements = introspector.collectModelsMetadata(obj), node;
            for (var i = 0; i < elements.length; i++) {
                var binding = elements[i],
                    objects = [].concat(obj[binding.name]);
                for (var j = 0; j < objects.length; j++) {
                    var model = objects[j];
                    if (model) {
                        if (binding.ns) {
                            node = el.ownerDocument.createElementNS(binding.ns, binding.el);
                            // xmldom npm package doesn't initialize xmlns attribute so we should set it manually
                            // typeof window === 'undefined' in NodeJS
                            if (typeof window === 'undefined') {
                                node.setAttribute('xmlns', binding.ns);
                            }
                        } else {
                            node = el.ownerDocument.createElement(binding.el);
                        }
                        me.serializeModel(model, node);
                        el.appendChild(node);
                    }
                }
            }
        },

        /**
         * Serializes model's items
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        serializeItems: function serializeItems(obj, el) {
            var itemsBinding = obj.itemsBinding,
                map = {}, i;
            if (!itemsBinding) {
                return;
            }

            for (i = 0; i < itemsBinding.length; i++) {
                var b = itemsBinding[i];
                map[b.cls.prototype.dpoName] = b.el;
            }

            for (i = 0; i < obj.items.length; i++) {
                var model = /** @type DPO.xml.Model*/obj.items[i],
                    nodeName = map[model.dpoName],
                    node = el.ownerDocument.createElement(nodeName);
                this.serializeModel(model, node);
                el.appendChild(node);
            }
        },

        /**
         * Serializes model's value
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} obj
         * @param {Element} el
         */
        serializeValue: function serializeValue(obj, el) {
            var me = this,
                introspector = me.introspector;
            if (obj.valueBinding) {
                var type = introspector.types[obj.valueBinding.type || 'string'];
                el.textContent = type.toStr(obj.value);
            }
        },

        /**
         * Serializes model to specified xml element
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} model
         * @param {Element} el
         */
        serializeModel: function serializeModel(model, el) {
            this.serializeValue(model, el);
            this.serializeAttributes(model, el);
            this.serializeModels(model, el);
            this.serializeItems(model, el);
        },

        /**
         * Serializes model
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} model
         * @param {string} ns
         * @param {string} root
         * @returns {Document}
         */
        serialize: function serialize(model, ns, root) {
            var doc = document.implementation.createDocument(ns, root, null),
                el = doc.documentElement;
            this.serializeModel(model, el);
            return doc;
        },

        /**
         * Serializes whole model to XML format
         * @memberof DPO.xml.Serializer#
         * @param {DPO.xml.Model} model
         * @param {?string} ns
         * @param {string} root
         * @returns {string}
         */
        serializeToXML: function serializeToXML(model, ns, root) {
            var res = this.serialize(model, ns, root),
                xmlSerializer = new XMLSerializer(),
                xml = xmlSerializer.serializeToString(res);

            // Workaround for IE.
            // IE adds attributes to documents root: xmlns:NS1="", NS1:xmlDPO.model...
            xml = xml.replace(/xmlns:NS\d+="" NS\d+:/g, '');
            xml = xml.replace(/xmlns=""/g, '');
            return xml;
        }
    });

    return Serializer;
});
DPO.def('wadl.Param', function () {
    /**
     * Creates Param object
     * @class DPO.wadl.Param
     * @memberof DPO.wadl
     * @constructor
     */
    function Param() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Param, DPO.xml.Model);
    DPO.mixin(Param.prototype, {
        attributesBinding: [
            {name: 'href'},
            {name: 'name'},
            {name: 'style'},
            {name: 'id'},
            {name: 'type'},
            {name: 'default'},
            {name: 'required'},
            {name: 'repeating'},
            {name: 'fixed'},
            {name: 'path'}
        ]
    });

    return Param;
});

DPO.def('wadl.Representation', function () {
    /**
     * Creates Representation object
     * @class DPO.wadl.Representation
     * @memberof DPO.wadl
     * @constructor
     */
    function Representation() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Representation, DPO.xml.Model);
    DPO.mixin(Representation.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'element'},
            {name: 'mediaType'},
            {name: 'href'},
            {name: 'profile'}
        ]
    });

    return Representation;
});

DPO.def('wadl.Request', function () {
    /**
     * Creates Response object
     * @class DPO.wadl.Request
     * @memberof DPO.wadl
     * @constructor
     */
    function Request() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Request, DPO.xml.Model);
    DPO.mixin(Request.prototype, {
        modelsBinding: [
            {el: 'param', name: 'params', cls: DPO.wadl.Param, collection: true}
        ]
    });

    return Request;
});

DPO.def('wadl.Response', function () {
    /**
     * Creates Response object
     * @class DPO.wadl.Response
     * @memberof DPO.wadl
     * @constructor
     */
    function Response() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Response, DPO.xml.Model);
    DPO.mixin(Response.prototype, {
        modelsBinding: [
            {el: 'representation', name: 'representation', cls: DPO.wadl.Representation}
        ]
    });

    return Response;
});

DPO.def('wadl.Method', function () {
    /**
     * Creates Method object
     * @class DPO.wadl.Method
     * @memberof DPO.wadl
     * @constructor
     */
    function Method() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Method, DPO.xml.Model);
    DPO.mixin(Method.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'name'}
        ],
        modelsBinding: [
            {el: 'request', name: 'requests', cls: DPO.wadl.Request}
        ]
    });

    return Method;
});

DPO.def('wadl.Resource', function () {
    /**
     * Creates Resources object
     * @class DPO.wadl.Resources
     * @memberof DPO.wadl
     * @constructor
     */
    function Resource() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Resource, DPO.xml.Model);
    DPO.mixin(Resource.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'type'},
            {name: 'queryType'},
            {name: 'path'}
        ],
        modelsBinding: [
            {el: 'resource', name: 'resources', cls: Resource, collection: true},
            {el: 'method', name: 'methods', cls: DPO.wadl.Method, collection: true},
            {el: 'param', name: 'params', cls: DPO.wadl.Param, collection: true}
        ]
    });

    return Resource;
});

DPO.def('wadl.Resources', function () {
    /**
     * Creates Resources object
     * @class DPO.wadl.Resources
     * @memberof DPO.wadl
     * @constructor
     */
    function Resources() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Resources, DPO.xml.Model);
    DPO.mixin(Resources.prototype, {
        attributesBinding: [
            {name: 'base'}
        ],
        itemsBinding: [
            {el: 'resource', cls: DPO.wadl.Resource}
        ]
    });

    return Resources;
});

DPO.def('wadl.Application', function () {
    /**
     * Creates Application object
     * @class DPO.wadl.Application
     * @memberof DPO.wadl
     * @constructor
     */
    function Application() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Application, DPO.xml.Model);
    DPO.mixin(Application.prototype, {
        modelsBinding: [
            {el: 'resources', name: 'resources', cls: DPO.wadl.Resources, collection: true}
        ]
    });

    return Application;
});

DPO.def('fc.BaseObject', function () {
    /**
     * Creates resource object
     * @class DPO.fc.BaseObject
     * @memberof DPO.fc
     * @property {string} mimeType
     * @property {string} extension
     * @property {string} operation
     * @constructor
     */
    function BaseObject() {
    }

    DPO.mixin(BaseObject.prototype, {
        attributesBinding: [
            {name: 'modifier'},
            {name: 'allowed'},
            {name: 'operation', defaultValue: 'noop'}
        ]
    });

    return BaseObject;
});

DPO.def('fc.Option', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Option
     * @memberof DPO.fc
     * @property {string} id
     * @property {string} l10n
     * @property {string} value
     * @constructor
     */
    function Option() {
    }

    DPO.inherit(Option, DPO.fc.BaseObject);
    DPO.mixin(Option.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'l10n'}
        ],
        valueBinding: {}
    });

    return Option;
});
DPO.def('fc.PrintChecklist', function () {
    /**
     * Creates resource object
     * @class DPO.fc.PrintChecklist
     * @memberof DPO.fc
     * @property {DPO.fc.Option[]} options
     * @property {string} title
     * @property {string} l10n
     * @property {string} singleCheck
     * @property {string} multiCheck
     * @constructor
     */
    function PrintChecklist() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(PrintChecklist, DPO.fc.BaseObject);
    DPO.mixin(PrintChecklist.prototype, {
        attributesBinding: [
            {name: 'title'},
            {name: 'l10n'},
            {name: 'single-check', propName: 'singleCheck'},
            {name: 'multi-check', propName: 'multiCheck'}
        ],
        modelsBinding: [
            {el: 'option', name: 'options', cls: DPO.fc.Option, collection: true}
        ]
    });

    return PrintChecklist;
});



DPO.def('fc.Item', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Item
     * @memberof DPO.fc
     * @property {string} id
     * @property {string} l10n
     * @property {string} value
     * @constructor
     */
    function Item() {
    }

    DPO.inherit(Item, DPO.fc.BaseObject);
    DPO.mixin(Item.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'l10n'}
        ],
        valueBinding: {}
    });

    return Item;
});
DPO.def('fc.List', function () {
    /**
     * Creates resource object
     * @class DPO.fc.List
     * @memberof DPO.fc
     * @property {DPO.fc.Item[]} items
     * @property {string} title
     * @property {string} l10n
     * @constructor
     */
    function List() {
        List.prototype.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(List, DPO.fc.BaseObject);
    DPO.mixin(List.prototype, {
        attributesBinding: [
            {name: 'title'},
            {name: 'l10n'}
        ],
        modelsBinding: [
            {el: 'item', name: 'items', cls: DPO.fc.Item, collection: true}
        ]
    });

    return List;
});



DPO.def('fc.UploadDesignRequirements', function () {
    /**
     * Creates resource object
     * @class DPO.fc.UploadDesignRequirements
     * @memberof DPO.fc
     * @constructor
     */
    function UploadDesignRequirements() {
        UploadDesignRequirements.prototype.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(UploadDesignRequirements, DPO.fc.List);

    return UploadDesignRequirements;
});



DPO.def('fc.Param', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Param
     * @memberof DPO.fc
     * @property {string} name
     * @property {string} value
     * @constructor
     */
    function Param() {
    }

    DPO.mixin(Param.prototype, {
        attributesBinding: [
            {name: 'name'}
        ],
        valueBinding: {}
    });

    return Param;
});
DPO.def('fc.Tracker', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Tracker
     * @memberof DPO.fc
     * @property {string} id
     * @property {DPO.fc.Param} params
     * @constructor
     */
    function Tracker() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Tracker, DPO.fc.BaseObject);
    DPO.mixin(Tracker.prototype, {
        attributesBinding: [
            {name: 'id'}
        ],
        modelsBinding: [
            {el: 'param', name: 'params', cls: DPO.fc.Param, collection: true}
        ],
        valueBinding: {},

        /**
         * Returns param value by it's name
         * @param {string} name
         * @memberof DPO.fc.Tracker#
         * @returns {?string}
         */
        getParamValue: function getParamValue(name) {
            for (var i = 0; i < this.params.length; i++) {
                var p = this.params[i];
                if (p.name === name) {
                    return p.value;
                }
            }

            return null;
        }
    });

    return Tracker;
});

DPO.def('fc.Analytics', function () {
    /**
     * Creates analytics object
     * @class DPO.fc.Analytics
     * @memberof DPO.fc
     * @property {DPO.fc.Tracker[]} trackers
     * @constructor
     */
    function Analytics() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Analytics, DPO.fc.BaseObject);
    DPO.mixin(Analytics.prototype, {
        modelsBinding: [
            {el: 'tracker', name: 'trackers', cls: DPO.fc.Tracker, collection: true}
        ]
    });

    return Analytics;
});

DPO.def('fc.Value', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Value
     * @memberof DPO.fc
     * @property {string} value
     * @constructor
     */
    function Value() {
    }

    DPO.mixin(Value.prototype, {
        valueBinding: {}
    });

    return Value;
});
DPO.def('fc.Action', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Action
     * @memberof DPO.fc
     * @property {string} name
     * @property {boolean} disabled
     * @constructor
     */
    function Action() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Action, DPO.fc.BaseObject);
    DPO.mixin(Action.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'disabled', type: 'bool', defaultValue: false}
        ]
    });

    return Action;
});

DPO.def('fc.Actions', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Actions
     * @memberof DPO.fc
     * @property {DPO.fc.Action[]} items
     * @constructor
     */
    function Actions() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Actions, DPO.fc.BaseObject);
    DPO.mixin(Actions.prototype, {
        itemsBinding: [
            {el: 'action', cls: DPO.fc.Action}
        ],

        /**
         * Checks if action is enabled
         * @memberof DPO.fc.Actions#
         * @param {string} actionId
         * @returns {boolean}
         */
        isActionEnabled: function isActionEnabled(actionId) {
            var disabled = false;
            for (var i = 0; i < this.items.length; i++) {
                var action = this.items[i];
                if (action.id === actionId) {
                    disabled = action.disabled;
                }
            }

            return !disabled;
        }
    });

    return Actions;
});

DPO.def('fc.Fragment', function () {
    /**
     * Creates fragment object
     * @class DPO.fc.Fragment
     * @memberof DPO.fc
     * @constructor
     */
    function Fragment() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Fragment, DPO.fc.BaseObject);
    DPO.mixin(Fragment.prototype, {
        attributesBinding: [
            {name: 'id'}
        ],
        valueBinding: {}
    });

    return Fragment;
});
DPO.def('fc.Fragments', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Fragments
     * @memberof DPO.fc
     * @property {DPO.fc.Fragment[]} items
     * @constructor
     */
    function Fragments() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Fragments, DPO.fc.BaseObject);
    DPO.mixin(Fragments.prototype, {
        itemsBinding: [
            {el: 'fragment', cls: DPO.fc.Fragment}
        ]
    });

    return Fragments;
});

DPO.def('fc.Request', function () {
    /**
     * Creates request object
     * @class DPO.fc.Request
     * @memberof DPO.fc
     * @constructor
     */
    function Request() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Request, DPO.fc.BaseObject);
    DPO.mixin(Request.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'resource'}
        ]
    });

    return Request;
});
DPO.def('fc.Resource', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Resource
     * @memberof DPO.fc
     * @property {string} id
     * @property {string} route
     * @property {string} value
     * @constructor
     */
    function Resource() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Resource, DPO.fc.BaseObject);
    DPO.mixin(Resource.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'route'}
        ],
        valueBinding: {}
    });

    return Resource;
});

DPO.def('fc.Resources', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Resources
     * @memberof DPO.fc
     * @property {DPO.fc.Resource[]} items
     * @constructor
     */
    function Resources() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Resources, DPO.fc.BaseObject);
    DPO.mixin(Resources.prototype, {
        itemsBinding: [
            {el: 'resource', cls: DPO.fc.Resource}
        ]
    });

    return Resources;
});

DPO.def('fc.Route', function () {
    /**
     * Creates routes object
     * @class DPO.fc.Route
     * @memberof DPO.fc
     * @property {string} id
     * @property {string} value
     * @constructor
     */
    function Route() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Route, DPO.fc.BaseObject);
    DPO.mixin(Route.prototype, {
        attributesBinding: [
            { name: 'id' }
        ],
        valueBinding: {}
    });

    return Route;
});

DPO.def('fc.Routes', function () {
    /**
     * Creates routes object
     * @class DPO.fc.Routes
     * @memberof DPO.fc
     * @property {DPO.fc.Route[]} items
     * @constructor
     */
    function Routes() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Routes, DPO.fc.BaseObject);
    DPO.mixin(Routes.prototype, {
        itemsBinding: [
            {el: 'route', cls: DPO.fc.Route}
        ]
    });

    return Routes;
});

DPO.def('fc.Authentication', function () {
    /**
     * Creates authentication object
     * @class DPO.fc.Authentication
     * @memberof DPO.fc
     * @property {string} type
     * @property {string} clientId
     * @property {DPO.fc.Request[]} requests
     * @property {DPO.fc.Param[]} params
     * @constructor
     */
    function Authentication() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Authentication, DPO.fc.BaseObject);
    DPO.mixin(Authentication.prototype, {
        attributesBinding: [
            {name: 'type'}
        ],

        modelsBinding: [
            {el: 'request', name: 'requests', cls: DPO.fc.Request, collection: true},
            {el: 'param', name: 'params', cls: DPO.fc.Param, collection: true}
        ],

        /**
         * Returns param value by it's name
         * @param {string} name
         * @memberof DPO.fc.Authentication#
         * @returns {?string}
         */
        getParamValue: function getParamValue(name) {
            for (var i = 0; i < this.params.length; i++) {
                var p = this.params[i];
                if (p.name === name) {
                    return p.value;
                }
            }

            return null;
        }
    });

    return Authentication;
});

DPO.def('fc.Redirection', function () {
    /**
     * Creates authentication object
     * @class DPO.fc.Redirection
     * @memberof DPO.fc
     * @property {DPO.fc.Request[]} items
     * @constructor
     */
    function Redirection() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Redirection, DPO.fc.BaseObject);
    DPO.mixin(Redirection.prototype, {
        itemsBinding: [
            {el: 'request', cls: DPO.fc.Request}
        ]
    });

    return Redirection;
});

DPO.def('fc.Format', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Format
     * @memberof DPO.fc
     * @property {string} mimeType
     * @property {string} extension
     * @constructor
     */
    function Format() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Format, DPO.fc.BaseObject);
    DPO.mixin(Format.prototype, {
        attributesBinding: [
            {name: 'mime-type', propName: 'mimeType'},
            {name: 'extension'}
        ]
    });

    return Format;
});

DPO.def('fc.Formats', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Resources
     * @memberof DPO.fc
     * @property {DPO.fc.Resource[]} items
     * @constructor
     */
    function Formats() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Formats, DPO.fc.BaseObject);
    DPO.mixin(Formats.prototype, {
        itemsBinding: [
            {el: 'format', cls: DPO.fc.Format}
        ],

        /**
         * Check if mime-type is supported
         * @memberof DPO.fc.Resources#
         * @param {string} type
         * @returns {boolean}
         */
        containsMimeType: function containsMimeType(type) {
            var items = this.items;
            for (var i = 0; i < items.length; i++) {
                if (items[i].mimeType === type) {
                    return true;
                }
            }

            return false;
        },

        /**
         * Return comma separated types
         * @memberof DPO.fc.Resources#
         * @returns {string}
         */
        getTypes: function getTypes() {
            var types = [],
                items = this.items;

            items.forEach(function(i) {
                if (types.indexOf(i.mimeType) === -1) {
                    types.push(i.mimeType);
                }
            });
            return types.join(',');
        }
    });

    return Formats;
});

DPO.def('fc.Presentation', function () {
    /**
     * Creates fragment object
     * @class DPO.fc.Presentation
     * @memberof DPO.fc
     * @property {string} resolution
     * @property {string} colorSpace
     * @constructor
     */
    function Presentation() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Presentation, DPO.fc.BaseObject);
    DPO.mixin(Presentation.prototype, {
        attributesBinding: [
            {name: 'resolution', defaultValue: 'high'},
            {name: 'color-space', propName: 'colorSpace', defaultValue: 'RGB'}
        ]
    });

    return Presentation;
});
DPO.def('fc.ImageProcessing', function () {
    /**
     * Creates image processing object
     * @class DPO.fc.ImageProcessing
     * @memberof DPO.fc
     * @property {string} maxSize
     * @property {string} maxResolution
     * @property {DPO.fc.Presentation} presentation
     * @property {DPO.fc.Formats} formats
     * @constructor
     */
    function ImageProcessing() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(ImageProcessing, DPO.fc.BaseObject);
    DPO.mixin(ImageProcessing.prototype, {
        attributesBinding: [
            {name: 'max-size', propName: 'maxSize', type: 'number', defaultValue: 104857600},
            {name: 'max-resolution', propName: 'maxResolution', type: 'number', defaultValue: 6000}
        ],

        modelsBinding: [
            {el: 'presentation', name: 'presentation', cls: DPO.fc.Presentation, required: true},
            {el: 'formats', name: 'formats', cls: DPO.fc.Formats, required: true}
        ]
    });

    return ImageProcessing;
});

DPO.def('fc.ImageFilters', function () {
    /**
     * Creates resource object
     * @class DPO.fc.ImageFilters
     * @memberof DPO.fc
     * @property {DPO.fc.Value[]} items
     * @constructor
     */
    function ImageFilters() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(ImageFilters, DPO.fc.BaseObject);
    DPO.mixin(ImageFilters.prototype, {
        itemsBinding: [
            {el: 'filter', cls: DPO.fc.Value}
        ]
    });

    return ImageFilters;
});

DPO.def('fc.ColorManagement', function () {
    /**
     * Creates resource object
     * @class DPO.fc.ColorManagement
     * @memberof DPO.fc
     * @constructor
     */
    function ColorManagement() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(ColorManagement, DPO.fc.BaseObject);
    DPO.mixin(ColorManagement.prototype, {
    });

    return ColorManagement;
});

DPO.def('fc.ColorSwatches', function () {
    /**
     * Creates resource object
     * @class DPO.fc.ColorSwatches
     * @memberof DPO.fc
     * @property {boolean} allowTransparent
     * @property {DPO.fc.Value[]} items
     * @constructor
     */
    function ColorSwatches() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(ColorSwatches, DPO.fc.BaseObject);
    DPO.mixin(ColorSwatches.prototype, {
        attributesBinding: [
            {name: 'allow-transparent', propName: 'allowTransparent', type: 'bool', defaultValue: true}
        ],
        itemsBinding: [
            {el: 'color', cls: DPO.fc.Value}
        ]
    });

    return ColorSwatches;
});

DPO.def('fc.Fonts', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Fonts
     * @memberof DPO.fc
     * @property {string} resource
     * @property {DPO.fc.Value[]} items
     * @constructor
     */
    function Fonts() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Fonts, DPO.fc.BaseObject);
    DPO.mixin(Fonts.prototype, {
        attributesBinding: [
            {name: 'resource'}
        ],
        itemsBinding: [
            {el: 'font', cls: DPO.fc.Value}
        ],

        /**
         * Returns all fonts
         * @memberof DPO.fc.Fonts#
         * @returns {string[]}
         */
        getAll: function getAll() {
            var array = [];
            for (var i = 0; i < this.items.length; i++) {
                var v = this.items[i];
                array.push(v.value);
            }

            return array;
        }
    });

    return Fonts;
});

DPO.def('fc.Locale', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Locale
     * @memberof DPO.fc
     * @property {string} measurementSystem
     * @property {string} currency
     * @property {string} shortDateTimeFormat
     * @property {string} longDateTimeFormat
     * @constructor
     */
    function Locale() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Locale, DPO.fc.BaseObject);
    DPO.mixin(Locale.prototype, {
        attributesBinding: [
            {name: 'name'}
        ],

        elementBinding: [
            {el: 'measurement-system', propName: 'measurementSystem'},
            {el: 'currency'},
            {el: 'short-date-time-format', propName: 'shortDateTimeFormat'},
            {el: 'long-date-time-format', propName: 'longDateTimeFormat'}
        ]
    });

    return Locale;
});

DPO.def('fc.Products', function () {
    /**
     * Creates resource object
     * @class DPO.fc.Products
     * @memberof DPO.fc
     * @property {DPO.fc.Value[]} items
     * @constructor
     */
    function Products() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Products, DPO.fc.BaseObject);
    DPO.mixin(Products.prototype, {
        itemsBinding: [
            {el: 'profile', cls: DPO.fc.Value}
        ],

        /**
         * Return product profiles
         * @memberof DPO.fc.Products
         * @returns {Array}
         */
        getProfiles: function getProfiles() {
            var profiles = [],
                items = this.items;
            for (var i = 0; i < items.length; i++) {
                profiles.push(items[i].value);
            }
            return profiles;
        }
    });

    return Products;
});

DPO.def('fc.SocialMedia', function () {
    /**
     * Creates resource object
     * @class DPO.fc.SocialMedia
     * @memberof DPO.fc
     * @property {DPO.fc.Value[]} items
     * @constructor
     */
    function SocialMedia() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(SocialMedia, DPO.fc.BaseObject);
    DPO.mixin(SocialMedia.prototype, {
        itemsBinding: [
            {el: 'provider', cls: DPO.fc.Value}
        ]
    });

    return SocialMedia;
});

DPO.def('fc.ProductGeometryCharacteristic', function () {
    /**
     * Creates resource object
     * @class DPO.fc.ProductGeometryCharacteristic
     * @memberof DPO.fc
     * @property {number} panelSafelineRenderLimit in twips
     * @constructor
     */
    function ProductGeometryCharacteristic() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(ProductGeometryCharacteristic, DPO.fc.BaseObject);
    DPO.mixin(ProductGeometryCharacteristic.prototype, {
        elementBinding: [
            {el: 'panel-safeline-render-limit', propName: 'panelSafelineRenderLimit', type: 'number', defaultValue: 450}
        ]
    });

    return ProductGeometryCharacteristic;
});

DPO.def('fc.UI', function () {
    /**
     * Creates user interface object
     * @class DPO.fc.UI
     * @memberof DPO.fc
     * @property {string} theme
     * @constructor
     */
    function UI() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(UI, DPO.fc.BaseObject);
    DPO.mixin(UI.prototype, {
        elementBinding: [
            {el: 'theme', propName: 'theme'}
        ]
    });

    return UI;
});

DPO.def('fc.Wizard', function () {
    /**
     * Creates wizard object
     * @class DPO.fc.Wizard
     * @memberof DPO.fc
     * @property {string} id
     * @property {DPO.fc.Param} params
     * @constructor
     */
    function Wizard() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Wizard, DPO.fc.BaseObject);
    DPO.mixin(Wizard.prototype, {
        attributesBinding: [
            {name: 'id'}
        ],
        modelsBinding: [
            {el: 'param', name: 'params', cls: DPO.fc.Param, collection: true}
        ],
        valueBinding: {},

        /**
         * Returns param value by it's name
         * @param {string} name
         * @memberof DPO.fc.Wizard#
         * @returns {?string}
         */
        getParamValue: function getParamValue(name) {
            for (var i = 0; i < this.params.length; i++) {
                var p = this.params[i];
                if (p.name === name) {
                    return p.value;
                }
            }

            return null;
        }
    });

    return Wizard;
});

DPO.def('fc.Autorun', function () {
    /**
     * Creates autorun object
     * @class DPO.fc.Autorun
     * @memberof DPO.fc
     * @property {DPO.fc.Wizard[]} wizards
     * @constructor
     */
    function Autorun() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(Autorun, DPO.fc.BaseObject);
    DPO.mixin(Autorun.prototype, {
        modelsBinding: [
            {el: 'wizard', name: 'wizards', cls: DPO.fc.Wizard, collection: true}
        ]
    });

    return Autorun;
});

DPO.def('fc.SKU', function () {
    /**
     * Creates SKU object
     * @class DPO.fc.SKU
     * @memberof DPO.fc
     * @property {string} value
     * @constructor
     */
    function SKU() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(SKU, DPO.fc.BaseObject);
    DPO.mixin(SKU.prototype, {
        valueBinding: {}
    });

    return SKU;
});

DPO.def('fc.CheckDesign', function () {
    /**
     * Creates Check Design object
     * @class DPO.fc.CheckDesign
     * @memberof DPO.fc
     * @property {DPO.fc.SKU[]} skus
     * @constructor
     */
    function CheckDesign() {
        this.$super.constructor.apply(this, arguments);
    }

    DPO.inherit(CheckDesign, DPO.fc.BaseObject);
    DPO.mixin(CheckDesign.prototype, {
        modelsBinding: [
            {el: 'sku', name: 'skus', cls: DPO.fc.SKU, collection: true}
        ],

        /**
         * Check if SKU exist in collection
         * @memberof DPO.fc.CheckDesign#
         * @param {string} sku
         * @returns {boolean}
         */
        containsSKU: function containsSKU(sku) {
            var contains = false;
            for (var i = 0; !contains && i < this.skus.length; i++) {
                contains = this.skus[i].value === sku;
            }
            return contains;
        }
    });

    return CheckDesign;
});

DPO.def('fc.Configuration', function () {
    /**
     * Creates flow configuration object
     * @class DPO.fc.Configuration
     * @memberof DPO.fc
     * @property {string} version
     * @property {DPO.fc.Routes} routes
     * @property {DPO.fc.Resources} systemResources
     * @property {DPO.fc.Resources} resources
     * @property {DPO.fc.Fragments} fragments
     * @property {DPO.fc.Authentication} authentication
     * @property {DPO.fc.Redirection} redirection
     * @property {DPO.fc.ImageProcessing} imageProcessing
     * @property {DPO.fc.ImageFilters} imageFilters
     * @property {DPO.fc.ColorManagement} colorManagement
     * @property {DPO.fc.ColorSwatches} colorSwatches
     * @property {DPO.fc.Fonts} fonts
     * @property {DPO.fc.Locale} locale
     * @property {DPO.fc.Products} products
     * @property {DPO.fc.SocialMedia} socialMedia
     * @property {DPO.fc.Analytics} analytics
     * @property {DPO.fc.PrintChecklist} printChecklist
     * @property {DPO.fc.UploadDesignRequirements} uploadDesignRequirements
     * @property {DPO.fc.ProductGeometryCharacteristic} productGeometryCharacteristic
     * @property {DPO.fc.UI} ui
     * @property {DPO.fc.Autorun} autorun
     * @property {DPO.fc.CheckDesign} checkDesign
     * @constructor
     */
    function Configuration() {
    }

    DPO.mixin(Configuration.prototype, {
        attributesBinding: [
            {name: 'version'},
            {name: 'xmlns', defaultValue: 'http://print.avery.com/2015/dpo8-fc'}
        ],

        modelsBinding: [
            {el: 'routes', name: 'routes', cls: DPO.fc.Routes, required: true},
            {el: 'system-resources', name: 'systemResources', cls: DPO.fc.Resources, required: true},
            {el: 'resources', name: 'resources', cls: DPO.fc.Resources, required: true},
            {el: 'html-fragments', name: 'fragments', cls: DPO.fc.Fragments, required: true},
            {el: 'authentication', name: 'authentication', cls: DPO.fc.Authentication, required: true},
            {el: 'redirection', name: 'redirection', cls: DPO.fc.Redirection, required: true},
            {el: 'image-processing', name: 'imageProcessing', cls: DPO.fc.ImageProcessing, required: true},
            {el: 'image-filters', name: 'imageFilters', cls: DPO.fc.ImageFilters, required: true},
            {el: 'color-management', name: 'colorManagement', cls: DPO.fc.ColorManagement},
            {el: 'color-swatches', name: 'colorSwatches', cls: DPO.fc.ColorSwatches, required: true},
            {el: 'fonts', name: 'fonts', cls: DPO.fc.Fonts, required: true},
            {el: 'locale', name: 'locale', cls: DPO.fc.Locale},
            {el: 'products', name: 'products', cls: DPO.fc.Products, required: true},
            {el: 'social-media', name: 'socialMedia', cls: DPO.fc.SocialMedia, required: true},
            {el: 'actions', name: 'actions', cls: DPO.fc.Actions, required: true},
            {el: 'analytics', name: 'analytics', cls: DPO.fc.Analytics, required: true},
            {el: 'print-checklist', name: 'printChecklist', cls: DPO.fc.PrintChecklist, required: true},
            {el: 'product-geometry-characteristic', name: 'productGeometryCharacteristic', cls: DPO.fc.ProductGeometryCharacteristic, required: true},
            {el: 'upload-design-requirements', name: 'uploadDesignRequirements', cls: DPO.fc.UploadDesignRequirements, required: true},
            {el: 'ui', name: 'ui', cls: DPO.fc.UI, required: true},
            {el: 'autorun', name: 'autorun', cls: DPO.fc.Autorun, required: true},
            {el: 'check-design', name: 'checkDesign', cls: DPO.fc.CheckDesign, required: true}
        ],

        cacheCollectionItems: function cacheCollectionItems(obj, key) {
            var items = obj[key];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                this.cache[item.id] = item;
            }
        },

        prepareCache: function prepareCache() {
            var me = this;
            if (me.cache) {
                return;
            }

            me.cache = {};
            me.cacheCollectionItems(me.routes, 'items');
            me.cacheCollectionItems(me.systemResources, 'items');
            me.cacheCollectionItems(me.resources, 'items');
            me.cacheCollectionItems(me.fragments, 'items');
            me.cacheCollectionItems(me.authentication, 'requests');
            me.cacheCollectionItems(me.redirection, 'items');
        },

        /**
         * Returns resource URL
         * @memberof DPO.fc.Configuration#
         * @param {string} resourceId
         * @returns {?string}
         */
        getResourceURL: function getResourceURL(resourceId) {
            var me = this;
            me.prepareCache();

            var resource = me.cache[resourceId];
            if (!resource) {
                return null;
            }

            var route = me.cache[resource.route || ''],
                resourceValue = resource.value.replace(/^\//, ''),
                routeValue = route ? route.value : '';
            routeValue = routeValue.replace(/\/$/, '');
            return routeValue ? routeValue + '/' + resourceValue : resourceValue;
        },

        /**
         * Returns analytic tracker by specified identifier
         * @memberof DPO.fc.Configuration#
         * @param {string} id
         */
        getTracker: function getTracker(id) {
            var trackers = this.analytics.trackers;
            for (var i = 0; i < trackers.length; i++) {
                var tracker = trackers[i];
                if (tracker.id === id) {
                    return tracker;
                }
            }

            return null;
        }
    });

    return Configuration;
});

DPO.def('model.Color', function () {
    /**
     * @class DPO.model.Color
     * @memberof DPO.model
     * @property {string} css
     * @property {string} model
     * @property {?string} spot
     * @property {boolean} transparent
     * @property {number} r
     * @property {number} g
     * @property {number} b
     * @property {number} a
     * @property {number} h
     * @property {number} s
     * @property {number} v
     * @constructor
     */
    function Color() {
        var me = this;
        me.r = 0;
        me.g = 0;
        me.b = 0;
        me.a = 1;
        me.h = 0;
        me.s = 0;
        me.v = 0;
        me.spot = null;
        DPO.mixin(me, me.rgb2hsv(me.r, me.g, me.b));
    }

    DPO.mixin(Color.prototype, {
        rgb2hsv: function rgb2hsv(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h, s, v = max;

            var d = max - min;
            s = max === 0 ? 0 : d / max;

            if (max === min) {
                h = 0; // achromatic
            } else {
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }

            h = Math.floor(h * 360); // degrees

            return {
                h: h,
                s: s,
                v: v
            };
        },

        hsv2rgb: function hsv2rgb(h, s, v) {
            var hh, p, q, t, ff, i, out = {};

            if (s <= 0.0) {
                out.r = v;
                out.g = v;
                out.b = v;
                return out;
            }

            hh = h;
            if (hh >= 360.0) {
                hh = 0.0;
            }

            hh /= 60.0;
            i = Math.floor(hh);
            ff = hh - i;
            p = v * (1.0 - s);
            q = v * (1.0 - (s * ff));
            t = v * (1.0 - (s * (1.0 - ff)));

            switch (i) {
                case 0:
                    out.r = v;
                    out.g = t;
                    out.b = p;
                    break;
                case 1:
                    out.r = q;
                    out.g = v;
                    out.b = p;
                    break;
                case 2:
                    out.r = p;
                    out.g = v;
                    out.b = t;
                    break;
                case 3:
                    out.r = p;
                    out.g = q;
                    out.b = v;
                    break;
                case 4:
                    out.r = t;
                    out.g = p;
                    out.b = v;
                    break;
                default:
                    out.r = v;
                    out.g = p;
                    out.b = q;
                    break;
            }
            return out;
        },

        /**
         * Assigns or returns HSV values
         * @memberof DPO.model.Color#
         * @param {number|{h: number, s: number, v: number}} [h]
         * @param {number} [s]
         * @param {number} [v]
         * @returns {{h: number, s: number, v: number}}
         */
        hsv: function hsv(h, s, v) {
            var me = this;
            if (h !== undefined && s === undefined) {
                s = h.s;
                v = h.v;
                h = h.h;
            }

            if (h !== undefined) {
                me.h = h;
                me.s = s;
                me.v = v;
                me.spot = null;
                DPO.mixin(me, me.hsv2rgb(h, s, v));
            }

            return {
                h: me.h,
                s: me.s,
                v: me.v
            };
        },

        /**
         * Assigns or returns RGB values
         * @memberof DPO.model.Color#
         * @param {number|{r: number, g: number, b: number}} [r]
         * @param {number} [g]
         * @param {number} [b]
         * @returns {{r: number, g: number, b: number}}
         */
        rgb: function rgb(r, g, b) {
            var me = this;
            if (r !== undefined && g === undefined) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (r !== undefined) {
                me.r = r;
                me.g = g;
                me.b = b;
                me.spot = null;
                DPO.mixin(me, me.rgb2hsv(r, g, b));
            }

            return {
                r: me.r,
                g: me.g,
                b: me.b
            };
        },

        /**
         * Parses or returns hex string
         * @memberof DPO.model.Color#
         * @param {string} [h]
         * @returns {string}
         */
        hex: function hex(h) {
            var me = this,
                color = '',
                result;
            h = h || '';
            result = /([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
            if (result) {
                me.r = parseInt(result[1], 16) / 255;
                me.g = parseInt(result[2], 16) / 255;
                me.b = parseInt(result[3], 16) / 255;
                me.a = 1;
                me.spot = null;
                DPO.mixin(me, me.rgb2hsv(me.r, me.g, me.b));
            }

            color += ('0' + Math.round(me.r * 255).toString(16)).substr(-2);
            color += ('0' + Math.round(me.g * 255).toString(16)).substr(-2);
            color += ('0' + Math.round(me.b * 255).toString(16)).substr(-2);
            return color;
        },

        /**
         * Returns clone of current color
         * @memberof DPO.model.Color#
         * @returns {DPO.model.Color}
         */
        clone: function clone() {
            var me = this,
                c = new Color();
            c.rgb(me.r, me.g, me.b);
            c.a = me.a;
            c.spot = me.spot;
            return c;
        }
    });

    /**
     * Creates new color object from specified hex value
     * @memberof DPO.model.Color
     * @param {string} hex
     * @param {number} [alpha]
     * @returns {DPO.model.Color}
     */
    Color.fromHex = function fromHex(hex, alpha) {
        var c = new Color();
        c.hex(hex);
        if (alpha !== undefined) {
            c.a = alpha;
        }
        return c;
    };

    /**
     * Check if too colors are equal
     * @memberof DPO.model.Color
     * @param {DPO.model.Color} a
     * @param {DPO.model.Color} b
     * @returns {boolean}
     */
    Color.isEqual = function isEqual(a, b) {
        if (a === b) {
            return true;
        }

        if (!a || !b) {
            return false;
        }

        var equal = a.r === b.r;
        equal = equal && a.r === b.r;
        equal = equal && a.b === b.b;
        equal = equal && a.g === b.g;
        equal = equal && a.a === b.a;
        equal = equal && a.spot === b.spot;
        return equal;
    };

    Object.defineProperty(Color.prototype, 'css', {
        get: function get() {
            return '#' + this.hex();
        }
    });

    Object.defineProperty(Color.prototype, 'model', {
        get: function get() {
            return '0x' + this.hex();
        }
    });

    Object.defineProperty(Color.prototype, 'transparent', {
        get: function get() {
            return this.a === 0;
        }
    });

    return Color;
});

DPO.def('model.Bezier', function() {
    /**
     * @class DPO.model.Bezier
     * @memberof DPO.model
     * @property {number} x the same as x1
     * @property {number} y the same as y1
     * @property {number} x1
     * @property {number} y1
     * @property {number} x2
     * @property {number} y2
     * @property {number} x3
     * @property {number} y3
     * @property {?number} x4
     * @property {?number} y4
     * @param {number} [x1]
     * @param {number} [y1]
     * @param {number} [x2]
     * @param {number} [y2]
     * @param {number} [x3]
     * @param {number} [y3]
     * @param {number} [x4]
     * @param {number} [y4]
     * @constructor
     */
    function Bezier(x1, y1, x2, y2, x3, y3, x4, y4) {
        var me = this;
        DPO.xml.Model.apply(me, arguments);
        me.x1 = x1 || 0;
        me.y1 = y1 || 0;
        me.x2 = x2 || 0;
        me.y2 = y2 || 0;
        me.x3 = x3;
        me.y3 = y3;
        me.x4 = x4;
        me.y4 = y4;
    }

    DPO.inherit(Bezier, DPO.xml.Model);
    DPO.mixin(Bezier.prototype, {
        attributesBinding: [
            { name: 'x1', type: 'number' },
            { name: 'y1', type: 'number' },
            { name: 'x2', type: 'number' },
            { name: 'y2', type: 'number' },
            { name: 'x3', type: 'number' },
            { name: 'y3', type: 'number' },
            { name: 'x4', type: 'number' },
            { name: 'y4', type: 'number' }
        ],

        /**
         * Creates SVG path
         * @memberof DPO.model.Bezier#
         * @param prefix
         * @param divider
         * @returns {string}
         */
        format: function format(prefix, divider) {
            var me = this,
                cubic = me.x4 != null,
                res = prefix;
            res = res + (me.x1 / divider) + ',' + (me.y1 / divider) + (cubic ? ' C' : ' Q');
            res = res + (me.x2 / divider) + ',' + (me.y2 / divider);
            res = res + ' ' + (me.x3 / divider) + ',' + (me.y3 / divider);
            if (cubic) {
                res = res + ' ' + (me.x4 / divider) + ',' + (me.y4 / divider);
            }
            return res;
        },

        /**
         * Offsets bezier curve by x & y
         * @memberof DPO.model.Bezier#
         * @param {number} x
         * @param {number} y
         * @returns {DPO.model.Bezier}
         */
        offset: function offset(x, y) {
            var me = this;
            me.x1 += x;
            me.y1 += y;
            me.x2 += x;
            me.y2 += y;
            me.x3 += x;
            me.y3 += y;
            if (me.x4 != null) {
                me.x4 += x;
                me.y4 += y;
            }

            return me;
        },

        /**
         * Scales bezier curve
         * @memberof DPO.model.Bezier#
         * @param {number} s
         * @returns {DPO.model.Bezier}
         */
        scale: function scale(s) {
            var me = this;
            me.x1 *= s;
            me.y1 *= s;
            me.x2 *= s;
            me.y2 *= s;
            me.x3 *= s;
            me.y3 *= s;
            if (me.x4 != null) {
                me.x4 *= s;
                me.y4 *= s;
            }

            return me;
        },

        /**
         * Returns bezier curve bounds
         * @returns {{left: number, right: number, top: number, bottom: number}}
         */
        bounds: function bounds() {
            // Convert quadratic path to cubic
            // See http://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic
            var me = this;
            if (me.x4 === undefined) {
               var cubic = {
                   x1: me.x1,
                   y1: me.y1,
                   x2: me.x1 + 2 / 3 * (me.x2 - me.x1),
                   y2: me.y1 + 2 / 3 * (me.y2 - me.y1),
                   x3: me.x3 + 2 / 3 * (me.x2 - me.x3),
                   y3: me.y3 + 2 / 3 * (me.y2 - me.y3),
                   x4: me.x3,
                   y4: me.y3
               };

                me.x1 = cubic.x1;
                me.y1 = cubic.y1;
                me.x2 = cubic.x2;
                me.y2 = cubic.y2;
                me.x3 = cubic.x3;
                me.y3 = cubic.y3;
                me.x4 = cubic.x4;
                me.y4 = cubic.y4;
            }

            var bound = Snap.path.bezierBBox([
                me.x1, me.y1,
                me.x2, me.y2,
                me.x3, me.y3,
                me.x4, me.y4
            ]);

            return {
                left: bound.x,
                right: bound.x2,
                top: bound.y,
                bottom: bound.y2
            };
        },

        /**
         * Returns end point of bezier path
         * @memberof DPO.model.Bezier#
         * @returns {{x: (number), y: (number)}}
         */
        getEndPoint: function getEndPoint() {
            return {
                x: this.x4 == null ? this.x3 : this.x4,
                y: this.x4 == null ? this.y3 : this.y4
            };
        }
    });

    Object.defineProperty(Bezier.prototype, 'x', {
        get: function get() {
            return this.x1;
        },
        set: function set(value) {
            this.x1 = value;
        }
    });

    Object.defineProperty(Bezier.prototype, 'y', {
        get: function get() {
            return this.y1;
        },
        set: function set(value) {
            this.y1 = value;
        }
    });

    return Bezier;
});

DPO.def('model.Point', function() {
    /**
     * @class DPO.model.Point
     * @memberof DPO.model
     * @param x [x=0]
     * @param y [y=0]
     * @property {number} x
     * @property {number} y
     * @constructor
     */
    function Point(x, y) {
        DPO.xml.Model.apply(this, arguments);
        this.x = x || 0;
        this.y = y || 0;
    }

    /**
     * Converts string to point
     * @memberof DPO.model.Point
     * @param {string} string
     * @static
     * @returns {DPO.model.Point}
     */
    Point.fromString = function fromString(string) {
        var res = string.split(',');
        return new Point(res[0] - 0.0, res[1] - 0.0);
    };

    /**
     * Converts point to string
     * @memberof DPO.model.Point
     * @param {DPO.model.Point} point
     * @static
     * @returns {string}
     */
    Point.toString = function toString(point) {
        return point.x + ',' + point.y;
    };

    DPO.inherit(Point, DPO.xml.Model);
    DPO.mixin(Point.prototype, {
        attributesBinding: [
            { name: 'x',    type: 'number' },
            { name: 'y',    type: 'number' },
            { name: 'move', type: 'bool', defaultValue: false }
        ],

        offset: function offset(x, y) {
            var me = this;
            me.x += x;
            me.y += y;
        },

        scale: function scale(s) {
            this.x *= s;
            this.y *= s;
        },

        bounds: function bounds(){
            return {
                left: this.x,
                right: this.x,
                top: this.y,
                bottom: this.y
            };
        },

        format: function format(prefix, divider) {
            return prefix + (this.x / divider) + ',' + (this.y / divider);
        }
    });

    return Point;
});
DPO.def('model.Position', function() {
    /**
     * @class DPO.model.Position
     * @memberof DPO.model
     * @constructor
     */
    function Position() {
        DPO.model.Point.apply(this, arguments);
    }

    DPO.inherit(Position, DPO.model.Point);
    DPO.mixin(Position.prototype, {
    });

    return Position;
});
DPO.def('model.Polypoints', function () {
    /**
     * @class DPO.model.Polypoints
     * @memberof DPO.model
     * @property {object[]} items
     * @constructor
     */
    function Polypoints() {
        DPO.xml.Model.apply(this, arguments);
    }

    /**
     * Creates new polypoints object from specified SVG path
     * @param {string} svgPath
     * @returns {DPO.model.Polypoints}
     */
    Polypoints.parsePath = function parsePath(svgPath) {
        function stringToIntConverter(a) {
            return a - 0;
        }
        
        function getReflectionPoint (bezierPath) {
            return (bezierPath.x4 == null) ? {
                //for quadratic bezier
                x:bezierPath.x3 * 2 - bezierPath.x2, 
                y:bezierPath.y3 * 2 - bezierPath.y2
            } : {
                //for cubic bezier
                x:bezierPath.x4 * 2 - bezierPath.x3, 
                y:bezierPath.y4 * 2 - bezierPath.y3
            };
        }

        var p = new Polypoints();
        p.items = [];

        if (!svgPath) {
            return p;
        }

        var segments = svgPath.match(/[a-z]+[^a-z]*/ig);

        for (var i = 0; i < segments.length; i++) {
            var pathItem,
                point,
                currentItem,
                reflectionPoint,
                attr,
                command = segments[i].slice(0, 1),
                value = segments[i].split(command)[1].trim();

            //add extra comma to value. E.g. '6-28' => '6,-28'
            value = value.replace(/(?!^)-/gi, ' -');
            value = value.replace(/,/gi, ' ');
            value = value.replace(/\s+/gi, ' ');
            attr = value.split(' ');
            attr = attr.map(stringToIntConverter);
            currentItem = p.items[p.items.length - 1] || new DPO.model.Point();
            point = currentItem instanceof DPO.model.Bezier === true ? currentItem.getEndPoint() : currentItem;
            
            reflectionPoint = getReflectionPoint(currentItem);

            switch (command) {
                case 'M':
                    pathItem = new DPO.model.Point(attr[0], attr[1]);
                    pathItem.move = true;
                    break;
                case 'm':
                    pathItem = new DPO.model.Point(point.x + attr[0], point.y + attr[1]);
                    pathItem.move = true;
                    break;
                case 'l':
                    pathItem = new DPO.model.Point((point.x + attr[0]), (point.y + attr[1]));
                    break;
                case 'L':
                    pathItem = new DPO.model.Point(attr[0], attr[1]);
                    break;
                case 'h':
                    pathItem = new DPO.model.Point((point.x + attr[0]), point.y);
                    break;
                case 'H':
                    pathItem = new DPO.model.Point(attr[0], point.y);
                    break;
                case 'v':
                    pathItem = new DPO.model.Point(point.x, point.y + attr[0]);
                    break;
                case 'V':
                    pathItem = new DPO.model.Point(point.x, attr[0]);
                    break;
                case 'c':
                    pathItem = new DPO.model.Bezier(
                        point.x, point.y,
                        point.x + attr[0], point.y + attr[1],
                        point.x + attr[2], point.y + attr[3],
                        point.x + attr[4], point.y + attr[5]
                    );
                    break;
                case 'C':
                    pathItem = new DPO.model.Bezier(point.x, point.y, attr[0], attr[1], attr[2], attr[3], attr[4], attr[5]);
                    break;
                case 's':
                    pathItem = new DPO.model.Bezier(
                        point.x, point.y,
                        reflectionPoint.x, reflectionPoint.y,
                        point.x  + attr[0], point.y + attr[1],
                        point.x + attr[2], point.y + attr[3]
                    );
                    break;
                case 'S':
                    pathItem = new DPO.model.Bezier(point.x, point.y, reflectionPoint.x, reflectionPoint.y, attr[0], attr[1], attr[2], attr[3]);
                    break;
                case 'q':
                    pathItem = new DPO.model.Bezier(point.x, point.y, point.x + attr[0], point.y + attr[1], point.x + attr[2], point.y + attr[3]);
                    break;
                case 'Q':
                    pathItem = new DPO.model.Bezier(point.x, point.y, attr[0], attr[1], attr[2], attr[3]);
                    break;
                case 't':
                    pathItem = new DPO.model.Bezier(
                        currentItem.x3, currentItem.y3,
                        reflectionPoint.x, reflectionPoint.y,
                        currentItem.x3 + attr[0],
                        currentItem.y3 + attr[1]
                    );
                    break;
                case 'T':
                    pathItem = new DPO.model.Bezier(currentItem.x3, currentItem.y3, reflectionPoint.x, reflectionPoint.y, attr[0], attr[1]);
                    break;
                default:
                    p.items.pop();
                    break;
            }

            p.items.push(pathItem);
        }

        return p;
    };

    DPO.inherit(Polypoints, DPO.xml.Model);
    DPO.mixin(Polypoints.prototype, {
        itemsBinding: [
            {el: 'avery:point', cls: DPO.model.Point},
            {el: 'avery:bezier', cls: DPO.model.Bezier}
        ],

        /**
         * Returns Polypoints bounds
         * @memberof DPO.model.Polypoints#
         * @returns {{left: Number, right: Number, top: Number, bottom: Number}}
         */
        bounds: function bounds() {
            var result = {
                left: Number.POSITIVE_INFINITY,
                right: Number.NEGATIVE_INFINITY,
                top: Number.POSITIVE_INFINITY,
                bottom: Number.NEGATIVE_INFINITY
            }, i, b;
            for (i = 0; i < this.items.length; i++) {
                b = this.items[i].bounds();
                result.left = Math.min(result.left, b.left);
                result.right = Math.max(result.right, b.right);
                result.top = Math.min(result.top, b.top);
                result.bottom = Math.max(result.bottom, b.bottom);
            }

            return result;
        },

        /**
         * Scales polypoints
         * @memberof DPO.model.Polypoints#
         * @param {number} s
         */
        scale: function scale(s) {
            var minX = Number.POSITIVE_INFINITY,
                minY = Number.POSITIVE_INFINITY,
                b, i, obj;
            for (i = 0; i < this.items.length; i++) {
                obj = this.items[i];
                obj.scale(s);

                b = obj.bounds();
                minX = Math.min(minX, b.left);
                minY = Math.min(minY, b.top);
            }

            for (i = 0; i < this.items.length; i++) {
                obj = this.items[i];
                obj.offset(-minX, -minY);
            }
        },

        /**
         * Creates SVG path
         * @memberof DPO.model.Polypoints#
         * @param {boolean} [closed]
         * @returns {string}
         */
        makePath: function makePath(closed) {
            var path = '';
            for (var i = 0; i < this.items.length; i++) {
                var obj = this.items[i];
                if (path && obj.move) {
                    path += 'Z ';
                }
                path = path + obj.format((i === 0 || obj.move) ? 'M' : 'L', 20, '') + ' ';
            }
            return closed ? path + 'Z' : path.substring(0, path.length - 1);
        },

        /**
         * Polygonize current polypoints path
         * @memberof DPO.model.Polypoints#
         * @param {number} [steps=16]
         * @returns {DPO.math.Polygon}
         */
        polygonize: function polygonize(steps) {
            var me = this,
                points = [],
                item, i, j, p, curve;
            steps = steps || 16;
            for (i = 0; i < me.items.length; i++) {
                item = me.items[i];
                if (item instanceof DPO.model.Point) {
                    points.push(item.x, item.y);
                    continue;
                }

                if (item.x4 !== undefined) {
                    curve = new DPO.math.CubicBezier(
                        item.x1, item.y1,
                        item.x2, item.y2,
                        item.x3, item.y3,
                        item.x4, item.y4);
                } else {
                    curve = DPO.math.CubicBezier.fromQuadratic(
                        item.x1, item.y1,
                        item.x2, item.y2,
                        item.x3, item.y3);
                }

                for (j = 0; j <= 1.0; j += 1 / steps) {
                    p = curve.compute(j);
                    points.push(p.x, p.y);
                }
            }

            return new DPO.math.Polygon(points);
        }
    });

    return Polypoints;
});

DPO.def('model.Outline', function() {
    /**
     * @class DPO.model.Outline
     * @memberof DPO.model
     * @property {number} width
     * @property {number} opacity
     * @property {string} color
     * @constructor
     */
    function Outline() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Outline, DPO.xml.Model);
    DPO.mixin(Outline.prototype, {
        attributesBinding: [
            { name: 'width',    type: 'number', defaultValue: 0             },
            { name: 'opacity',  type: 'number', defaultValue: 1.0           },
            { name: 'color',                    defaultValue: '0x000000'    },
            { name: 'spotColor',                defaultValue: '' }
        ]
    });

    return Outline;
});

DPO.def('model.Description', function() {
    /**
     * @class DPO.model.Description
     * @memberof DPO.model
     * @constructor
     */
    function Description() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Description, DPO.xml.Model);
    DPO.mixin(Description.prototype, {
        attributesBinding: [
            { name: 'index', type: 'number'}
        ],
        valueBinding: {}
    });

    return Description;
});

DPO.def('model.Field', function () {
    /**
     * @class DPO.model.Field
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {string} id
     * @property {DPO.model.Description} description
     * @property {DPO.model.Position} position
     * @property {number} width
     * @property {number} height
     * @property {number} rotation
     * @property {number} promptOrder
     * @property {number} zOrder
     * @property {boolean} visible
     * @property {?string} contentId
     * @property {?string} geometryId
     * @property {?number} mask
     * @property {boolean} editable
     * @property {boolean} styleable
     * @property {boolean} movable
     * @property {boolean} previewable
     * @property {boolean} print
     * @property {number} opacity
     * @constructor
     */
    function Field() {
        DPO.xml.Model.apply(this, arguments);
        this.geometryId = null;
        this.mask = null;
    }

    DPO.inherit(Field, DPO.xml.Model);
    DPO.mixin(Field.prototype, {
        attributesBinding: [
            {name: 'id'},
            {name: 'width', type: 'number'},
            {name: 'height', type: 'number'},
            {name: 'rotation', type: 'number', defaultValue: 0.0},
            {name: 'promptOrder', type: 'number'},
            {name: 'zOrder', type: 'number'},
            {name: 'visible', type: 'bool', defaultValue: true},
            {name: 'contentId', type: 'string'},
            {name: 'editable', type: 'bool', defaultValue: true},
            {name: 'movable', type: 'bool', defaultValue: true},
            {name: 'previewable', type: 'bool', defaultValue: true},
            {name: 'print', type: 'bool', defaultValue: true},
            {name: 'geometryId', type: 'string'},
            {name: 'mask', type: 'string'},
            {name: 'styleable', type: 'bool', defaultValue: true},
            {name: 'opacity', type: 'number', defaultValue: 1.0}
        ],

        modelsBinding: [
            {el: 'avery:description', name: 'description', cls: DPO.model.Description},
            {el: 'avery:position', name: 'position', cls: DPO.model.Position, required: true}
        ],

        /**
         * Returns data binding flags
         * 0 - none
         * 1 - sequential numbers
         * 2 - mail merge
         * @memberof DPO.model.Field#
         * @returns {number}
         */
        dataBindingFlags: function dataBinding() {
            return 0;
        }
    });

    return Field;
});

DPO.def('model.Background', function () {
    /**
     * @class DPO.model.Background
     * @extends DPO.model.Field
     * @memberof DPO.model
     * @property {string} source
     * @property {string} gallery
     * @property {string} color
     * @property {boolean} mirror
     * @constructor
     */
    function Background() {
        DPO.model.Field.apply(this, arguments);
    }

    DPO.inherit(Background, DPO.model.Field);
    DPO.mixin(Background.prototype, {
        attributesBinding: [
            {name: 'source'},
            {name: 'gallery', defaultValue: ''},
            {name: 'color'},
            {name: 'spotColor',            defaultValue: '' },
            {name: 'mirror', type: 'bool', defaultValue: false}
        ]
    });

    return Background;
});

DPO.def('model.BarcodeProperty', function() {
    /**
     * @class DPO.model.BarcodeProperty
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {string} name
     * @property {string} value
     * @property {string} mailMergeField
     * @property {string} serialNumberField
     * @param {string} [name]
     * @param {string} [value]
     * @constructor
     */
    function BarcodeProperty(name, value) {
        DPO.xml.Model.apply(this, arguments);
        this.name = name;
        this.value = value;
    }

    DPO.inherit(BarcodeProperty, DPO.xml.Model);
    DPO.mixin(BarcodeProperty.prototype, {
        attributesBinding: [
            { name: 'name' },
            { name: 'mailMergeField' },
            { name: 'serialNumberField'}
        ],

        valueBinding: {}
    });

    return BarcodeProperty;
});
DPO.def('model.Barcode', function () {
    /**
     * @class DPO.model.Barcode
     * @extends DPO.model.Field
     * @memberof DPO.model
     * @property {string} barcodeType
     * @property {string} barcodeData
     * @property {boolean} checkDigit
     * @property {boolean} displayPlainText
     * @property {boolean} autoSize
     * @property {number} minModuleWidth
     * @property {boolean} displayStartStopCode39
     * @property {number} zoomFactor
     * @property {string} merge
     * @property {DPO.model.BarcodeProperty[]} properties
     * @constructor
     */
    function Barcode() {
        DPO.model.Field.apply(this, arguments);
    }

    DPO.inherit(Barcode, DPO.model.Field);
    DPO.mixin(Barcode.prototype, {
        attributesBinding: [
            {name: 'barcodeType'},
            {name: 'barcodeData'},
            {name: 'checkDigit', type: 'bool'},
            {name: 'displayPlainText', type: 'bool'},
            {name: 'autoSize', type: 'bool', defaultValue: true},
            {name: 'minModuleWidth', type: 'number'},
            {name: 'moduleRatio', type: 'number'},
            {name: 'displayStartStopCode39', type: 'bool'},
            {name: 'zoomFactor', type: 'number'},
            {name: 'merge'}
        ],

        modelsBinding: [
            {el: 'avery:property', name: 'properties', cls: DPO.model.BarcodeProperty, collection: true}
        ],

        /**
         * Returns BarcodeProperty object by it's name
         * @memberof DPO.model.Barcode#
         * @param {string} name
         * @returns {DPO.model.BarcodeProperty}
         */
        getBarcodeProperty: function getProperty(name) {
            var p = null;
            for (var i = 0; i < this.properties.length; i++) {
                if (this.properties[i].name === name) {
                    p = this.properties[i];
                }
            }
            return p;
        },

        /**
         * Returns value of specified property
         * @memberof DPO.model.Barcode#
         * @param {string} name
         * @returns {string} value of property for name
         */
        getProperty: function getProperty(name) {
            var value = null;
            for (var i = 0; i < this.properties.length; i++) {
                if (this.properties[i].name === name) {
                    value = this.properties[i].value;
                }
            }
            return value;
        },

        /**Set some value to property with name
         * @memberof DPO.model.Barcode#
         * @param {string} name
         * @param value
         */
        setProperty: function setProperty(name, value) {
            for (var i = 0; i < this.properties.length; i++) {
                if (this.properties[i].name === name) {
                    this.properties[i].value = value;
                    return;
                }
            }

            this.properties.push(new DPO.model.BarcodeProperty(name, value));
        },

        /**
         * Returns data binding flags
         * 0 - none
         * 1 - sequential numbers
         * 2 - mail merge
         * @memberof DPO.model.Barcode#
         * @returns {number}
         */
        dataBindingFlags: function dataBinding() {
            var flags = 0;
            for (var i = 0; i < this.properties.length; i++) {
                var property = this.properties[i];
                if (property.serialNumberField) {
                    flags |= 1;
                }
                if (property.mailMergeField) {
                    flags |= 2;
                }
            }
            return flags;
        }
    });

    return Barcode;
});
DPO.def('model.BaseLayout', function() {
    /**
     * @class DPO.model.BaseLayout
     * @memberof DPO.model
     * @constructor
     */
    function BaseLayout() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(BaseLayout, DPO.xml.Model);
    DPO.mixin(BaseLayout.prototype, {
        valueBinding: {}
    });

    return BaseLayout;
});

DPO.def('model.Cutout', function() {
    /**
     * @class DPO.model.Cutout
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {string} shape
     * @property {number} width
     * @property {number} height
     * @property {DPO.model.Point} position
     * @property {DPO.model.Polypoints} polypoints
     * @property {DPO.model.Polypoints} polypoints
     * @constructor
     */
    function Cutout() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Cutout, DPO.xml.Model);
    DPO.mixin(Cutout.prototype, {
        attributesBinding: [
            { name: 'width',        type: 'number'  },
            { name: 'height',       type: 'number'  },
            { name: 'position',     type: 'point'   },
            { name: 'shape',                        defaultValue: 'rect'    },
            { name: 'cornerRadius', type: 'number', defaultValue: 0.0       }
        ],
        modelsBinding: [
            { el: 'avery:polypoints',  name: 'polypoints',    cls: DPO.model.Polypoints }
        ]
    });

    return Cutout;
});
DPO.def('model.Drawing', function () {
    /**
     * @class DPO.model.Drawing
     * @extends DPO.model.Field
     * @memberof DPO.model
     * @property {string} shape
     * @property {string} color
     * @property {boolean} maintainAspect
     * @property {DPO.model.Outline} outline
     * @property {DPO.model.Polypoints} polypoints
     * @constructor
     */
    function Drawing() {
        var me = this;
        DPO.model.Field.apply(me, arguments);
    }

    DPO.inherit(Drawing, DPO.model.Field);
    DPO.mixin(Drawing.prototype, {
        attributesBinding: [
            {name: 'shape', defaultValue: 'rect'},
            {name: 'color', defaultValue: '0xfde291'},
            {name: 'spotColor', defaultValue: ''},
            {name: 'maintainAspect', type: 'bool', defaultValue: false}
        ],
        modelsBinding: [
            {el: 'avery:outline', name: 'outline', cls: DPO.model.Outline, required: true},
            {el: 'avery:polypoints', name: 'polypoints', cls: DPO.model.Polypoints}
        ]
    });

    return Drawing;
});

DPO.def('model.FieldRef', function() {
    /**
     * @class DPO.model.FieldRef
     * @memberof DPO.model
     * @property {string} id
     * @property {string} contentId
     * @property {string} geometryId
     * @property {string} styleId
     * @property {?number} zOrder
     * @property {boolean} visible
     * @constructor
     */
    function FieldRef() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(FieldRef, DPO.xml.Model);
    DPO.mixin(FieldRef.prototype, {
        attributesBinding: [
            { name: 'id' },
            { name: 'zOrder',       type: 'number'  },
            { name: 'visible',      type: 'bool',   defaultValue: true },
            { name: 'contentId',    type: 'string'  },
            { name: 'styleId' },
            { name: 'geometryId',   type: 'string'  }
        ]
    });

    return FieldRef;
});
DPO.def('model.GridLayout', function() {
    /**
     * @class DPO.model.GridLayout
     * @memberof DPO.model
     * @constructor
     */
    function GridLayout() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(GridLayout, DPO.xml.Model);
    DPO.mixin(GridLayout.prototype, {
        attributesBinding: [
            { name: 'master' },
            { name: 'x',            type: 'number' },
            { name: 'y',            type: 'number' },
            { name: 'hpitch',       type: 'number' },
            { name: 'vpitch',       type: 'number' },
            { name: 'numberAcross', type: 'number' },
            { name: 'numberDown',   type: 'number' },
            { name: 'reorient',     type: 'bool' }
        ],
        modelsBinding: [
            { el: 'avery:description', name: 'description',   cls: DPO.model.Description }
        ]
    });

    return GridLayout;
});
DPO.def('model.Guide', function() {
    /**
     * @class DPO.model.Guide
     * @memberof DPO.model
     * @constructor
     */
    function Guide() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Guide, DPO.xml.Model);
    DPO.mixin(Guide.prototype, {
        attributesBinding: [
            { name: 'usage' },
            { name: 'startPosition',    type: 'point' },
            { name: 'endPosition',      type: 'point' },
            { name: 'shape',  defaultValue: 'line' },
            { name: 'cornerRadius', type: 'number', defaultValue: 0.0 }
        ]
    });

    return Guide;
});
DPO.def('model.Hint', function() {
    /**
     * @class DPO.model.Hint
     * @memberof DPO.model
     * @constructor
     */
    function Hint() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Hint, DPO.xml.Model);
    DPO.mixin(Hint.prototype, {
        attributesBinding: [
            { name: 'name' },
            { name: 'value' }
        ]
    });

    return Hint;
});
DPO.def('model.Image', function() {
    /**
     * @class DPO.model.Image
     * @extends DPO.model.Field
     * @memberof DPO.model
     * @property {string} source
     * @property {string} gallery
     * @property {string} color
     * @property {boolean} mirror
     * @property {boolean} stretch
     * @constructor
     */
    function Image() {
        DPO.model.Field.apply(this, arguments);
    }

    DPO.inherit(Image, DPO.model.Field);
    DPO.mixin(Image.prototype, {
        attributesBinding: [
            { name: 'source' },
            { name: 'gallery', defaultValue: ''},
            { name: 'color' },
            { name: 'mirror',   type: 'bool', defaultValue: false },
            { name: 'stretch',  type: 'bool', defaultValue: true }
        ]
    });

    return Image;
});
DPO.def('model.PanelSetOptions', function() {
    /**
     * @class DPO.model.PanelSetOptions
     * @memberof DPO.model
     * @property {string} master
     * @property {number} panelsPerSet
     * @property {boolean} allowGroup
     * @property {string} backMaster
     * @property {boolean} reverseBackSet
     * @constructor
     */
    function PanelSetOptions() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(PanelSetOptions, DPO.xml.Model);
    DPO.mixin(PanelSetOptions.prototype, {
        attributesBinding: [
            { name: 'master' },
            { name: 'panelsPerSet', type: 'number' },
            { name: 'allowGroup', type: 'bool', defaultValue: true },
            { name: 'backMaster' },
            { name: 'reverseBackSet', type: 'bool', defaultValue: false }
        ]
    });

    return PanelSetOptions;
});
DPO.def('model.ProductGroup', function() {
    /**
     * @class DPO.model.ProductGroup
     * @memberof DPO.model
     * @constructor
     */
    function ProductGroup() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(ProductGroup, DPO.xml.Model);
    DPO.mixin(ProductGroup.prototype, {
        valueBinding: {}
    });

    return ProductGroup;
});
DPO.def('model.Sku', function() {
    /**
     * @class DPO.model.Sku
     * @memberof DPO.model
     * @constructor
     */
    function Sku() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Sku, DPO.xml.Model);
    DPO.mixin(Sku.prototype, {
        attributesBinding: [{
            name: 'description'
        }],
        valueBinding: {}
    });

    return Sku;
});

DPO.def('model.Span', function () {
    /**
     * @class DPO.model.Span
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {string} color
     * @property {string} fontFamily
     * @property {string} fontLookup
     * @property {number} fontSize
     * @property {string} fontStyle
     * @property {string} fontWeight
     * @property {string} renderingMode
     * @property {string} textDecoration
     * @property {string} serialNumberField
     * @property {string} mailMergeField
     * @property {string} mailMergeId
     * @constructor
     */
    function Span() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Span, DPO.xml.Model);
    DPO.mixin(Span.prototype, {
        attributesBinding: [
            { name: 'color', defaultValue: '0x000000' },
            { name: 'spotColor', defaultValue: '' },
            { name: 'fontFamily', defaultValue: 'Arial' },
            { name: 'fontLookup', defaultValue: 'embeddedCFF' },
            { name: 'fontSize', type: 'number', defaultValue: 14 },
            { name: 'fontStyle', defaultValue: 'normal' },
            { name: 'fontWeight', defaultValue: 'normal' },
            { name: 'renderingMode', defaultValue: 'cff' },
            { name: 'textDecoration', defaultValue: 'none' },
            { name: 'serialNumberField' },
            { name: 'mailMergeField' },
            { name: 'mailMergeId' }
        ],

        valueBinding: {},

        /**
         * Copies style from specified span
         * @memberof DPO.model.Span#
         * @param {DPO.model.Span} span
         * @returns {DPO.model.Span}
         */
        copyStyle: function copyStyle(span) {
            var me = this;
            me.color = span.color;
            me.spotColor = span.spotColor;
            me.fontFamily = span.fontFamily;
            me.fontSize = span.fontSize;
            me.fontStyle = span.fontStyle;
            me.fontWeight = span.fontWeight;
            me.textDecoration = span.textDecoration;
            return /** @type DPO.model.Span*/me;
        },

        /**
         * Checks if spans have equal style
         * @memberof DPO.model.Span#
         * @param {DPO.model.Span} span
         * @returns {boolean}
         */
        isStylesEqual: function isStylesEqual(span) {
            var me = this,
                equal = true;
            equal = equal && span.color === me.color;
            equal = equal && span.fontFamily === me.fontFamily;
            equal = equal && span.fontSize === me.fontSize;
            equal = equal && span.fontStyle === me.fontStyle;
            equal = equal && span.fontWeight === me.fontWeight;
            equal = equal && span.textDecoration === me.textDecoration;
            return equal;
        },

        /**
         * Checks if spans can be merged
         * @memberof DPO.model.Span#
         * @param {DPO.model.Span} span
         * @param {boolean} [forceMailMerge]
         * @returns {boolean}
         */
        canMergeWith: function canMergeWith(span, forceMailMerge) {
            var me = this,
                can = this.isStylesEqual(span);
            can = can && !span.serialNumberField && !me.serialNumberField;
            if (forceMailMerge) {
                can = can && span.mailMergeField === me.mailMergeField;
            } else {
                can = can && !span.mailMergeField && !me.mailMergeField;
            }
            return can;
        }
    });

    return Span;
});
DPO.def('model.Paragraph', function () {
    /**
     * @class DPO.model.Paragraph
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {string} textAlign
     * @property {DPO.model.Span[]} spans
     * @constructor
     */
    function Paragraph() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Paragraph, DPO.xml.Model);
    DPO.mixin(Paragraph.prototype, {
        attributesBinding: [
            {name: 'defaultText', defaultValue: ''},
            {name: 'textAlign', defaultValue: 'center'}
        ],

        modelsBinding: [
            {el: 'span', name: 'spans', cls: DPO.model.Span, collection: true}
        ],

        /**
         * Returns plain text
         * @memberof DPO.model.Paragraph#
         * @returns {string}
         */
        getPlainText: function getPlainText() {
            var text = '';
            for (var j = 0; j < this.spans.length; j++) {
                var s = this.spans[j];
                text += s.value;
            }
            return text;
        }
    });

    return Paragraph;
});
DPO.def('model.TextFlow', function() {
    /**
     * @class DPO.model.TextFlow
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {string} verticalAlign
     * @property {string} whiteSpaceCollapse
     * @property {string} version
     * @property {string} xmlns
     * @property {DPO.model.Paragraph[]} paragraphs
     * @constructor
     */
    function TextFlow() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(TextFlow, DPO.xml.Model);
    DPO.mixin(TextFlow.prototype, {
        attributesBinding: [
            { name: 'verticalAlign', defaultValue: 'middle' },
            { name: 'whiteSpaceCollapse' },
            { name: 'version' }
        ],

        modelsBinding: [
            { el: 'p', name: 'paragraphs', cls: DPO.model.Paragraph, collection: true }
        ]
    });

    return TextFlow;
});
DPO.def('model.TextStyle', function() {
    /**
     * @class DPO.model.TextStyle
     * @memberof DPO.model
     * @property {string} typeface
     * @property {number} pointSize
     * @property {string} textColor
     * @property {string} styles
     * @property {string} overflow
     * @property {string} valign
     * @property {string} justification
     * @constructor
     */
    function TextStyle() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(TextStyle, DPO.xml.Model);
    DPO.mixin(TextStyle.prototype, {
        attributesBinding: [
            {name: 'typeface',      defaultValue: 'Arial' },
            {name: 'pointSize',     type: 'number', defaultValue: 14 },
            {name: 'textColor',     defaultValue: '0x000000' },
            {name: 'styles',        defaultValue: 'none' },
            {name: 'overflow',      defaultValue: 'wrap'},
            {name: 'valign',        defaultValue: 'top' },
            {name: 'justification', defaultValue: 'center' }
        ]
    });

    return TextStyle;
});
DPO.def('model.Text', function() {
    /**
     * @class DPO.model.Text
     * @memberof DPO.model
     * @property {string} merge
     * @property {boolean} hardReturn
     * @property {DPO.model.TextFlow} textFlow
     * @constructor
     */
    function Text() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Text, DPO.xml.Model);
    DPO.mixin(Text.prototype, {
        attributesBinding: [
            { name: 'merge' },
            { name: 'hardReturn', type: 'bool', defaultValue: true }
        ],

        modelsBinding: [
            { el: 'TextFlow',  name: 'textFlow', cls: DPO.model.TextFlow, ns: 'http://ns.adobe.com/textLayout/2008' }
        ]
    });

    return Text;
});
DPO.def('model.TextBlock', function () {
    /**
     * @class DPO.model.TextBlock
     * @extends DPO.model.Field
     * @memberof DPO.model
     * @property {string} styleId
     * @property {number} flashXScale
     * @property {number} flashLineHeight
     * @property {number} lineSpacing
     * @property {boolean} previewable
     * @property {DPO.model.TextStyle} textStyle
     * @property {DPO.model.Text} text
     * @constructor
     */
    function TextBlock() {
        DPO.model.Field.apply(this, arguments);
    }

    DPO.inherit(TextBlock, DPO.model.Field);
    DPO.mixin(TextBlock.prototype, {
        attributesBinding: [
            {name: 'styleId'},
            {name: 'flashXScale', type: 'number'},
            {name: 'flashLineHeight', type: 'number'},
            {name: 'lineSpacing', type: 'number'},
            {name: 'previewable', type: 'bool', defaultValue: true}
        ],

        modelsBinding: [
            {el: 'avery:textStyle', name: 'textStyle', cls: DPO.model.TextStyle},
            {el: 'avery:text', name: 'text', cls: DPO.model.Text}
        ],

        /**
         * Returns plain text
         * @memberof DPO.model.TextBlock#
         * @returns {string}
         */
        getPlainText: function getPlainText() {
            var text = '',
                paragraphs = this.text.textFlow.paragraphs;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i];
                text += '\n';
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j];
                    text += s.value;
                }
            }
            return text.replace(/\s/, '');
        },

        /**
         * Check if text block has merge data or sequential number
         *  @memberof DPO.model.TextBlock#
         * @returns {boolean}
         */
        hasMergeData: function hasMergeData() {
            var paragraphs = this.text.textFlow.paragraphs,
                result = false;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i],
                    text = '';
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j];
                    text += s.value;
                    result = result || !!s.mailMergeField;
                    result = result || !!s.serialNumberField;
                }
            }

            return result;
        },

        /**
         * Returns true if text block contains default text; otherwise false
         * @memberof DPO.model.TextBlock#
         * @returns {boolean}
         */
        containsDefaultText: function containsDefaultText() {
            var paragraphs = this.text.textFlow.paragraphs;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i],
                    text = '';
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j];
                    text += s.value;
                }

                if (text !== p.defaultText) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns data binding flags
         * 0 - none
         * 1 - sequential numbers
         * 2 - mail merge
         * @memberof DPO.model.TextBlock#
         * @returns {number}
         */
        dataBindingFlags: function dataBinding() {
            var paragraphs = this.text.textFlow.paragraphs,
                flags = 0;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i];
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j];
                    if (s.serialNumberField) {
                        flags |= 1;
                    }
                    if (s.mailMergeField) {
                        flags |= 2;
                    }
                }
            }
            return flags;
        }
    });

    return TextBlock;
});
DPO.def('model.TextDefaults', function() {
    /**
     * @class DPO.model.TextDefaults
     * @memberof DPO.model
     * @constructor
     */
    function TextDefaults() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(TextDefaults, DPO.xml.Model);
    DPO.mixin(TextDefaults.prototype, {
        attributesBinding: [
            {name: 'blockPosition', type: 'point' },
            {name: 'blockWidth',    type: 'number' },
            {name: 'blockHeight',   type: 'number' },
        ],

        modelsBinding: [
            { el: 'avery:textStyle',    name: 'textStyle',  cls: DPO.model.TextStyle  },
            { el: 'avery:hint',         name: 'hints',      cls: DPO.model.Hint,      collection: true    }
        ]
    });

    return TextDefaults;
});
DPO.def('model.TextLine', function() {
    /**
     * @class DPO.model.TextLine
     * @extends DPO.model.Field
     * @memberof DPO.model
     * @constructor
     */
    function TextLine() {
        DPO.model.Field.apply(this, arguments);
    }

    DPO.inherit(TextLine, DPO.model.Field);
    DPO.mixin(TextLine.prototype, {
        attributesBinding: [
            { name: 'styleId' }
        ],
        modelsBinding: [
            { el: 'avery:textStyle',    name: 'textStyle',      cls: DPO.model.TextStyle      },
            { el: 'avery:text',         name: 'texts',          cls: DPO.model.Text,      collection: true }
        ]
    });

    return TextLine;
});
DPO.def('model.TextPath', function() {
    /**
     * @class DPO.model.TextPath
     * @extends DPO.model.TextBlock
     * @memberof DPO.model
     * @property {number} textAngle
     * @property {DPO.model.Point} startPosition
     * @property {string} rotateSense
     * @property {string} shape
     * @constructor
     */
    function TextPath() {
        DPO.model.Field.apply(this, arguments);
    }

    DPO.inherit(TextPath, DPO.model.TextBlock);
    DPO.mixin(TextPath.prototype, {
        attributesBinding: [
            { name: 'maxLines',         type: 'number', defaultValue: 1 },
            { name: 'textAngle',        type: 'number', defaultValue: 270 },
            { name: 'startPosition',    type: 'point'   },
            { name: 'rotateSense',      defaultValue: 'cw' },
            { name: 'shape',            defaultValue: 'ellipse' }
        ]
    });

    return TextPath;
});
DPO.def('model.Introspector', function () {
    /**
     * @class DPO.model.Introspector
     * @extends DPO.xml.Introspector
     * @memberof DPO.model
     * @param {object} [cfg]
     * @constructor
     */
    function Introspector(cfg) {
        DPO.xml.Introspector.apply(this, arguments);
        this.modelLookupTable = DPO.model;
    }

    DPO.inherit(Introspector, DPO.xml.Introspector);
    DPO.mixin(Introspector.prototype, {
        types: DPO.mixin({}, DPO.xml.Introspector.prototype.types, {
            'point': {
                fromStr: function fromStr(value) {
                    return DPO.model.Point.fromString(value);
                },

                toStr: function toStr(value) {
                    return DPO.model.Point.toString(value);
                }
            }
        }),

        /**
         * Returns hint by it's name
         * @memberof DPO.model.Introspector#
         * @param {DPO.xml.Model|{hints: DPO.model.Hint[]}} obj
         * @param {string} name
         * @returns {?string}
         */
        getHintValue: function getHintValue(obj, name) {
            var hints = obj.hints || [],
                hint = null;
            for (var i = 0; !hint && i < hints.length; i++) {
                if (hints[i].name === name) {
                    hint = obj.hints[i];
                }
            }
            return hint ? hint.value : null;
        },


        /**
         * Gets hint's value by it's name
         * @memberof DPO.model.Introspector#
         * @param {DPO.xml.Model|{hints: DPO.model.Hint[]}} obj
         * @param {string} name
         * @param {string} value
         */
        setHintValue: function setHintValue(obj, name, value) {
            var hints = obj.hints || [],
                hint = null;
            for (var i = 0; !hint && i < hints.length; i++) {
                if (hints[i].name === name) {
                    hint = obj.hints[i];
                }
            }

            if (!hint) {
                hint = new DPO.model.Hint();
                hint.name = name;
                hints.push(hint);
            }

            hint.value = value;
        },

        /**
         * Restores project from snapshot
         * @memberof DPO.model.Introspector#
         * @param {DPO.model.Project} project
         * @param {DPO.model.Project} snapshot
         * @returns {DPO.model.Project}
         */
        restoreProject: function overrideProject(project, snapshot) {
            var keys = Object.keys(snapshot), i, key;
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                project[key] = snapshot[key];
            }
            return project;
        }
    });

    return Introspector;
});
DPO.def('model.AbstractPanel', function() {
    /**
     * @class DPO.model.AbstractPanel
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {DPO.model.Background[]} backgrounds
     * @property {DPO.model.Barcode[]} barcodes
     * @property {DPO.model.Description} description
     * @property {DPO.model.Drawing[]} drawings
     * @property {DPO.model.Hint[]} hints
     * @property {DPO.model.Image[]} images
     * @property {DPO.model.TextBlock[]} textBlocks
     * @property {DPO.model.TextLine[]} textLines
     * @property {DPO.model.TextPath[]} textPaths
     * @constructor
     */
    function AbstractPanel() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(AbstractPanel, DPO.xml.Model);
    DPO.mixin(AbstractPanel.prototype, {
        modelsBinding: [
            { el: 'avery:background',   name: 'backgrounds',    cls: DPO.model.Background,    collection: true },
            { el: 'avery:barcode',      name: 'barcodes',       cls: DPO.model.Barcode,       collection: true },
            { el: 'avery:description',  name: 'description',    cls: DPO.model.Description                     },
            { el: 'avery:drawing',      name: 'drawings',       cls: DPO.model.Drawing,       collection: true },
            { el: 'avery:hint',         name: 'hints',          cls: DPO.model.Hint,          collection: true },
            { el: 'avery:image',        name: 'images',         cls: DPO.model.Image,         collection: true },
            { el: 'avery:textBlock',    name: 'textBlocks',     cls: DPO.model.TextBlock,     collection: true },
            { el: 'avery:textLine',     name: 'textLines',      cls: DPO.model.TextLine,      collection: true },
            { el: 'avery:textPath',     name: 'textPaths',      cls: DPO.model.TextPath,      collection: true }
        ]
    });

    return AbstractPanel;
});

DPO.def('model.Panel', function() {
    /**
     * @class DPO.model.Panel
     * @extends DPO.model.AbstractPanel
     * @memberof DPO.model
     * @property {string} master
     * @property {DPO.model.Point} position
     * @property {number} rotation
     * @property {number} altSortOrder
     * @property {number} ignoreZ
     * @property {DPO.model.FieldRef[]} fieldRefs
     * @constructor
     */
    function Panel() {
        DPO.model.AbstractPanel.apply(this, arguments);
        this.internalId = DPO.id();
    }

    DPO.inherit(Panel, DPO.model.AbstractPanel);
    DPO.mixin(Panel.prototype, {
        attributesBinding: [
            { name: 'master' },
            { name: 'position',     type: 'point' },
            { name: 'rotation',     type: 'number',    defaultValue: 0.0 },
            { name: 'altSortOrder', type: 'number' },
            { name: 'ignoreZ',      type: 'bool',      defaultValue: false }
        ],
        modelsBinding: [
            { el: 'avery:fieldRef',     name: 'fieldRefs',      cls: DPO.model.FieldRef,      collection: true }
        ]
    });

    return Panel;
});

DPO.def('model.MasterPanel', function() {
    /**
     * @class DPO.model.MasterPanel
     * @extends DPO.model.AbstractPanel
     * @memberof DPO.model
     * @property {string} id
     * @property {number} width
     * @property {number} height
     * @property {string} shape
     * @property {number} cornerRadius
     * @property {boolean} bleed
     * @property {boolean} printOutline
     * @property {DPO.model.TextDefaults[]} textDefaults
     * @property {DPO.model.Cutout[]} cutouts
     * @property {DPO.model.Guide[]} guides
     * @property {DPO.model.Polypoints} polypoints
     * @property {boolean} editable
     * @property {boolean} previewable
     * @constructor
     */
    function MasterPanel() {
        DPO.model.AbstractPanel.apply(this, arguments);
    }

    DPO.inherit(MasterPanel, DPO.model.AbstractPanel);
    DPO.mixin(MasterPanel.prototype, {
        attributesBinding: [
            { name: 'id' },
            { name: 'width',             type: 'number' },
            { name: 'height',            type: 'number' },
            { name: 'shape',                             defaultValue: 'rect'    },
            { name: 'cornerRadius',      type: 'number', defaultValue: 0.0       },
            { name: 'bleed',             type: 'bool',   defaultValue: false     },
            { name: 'printOutline',      type: 'bool',   defaultValue: false     },
            { name: 'outlineColor'  },
            { name: 'mergeMap'      },
            { name: 'noBleedSides'  },
            { name: 'editable',     type: 'bool',   defaultValue: true },
            { name: 'previewable',  type: 'bool',   defaultValue: true }
        ],

        modelsBinding: [
            { el: 'avery:textDefaults', name: 'textDefaults',   cls: DPO.model.TextDefaults,    collection: true    },
            { el: 'avery:polypoints',   name: 'polypoints',     cls: DPO.model.Polypoints                           },
            { el: 'avery:cutout',       name: 'cutouts',        cls: DPO.model.Cutout,          collection: true    },
            { el: 'avery:guide',        name: 'guides',         cls: DPO.model.Guide,           collection: true    }
        ]
    });
    return MasterPanel;
});

DPO.def('model.Page', function () {
    /**
     * @class DPO.model.Page
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {number} width
     * @property {number} height
     * @property {string} paperSize
     * @property {string} viewOrientation
     * @property {boolean} doubleSided
     * @property {boolean} mirrorPrint
     * @property {string} paperColor
     * @property {string} paperImage
     * @property {boolean} print180
     * @property {DPO.model.Description} description
     * @property {DPO.model.Hint[]} hints
     * @property {DPO.model.GridLayout[]} gridLayouts
     * @property {DPO.model.Panel[]} panels
     * @property {DPO.model.Guide[]} guides
     * @constructor
     */
    function Page() {
        DPO.xml.Model.apply(this, arguments);
        this.internalId = DPO.id();
    }

    DPO.inherit(Page, DPO.xml.Model);
    DPO.mixin(Page.prototype, {
        attributesBinding: [
            {name: 'width', type: 'number'},
            {name: 'height', type: 'number'},
            {name: 'paperSize'},
            {name: 'viewOrientation'},
            {name: 'doubleSided', type: 'bool', defaultValue: false},
            {name: 'mirrorPrint', type: 'bool', defaultValue: false},
            {name: 'paperColor', defaultValue: '0xFFFFFF'},
            {name: 'paperImage'},
            {name: 'print180', type: 'bool', defaultValue: false}
        ],
        modelsBinding: [
            {el: 'avery:description', name: 'description', cls: DPO.model.Description},
            {el: 'avery:hint', name: 'hints', cls: DPO.model.Hint, collection: true},
            {el: 'avery:gridLayout', name: 'gridLayouts', cls: DPO.model.GridLayout, collection: true},
            {el: 'avery:panel', name: 'panels', cls: DPO.model.Panel, collection: true},
            {el: 'avery:guide', name: 'guides', cls: DPO.model.Guide, collection: true}
        ],

        /**
         * Returns page rotation in degrees according it's orientation
         * @memberof DPO.model.Page#
         * @returns {number}
         */
        getOrientation: function getOrientation() {
            switch (this.viewOrientation) {
                case 'landscape-cw':
                case 'preferLandscape-cw':
                    return 90;
                case 'landscape-ccw':
                case 'preferLandscape-ccw':
                    return -90;
                default:
                    return 0;
            }
        }
    });

    return Page;
});

DPO.def('model.SerialNumber', function() {
    /**
     * @class DPO.model.SerialNumber
     * @memberof DPO.model
     * @property {string} id
     * @property {string} prefix
     * @property {string} suffix
     * @property {number} step
     * @property {string} serialNumberType
     * @property {string} startValue
     * @property {string} endValue
     * @property {number} leadingZeros
     * @constructor
     */
    function SerialNumber() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(SerialNumber, DPO.xml.Model);
    DPO.mixin(SerialNumber.prototype, {
        attributesBinding: [
            { name: 'id' },
            { name: 'prefix' },
            { name: 'suffix' },
            { name: 'step',         type: 'number' },
            { name: 'serialNumberType' },
            { name: 'startValue' },
            { name: 'endValue' },
            { name: 'leadingZeros', type: 'number', defaultValue: 0}
        ],
        valueBinding: {}
    });

    return SerialNumber;
});

DPO.def('model.Project', function() {
    /**
     * @class DPO.model.Project
     * @extends DPO.xml.Model
     * @memberof DPO.model
     * @property {number} bleedOffset
     * @property {number} safeOffset
     * @property {DPO.model.Hint[]} hints
     * @property {DPO.model.Sku} sku
     * @property {DPO.model.BaseLayout} baseLayout
     * @property {DPO.model.ProductGroup} productGroup
     * @property {DPO.model.PanelSetOptions} panelSetOptions
     * @property {DPO.model.MasterPanel[]} masterPanels
     * @property {DPO.model.Page[]} pages
     * @property {DPO.model.SerialNumber[]} serialNumbers
     * @property {number} bleedOffset
     * @property {number} safeOffset
     * @constructor
     */
    function Project() {
        DPO.xml.Model.apply(this, arguments);
        this.bleedOffset = 90;
        this.safeOffset = -90;
    }

    DPO.inherit(Project, DPO.xml.Model);
    DPO.mixin(Project.prototype, {
        attributesBinding: [
            { name: 'xmlns:flash'           },
            { name: 'nudge'                 },
            { name: 'version'               },
            { name: 'language'              },
            { name: 'revision', type: 'number' },
            { name: 'copyright'             },
            { name: 'description'           },
            { name: 'designTheme'           },
            { name: 'doubleSided'           },
            { name: 'designCategory'        }
        ],

        modelsBinding: [
            { el: 'avery:hint',             name: 'hints',              cls: DPO.model.Hint,              collection: true    },
            { el: 'avery:sku',              name: 'sku',                cls: DPO.model.Sku                },
            { el: 'avery:baseLayout',       name: 'baseLayout',         cls: DPO.model.BaseLayout         },
            { el: 'avery:productGroup',     name: 'productGroup',       cls: DPO.model.ProductGroup       },
            { el: 'avery:panelSetOptions',  name: 'panelSetOptions',    cls: DPO.model.PanelSetOptions    },
            { el: 'avery:masterpanel',      name: 'masterPanels',       cls: DPO.model.MasterPanel,       collection: true },
            { el: 'avery:page',             name: 'pages',              cls: DPO.model.Page,              collection: true },
            { el: 'avery:serialNumber',     name: 'serialNumbers',      cls: DPO.model.SerialNumber,      collection: true }
        ]
    });

    return Project;
});

DPO.def('model.FieldOrder', function() {
    /**
     * DPO point type
     * @typedef {Object} DPO.model.OrderItem
     * @memberof DPO.model
     * @property {string} id
     * @property {number} zOrder
     * @property {DPO.model.FieldRef} ref
     * @property {DPO.model.Field} field
     */

    /**
     * Creates FieldOrder
     * @class DPO.model.FieldOrder
     * @memberof DPO.model
     * @param {DPO.model.Panel} panel
     * @param {DPO.model.OrderItem[]} items
     * @property {DPO.model.OrderItem[]} items
     * @property {DPO.model.Panel} panel
     * @constructor
     */
    function FieldOrder(panel, items) {
        var me = this;
        me.panel = panel;
        me.original = [].concat(items);
        me.items = [].concat(items);
        me.sort();
        me.applyOrder();
    }

    /**
     * Compares by z-index order
     * @memberof DPO.model.FieldOrder#
     * @param a
     * @param b
     * @returns {number}
     * @function
     */
    function CompareOrder(a, b) {
        return a.zOrder - b.zOrder;
    }

    DPO.mixin(FieldOrder.prototype, {
        sort: function sort() {
            this.items.sort(CompareOrder);
        },

        /**
         * Returns field sorted by z-order
         * @memberof DPO.model.FieldOrder#
         * @returns {DPO.model.Field[]}
         */
        getFields: function getFields() {
            var array = [];
            for (var i = 0; i < this.items.length; i++) {
                array.push(this.items[i].field);
            }
            return array;
        },

        /**
         * Returns order items for specified fields
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field[]} fields
         * @returns {Array}
         */
        getItems: function getItems(fields) {
            var items = [];
            for (var i = 0; i < fields.length; i++) {
                for (var j = 0; j < this.items.length; j++) {
                    if (fields[i] === this.items[j].field) {
                        items.push(this.items[j]);
                    }
                }
            }
            return items;
        },

        /**
         * @private
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field[]} fields
         */
        removeItems: function removeItems(fields) {
            var items = this.items;
            for (var i = 0; i < fields.length; i++) {
                items.splice(items.indexOf(fields[i]), 1);
            }
        },

        /**
         * Recalculates fields z-positions
         * @memberof DPO.model.FieldOrder#
         * @returns {DPO.model.FieldOrder}
         */
        applyOrder: function applyOrder() {
            for (var i = 0; i < this.items.length; i++) {
                this.items[i].zOrder = i;
            }
            return this;
        },

        /**
         * Sets field's z-order
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field} field
         * @param {number} zOrder
         * @returns {DPO.model.FieldOrder}
         */
        setZOrder: function setZOrder(field, zOrder) {
            var me = this,
                items = me.getItems([field]);
            if (items.length) {
                me.removeItems(items);
                me.items.splice(zOrder, 0, items[0]);
            }
            return me.applyOrder();
        },

        /**
         * Sends fields to back.
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.model.FieldOrder}
         */
        sendToBack: function sendToBack(fields) {
            var me = this,
                items = me.getItems(fields);
            me.removeItems(items);
            me.items = items.concat(me.items);
            me.sendBackgroundToBack();
            return me.sendBackgroundToBack().applyOrder();
        },

        /**
         * Sends background to back.
         * @memberof DPO.model.FieldOrder#
         * @returns {DPO.model.FieldOrder}
         */
        sendBackgroundToBack: function sendBackgroundToBack() {
            var me = this,
                fields = me.getFields(),
                bg = null;
            for (var j = 0; j < fields.length && !bg; j++) {
                bg = fields[j] instanceof DPO.model.Background ? fields[j] : null;
            }

            if (bg) {
                var items = me.getItems([bg]);
                me.removeItems(items);
                me.items = items.concat(me.items);
            }
            return me;
        },

        /**
         * Sends fields backward
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.model.FieldOrder}
         */
        sendBackward: function sendBackward(fields) {
            var me = this,
                items = me.items,
                reorder = me.getItems(fields), tmp;
            for (var i = 0; i < reorder.length; i++) {
                var index = items.indexOf(reorder[i]);
                if (index > 0) {
                    tmp = items[index];
                    items[index] = items[index - 1];
                    items[index - 1] = tmp;
                }
            }
            return me.sendBackgroundToBack().applyOrder();
        },

        /**
         * Brings fields to front.
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.model.FieldOrder}
         */
        bringToFront: function bringToFront(fields) {
            var me = this,
                items = me.getItems(fields);
            me.removeItems(items);
            me.items = me.items.concat(items);
            return me.sendBackgroundToBack().applyOrder();
        },

        /**
         * Brings fields forward
         * @memberof DPO.model.FieldOrder#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.model.FieldOrder}
         */
        bringForward: function bringForward(fields) {
            var me = this,
                items = me.items,
                reorder = me.getItems(fields), tmp;
            for (var i = reorder.length - 1; i >=0 ; i--) {
                var index = items.indexOf(reorder[i]);
                if (index < items.length - 1) {
                    tmp = items[index];
                    items[index] = items[index + 1];
                    items[index + 1] = tmp;
                }
            }
            return me.sendBackgroundToBack().applyOrder();
        }
    });

    return FieldOrder;
});
DPO.def('model.Selector', function () {
    var internalProperties = [
            'id',
            'contentId',
            'geometryId',
            'promptOrder',
            'zOrder',
            'visible',
            'editable',
            'movable',
            'description',
            'previewable',
            'print',
            'styleable',
            'styleId'
        ],
        geometryProperties = [
            'position',
            'rotation',
            'width',
            'height',
            'polypoints'
        ];

    /**
     * @class DPO.model.Selector
     * @extends DPO.model.Introspector
     * @param {DPO.model.Project} project
     * @memberof DPO.model
     * @constructor
     */
    function Selector(project) {
        this.project = project;
        this.cache = null;
    }

    DPO.inherit(Selector, DPO.model.Introspector);
    DPO.mixin(Selector.prototype, {
        /**
         * Clears selector's cache
         * @memberof DPO.model.Selector#
         */
        clearCache: function clearCache() {
            this.cache = null;
        },

        /**
         * Prepares cache for collecting
         * @memberof DPO.model.Selector#
         */
        prepareCache: function prepareCache() {
            this.cache = {
                panelIndexes: {},
                panels: [],
                refs: {},
                masterMap: {},
                fieldsMap: {}
            };
        },

        /**
         * Collects fields
         * @private
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field[]} collection
         */
        collectFields: function collectFields(collection) {
            var fieldsMap = this.cache.fieldsMap;
            for (var i = 0; i < collection.length; i++) {
                var f = collection[i];
                fieldsMap[f.id] = f;
            }
        },

        /**
         * Collects cache data for all master panels
         * @memberof DPO.model.Selector#
         */
        collectMasterPanels: function callectMasterPanels() {
            var me = this,
                mps = me.project.masterPanels;
            for (var i = 0; i < mps.length; i++) {
                var mp = mps[i];
                me.cache.masterMap[mp.id] = mp;
                me.collectFields(mp.images);
                me.collectFields(mp.barcodes);
                me.collectFields(mp.drawings);
                me.collectFields(mp.textBlocks);
                me.collectFields(mp.textPaths);
                me.collectFields(mp.textLines);
                me.collectFields(mp.backgrounds);
            }
        },

        /**
         * Collects cache data for specified panel
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} panel
         */
        collectPanelData: function collectPanelData(panel) {
            var me = this;
            me.collectFields(panel.images);
            me.collectFields(panel.barcodes);
            me.collectFields(panel.drawings);
            me.collectFields(panel.textBlocks);
            me.collectFields(panel.textPaths);
            me.collectFields(panel.textLines);
            me.collectFields(panel.backgrounds);
            me.cache.panels.push(panel);

            for (var i = 0; i < panel.fieldRefs.length; i++) {
                var r = panel.fieldRefs[i];
                me.cache.refs[r.id] = r;
            }

            var indexes = me.cache.panelIndexes[panel.master] || [];
            indexes.push(panel);
            me.cache.panelIndexes[panel.master] = indexes;
        },

        /**
         * Collects page data
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Page} page
         */
        collectPageData: function collectPageData(page) {
            for (var j = 0; j < page.panels.length; j++) {
                this.collectPanelData(page.panels[j]);
            }
        },

        /**
         * Collects all field data
         * @memberof DPO.model.Selector#
         */
        collectData: function collectData() {
            var me = this,
                pgs = me.project.pages;
            if (me.cache) {
                return;
            }

            me.prepareCache();
            me.collectMasterPanels();

            for (var i = 0; i < pgs.length; i++) {
                me.collectPageData(pgs[i]);
            }
        },

        /**
         * Returns field with specified identifier
         * @memberof DPO.model.Selector#
         * @param {string} id
         * @returns {DPO.model.Field}
         */
        getField: function getField(id) {
            this.collectData();
            return this.cache.fieldsMap[id];
        },

        /**
         * Returns field reference with specified identifier
         * @memberof DPO.model.Selector#
         * @param {string} id
         * @returns {DPO.model.FieldRef}
         */
        getRef: function getRef(id) {
            this.collectData();
            return this.cache.refs[id];
        },

        /**
         * Returns fields (ordered by ids) that match the passed matcher
         * @memberof DPO.model.Selector#
         * @param {function} matcher
         * @returns {DPO.model.Field[]}
         */
        selectFields: function selectFields(matcher) {
            var me = this;
            me.collectData();

            var map = me.cache.fieldsMap,
                ids = Object.keys(map).sort(),
                result = [];
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i],
                    field = map[id];
                if (matcher(field)) {
                    result.push(field);
                }
            }
            return result;
        },

        /**
         * Returns field's properties by it's type
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field} field
         * @param {string} type - geometry or content
         * @returns {object}
         */
        getFieldProperties: function getFieldProperties(field, type) {
            var geometry = {},
                content = {},
                keys = Object.keys(field), i;
            for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (internalProperties.indexOf(key) !== -1) {
                    continue;
                }

                if (geometryProperties.indexOf(key) !== -1) {
                    geometry[key] = field[key];
                } else {
                    content[key] = field[key];
                }
            }

            switch (type) {
                case 'geometry':
                    return geometry;
                case 'content':
                    return content;
                default:
                    return {};
            }
        },

        /**
         * Returns properties mode
         * @memberof DPO.model.Selector#
         * @param {object} field
         * @returns {number} 0 - empty; 1 - geometry; 2 - content
         */
        getFieldPropertiesMode: function getFieldPropertiesMode(field) {
            var mode = 0,
                keys = Object.keys(field), i;
            for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (internalProperties.indexOf(key) !== -1) {
                    continue;
                }

                if (geometryProperties.indexOf(key) !== -1) {
                    mode |= 1;
                } else {
                    mode |= 2;
                }
            }

            return mode;
        },

        /**
         * Returns center point of specified field(s)
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {boolean} [skipTransform]
         * @returns {{x: number, y: number}}
         */
        getCenter: function getCenter(fields, skipTransform) {
            var bounds = this.getBounds(fields, skipTransform);
            return {
                x: bounds.cx,
                y: bounds.cy
            };
        },

        /**
         * Tests if point is inside box
         * @memberof DPO.model.Selector#
         * @param {{x: number, y: number}} p
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @returns {boolean}
         */
        isPointInsideBox: function isPointInsideBox(p, x1, y1, x2, y2) {
            return !(p.x < x1 || p.y < y1 || p.x > x2 || p.y > y2);
        },

        /**
         * Tests if field is inside box
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field} f
         * @param {number} x1
         * @param {number} y1
         * @param {number} width
         * @param {number} height
         * @returns {boolean}
         */
        isFieldInsideBox: function isFieldInsideBox(f, x1, y1, width, height) {
            var me = this,
                x2 = x1 + width,
                y2 = y1 + height,
                points = me.getBoundsPoints(f),
                inside = true;
            inside = inside && me.isPointInsideBox(points.ne, x1, y1, x2, y2);
            inside = inside && me.isPointInsideBox(points.nw, x1, y1, x2, y2);
            inside = inside && me.isPointInsideBox(points.se, x1, y1, x2, y2);
            inside = inside && me.isPointInsideBox(points.sw, x1, y1, x2, y2);
            return inside;
        },

        /**
         * Returns field's bounding points
         * @memberof DPO.model.Selector#
         * @param {object} field
         * @param {boolean} [ignoreTransform]
         * @param {boolean} [renderBounds]
         * @returns {{nw: {x: number, y: number}, ne: {x: number, y: number}, se: {x: number, y: number}, sw: {x: number, y: number}}}
         */
        getBoundsPoints: function getBoundsPoints(field, ignoreTransform, renderBounds) {
            var position = field.position,
                left = position.x,
                top = position.y,
                right = position.x + field.width,
                bottom = position.y + field.height,
                inflation = 0,
                matrix = new DPO.math.Matrix();
            if (field.outline) {
                inflation = field.outline.width / 2;
            }

            if (field instanceof DPO.model.TextPath) {
                var attr = this.collectRichTextAttributes(field),
                    max = attr.sizes[0];
                for (var i = 1; i < attr.sizes.length; i++) {
                    max = Math.max(max, attr.sizes[i]);
                }

                inflation = max * 18;
            }

            if (!ignoreTransform) {
                matrix.rotate(360 - field.rotation, left, top);
            }

            if (renderBounds) {
                left -= inflation;
                top -= inflation;
                right += inflation;
                bottom += inflation;
            }

            return {
                nw: matrix.point(left, top),
                ne: matrix.point(right, top),
                se: matrix.point(right, bottom),
                sw: matrix.point(left, bottom)
            };
        },

        /**
         * Returns bounds of specified field(s)
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {boolean} [ignoreTransform]
         * @param {boolean} [renderBounds]
         * @returns {{cx: number, cy: number, x: Number, y: Number, width: number, height: number, left: Number, right: Number, top: Number, bottom: Number}}
         */
        getBounds: function getFieldsBounds(fields, ignoreTransform, renderBounds) {
            fields = (fields instanceof Array) ? fields : [fields];
            var left = Number.POSITIVE_INFINITY,
                top = Number.POSITIVE_INFINITY,
                right = Number.NEGATIVE_INFINITY,
                bottom = Number.NEGATIVE_INFINITY;

            for (var i = 0; i < fields.length; i++) {
                var field = fields[i],
                    bounds = this.getBoundsPoints(field, ignoreTransform, renderBounds);
                left = Math.min(left, bounds.nw.x, bounds.ne.x, bounds.se.x, bounds.sw.x);
                top = Math.min(top, bounds.nw.y, bounds.ne.y, bounds.se.y, bounds.sw.y);
                right = Math.max(right, bounds.nw.x, bounds.ne.x, bounds.se.x, bounds.sw.x);
                bottom = Math.max(bottom, bounds.nw.y, bounds.ne.y, bounds.se.y, bounds.sw.y);
            }

            return {
                cx: (left + right) / 2,
                cy: (top + bottom) / 2,
                x: left,
                y: top,
                width: right - left,
                height: bottom - top,
                left: left,
                right: right,
                top: top,
                bottom: bottom
            };
        },

        /**
         * Returns field at specified position ordered by z-order
         * @memberof DPO.model.Selector#
         * @param {number} x x-coordinate in twips in panel space
         * @param {number} y y-coordinate in twips in panel space
         * @param {DPO.model.Panel} panel
         * @returns {DPO.model.Field[]}
         */
        getFieldsAtPos: function getFieldsAtPos(x, y, panel) {
            var order = this.getFieldOrder(panel),
                fields = order.getFields(),
                result = [];
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    matrix = new DPO.math.Matrix(),
                    inflation = 0,
                    pos = f.position,
                    rect = new DPO.math.Rect(0, 0, f.width, f.height);
                matrix.rotate(f.rotation, 0, 0);

                if (f instanceof DPO.model.TextPath) {
                    var attr = this.collectRichTextAttributes(f),
                        max = -Infinity;
                    for (var j = 0; j < attr.sizes.length; j++) {
                        max = Math.max(max, attr.sizes[j]);
                    }

                    inflation = max * 18;
                }

                var p = matrix.point(x - pos.x, y - pos.y);
                rect.inflate(inflation, inflation);
                if (rect.containsPoint(p)) {
                    result.push(f);
                }
            }

            return result;
        },

        /**
         * Selects all panels
         * @memberof DPO.model.Selector#
         * @returns {DPO.model.Panel[]}
         */
        selectPanels: function selectPanels() {
            var pgs = this.project.pages,
                panels = [];
            for (var i = 0; i < pgs.length; i++) {
                panels = panels.concat(pgs[i].panels);
            }
            return panels;
        },

        /**
         * Returns panel's text blocks
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} [panel]
         * @returns {DPO.model.Field[]}
         */
        selectPanelTextFields: function selectPanelTextFields(panel) {
            var order = this.getFieldOrder(panel),
                allFields = order.getFields(),
                textBlocks = [];

            for (var i = 0; i < allFields.length; i++) {
                var field = allFields[i];
                if (field instanceof DPO.model.TextBlock) {
                    textBlocks.push(field);
                }
            }

            return textBlocks;
        },

        /**
         * Returns panel's text block sorted by position
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} [panel]
         * @returns {DPO.model.Field[]}
         */
        selectPanelTextFieldsSortedByPosition: function selectPanelTextFieldsSortedByPosition(panel) {
            var me = this,
                textBlocks = me.selectPanelTextFields(panel),
                delta;

            textBlocks = textBlocks
                .filter(function (textBlock) {
                    return !me.isPropertyOnField(textBlock, 'mailMergeField');
                })
                .filter(function (textBlock) {
                    return !me.isPropertyOnField(textBlock, 'serialNumberField');
                });

            return textBlocks.sort(function (block, otherBlock) {
                delta = block.position.y - otherBlock.position.y;
                if (!delta) {
                    delta = block.position.x - otherBlock.position.x;
                }
                return delta;
            });

        },

        /**
         * Returns panel's fields
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} [panel]
         * @returns {DPO.model.Field[]}
         */
        selectPanelFields: function selectPanelFields(panel) {
            this.collectData();

            var fields = [];
            panel = panel || this.project.pages[0].panels[0];
            for (var i = 0; i < panel.fieldRefs.length; i++) {
                var ref = panel.fieldRefs[i],
                    field = this.cache.fieldsMap[ref.contentId];
                fields.push(field);
            }

            fields = fields.concat(
                panel.images,
                panel.barcodes,
                panel.drawings,
                panel.textBlocks,
                panel.textPaths,
                panel.textLines);

            return fields;
        },

        /**
         * Returns master panel
         * @memberof DPO.model.Selector#
         * @param {string|DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.model.MasterPanel}
         */
        selectMasterPanel: function selectMasterPanel(panel) {
            var id = typeof panel === 'string' ? panel : panel.master || panel.id;
            this.collectData();
            return this.cache.masterMap[id];
        },

        /**
         * Returns field order object for specified panel
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel|DPO.model.MasterPanel} [panel]
         * @returns {DPO.model.FieldOrder}
         */
        getFieldOrder: function getFieldOrder(panel) {
            this.collectData();

            var items = [], i, f, refs;
            panel = panel || this.project.pages[0].panels[0];
            refs = panel.fieldRefs || [];

            for (i = 0; i < refs.length; i++) {
                var ref = refs[i];
                f = this.cache.fieldsMap[ref.contentId];
                items.push({
                    id: f.id,
                    zOrder: ref.zOrder == null ? f.zOrder : ref.zOrder,
                    ref: ref,
                    field: this.cache.fieldsMap[ref.contentId]
                });
            }

            var fields = [].concat(
                panel.images,
                panel.barcodes,
                panel.drawings,
                panel.backgrounds,
                panel.textBlocks,
                panel.textPaths,
                panel.textLines);
            for (i = 0; i < fields.length; i++) {
                f = fields[i];
                items.push({
                    id: f.id,
                    zOrder: f.zOrder,
                    ref: null,
                    field: f
                });
            }
            return new DPO.model.FieldOrder(panel, items);
        },

        /**
         * Returns max opacity value
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {number}
         */
        getMaxOpacity: function getMaxOpacity(fields) {
            fields = fields instanceof Array ? fields : [fields];
            var max = 0;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                max = Math.max(max, f.opacity, f.outline ? f.outline.opacity : 0);
            }
            return max;
        },

        /**
         * Returns min transparency value
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {number}
         */
        getMinTransparency: function getMinTransparency(fields) {
            return 1 - this.getMaxOpacity(fields);
        },

        /**
         * Returns max fill opacity value
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {number}
         */
        getMaxFillOpacity: function getMaxOpacity(fields) {
            fields = fields instanceof Array ? fields : [fields];
            var max = 0;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                max = Math.max(max, f.opacity);
            }
            return max;
        },

        /**
         * Returns max fill opacity value
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {number}
         */
        getMaxOutlineOpacity: function getMaxOpacity(fields) {
            fields = fields instanceof Array ? fields : [fields];
            var max = 0;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                max = Math.max(max, f.outline ? f.outline.opacity : 0);
            }
            return max;
        },

        /**
         * Returns minimal outline width
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {number}
         */
        getMinOutlineWidth: function getMinOutlineWidth(fields) {
            fields = fields instanceof Array ? fields : [fields];

            var min = Number.MAX_VALUE;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                min = Math.min(min, f.outline.width);
            }

            return min;
        },

        /**
         * Returns color outline
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {DPO.model.Color}
         */
        getOutlineColor: function getOutlineColor(fields) {
            fields = fields instanceof Array ? fields : [fields];
            var colors = {};
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                colors[f.outline.color.toUpperCase()] = {
                    hex: f.outline.color,
                    spot: f.outline.spotColor
                };
            }

            var keys = Object.keys(colors),
                key = keys[0],
                color = key ? colors[key] : null,
                colorModel = null;

            if (color) {
                colorModel = DPO.model.Color.fromHex(color.hex);
                colorModel.spot = color.spot;
                colorModel.a = this.getMaxFillOpacity(fields);
            }

            return colorModel;
        },

        /**
         * Returns fill color
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {DPO.model.Color}
         */
        getFillColor: function getFillColor(fields) {
            fields = fields instanceof Array ? fields : [fields];
            var colors = {};
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                colors[f.color.toUpperCase()] = {
                    hex: f.color,
                    spot: f.spotColor
                };
            }

            var keys = Object.keys(colors),
                key = keys[0],
                color = key ? colors[key] : null,
                colorModel = null;

            if (color) {
                colorModel = DPO.model.Color.fromHex(color.hex);
                colorModel.spot = color.spot;
                colorModel.a = this.getMaxFillOpacity(fields);
            }

            return colorModel;
        },

        /**
         * Returns text angle
         * @memberof DPO.model.Selector#
         * @param {DPO.model.TextPath|DPO.model.TextPath[]} fields
         * @returns {?number}
         */
        getTextAngle: function getTextAngle(fields) {
            fields = fields instanceof Array ? fields : [fields];
            var angles = {};
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                angles[f.textAngle] = f.textAngle;
            }

            var keys = Object.keys(angles),
                key = keys[0];
            return key ? angles[key] : null;
        },

        /**
         * Collects rich text attributes
         * @memberof DPO.model.Selector#
         * @param {object|object[]} objectOrArray
         * @returns {{fonts: Array, sizes: Array, colors: Array, bold: boolean, italic: boolean, underline: boolean}}
         */
        collectRichTextAttributes: function collectRichTextAttributes(objectOrArray) {
            var fontMap = {},
                sizeMap = {},
                colorsData = [],
                textAlignment = {},
                verticalTextAlignment = {},
                boldMask = 0,
                italicMask = 0,
                underlineMask = 0,
                sizes = [], keys, i;
            objectOrArray = objectOrArray instanceof Array ? objectOrArray : [objectOrArray];

            function collectForSpan(span) {
                fontMap[span.fontFamily] = 1;
                sizeMap[span.fontSize] = 1;
                colorsData.push({
                    hex: span.color.toUpperCase(),
                    spot: span.spotColor
                });

                switch (span.fontWeight) {
                    case 'normal':
                        boldMask |= 1;
                        break;
                    case 'bold':
                        boldMask |= 2;
                        break;
                }
                switch (span.fontStyle) {
                    case 'normal':
                        italicMask |= 1;
                        break;
                    case 'italic':
                        italicMask |= 2;
                        break;
                }
                switch (span.textDecoration) {
                    case 'none':
                        underlineMask |= 1;
                        break;
                    case 'underline':
                        underlineMask |= 2;
                        break;
                }
            }

            function collectForParagraph(p) {
                for (var i = 0; i < p.spans.length; i++) {
                    collectForSpan(p.spans[i]);
                    textAlignment[p.textAlign] = 1;
                }
            }

            function collectForTextBlock(textBlock) {
                var textFlow = textBlock.text.textFlow;
                for (var i = 0; i < textFlow.paragraphs.length; i++) {
                    var p = textFlow.paragraphs[i];
                    collectForParagraph(p);
                }
                verticalTextAlignment[textFlow.verticalAlign] = 1;
            }

            for (i = 0; i < objectOrArray.length; i++) {
                var item = objectOrArray[i];
                if (item instanceof DPO.model.TextBlock) {
                    collectForTextBlock(item);
                    continue;
                }

                if (item instanceof DPO.model.Paragraph) {
                    collectForParagraph(item);
                    continue;
                }

                if (item instanceof DPO.model.Span) {
                    collectForSpan(item);
                }
            }

            keys = Object.keys(sizeMap);
            for (i = 0; i < keys.length; i++) {
                sizes.push(keys[i] - 0);
            }

            var colors = [];
            for (i = 0; i < colorsData.length; i++) {
                var data = colorsData[i],
                    color = DPO.model.Color.fromHex(data.hex);

                if (data.spot) {
                    color.spot = data.spot;
                }

                colors.push(color);
            }

            return {
                fonts: Object.keys(fontMap),
                sizes: sizes,
                colors: colors,
                textAlignment: Object.keys(textAlignment),
                verticalTextAlignment: Object.keys(verticalTextAlignment),
                bold: boldMask === 3 ? null : boldMask === 2,
                italic: italicMask === 3 ? null : italicMask === 2,
                underline: underlineMask === 3 ? null : underlineMask === 2
            };
        },

        /**
         * Collect paragraph and spans attributes
         * @memberof DPO.model.Selector#
         * @param {string} fieldId
         * @returns {[{textAlign: String, spans: {}}]}
         */
        collectParagraphAndSpanTextAttributes: function collectParagraphAndSpanTextAttributes(fieldId) {
            var field = this.getField(fieldId);
            return field.text.textFlow.paragraphs.map(function (p) {
                return {
                    textAlign: p.textAlign,
                    spans: {
                        fontFamily: p.spans[0].fontFamily,
                        fontSize: p.spans[0].fontSize,
                        color: p.spans[0].color,
                        fontStyle: p.spans[0].fontStyle,
                        fontWeight: p.spans[0].fontWeight,
                        textDecoration: p.spans[0].textDecoration
                    }
                };
            });
        },

        /**
         * Select all child panels, if needed - from page
         * @memberof DPO.model.Selector#
         * @param {DPO.model.MasterPanel} masterPanel
         * @param {DPO.model.Page} [page]
         * @returns {DPO.model.Panel[]}
         */
        selectChildPanels: function selectChildPanels(masterPanel, page) {
            this.collectData();
            var allPanels,
                panels = [];

            allPanels = (page) ? page.panels : this.cache.panels;

            for (var i = 0; i < allPanels.length; i++) {
                var panel = allPanels[i];
                if (panel.master === masterPanel.id) {
                    panels.push(panel);
                }
            }

            return panels;
        },

        /**
         * Selects sheets
         * @memberof DPO.model.Selector#
         * @returns {object[]}
         */
        selectSheets: function selectSheets() {
            var sheets = [],
                pages = this.project.pages,
                index = 0, i = 0;
            while (i < pages.length) {
                var page = pages[i];
                if (page.doubleSided) {
                    sheets.push({
                        index: index++,
                        front: pages[i],
                        back: pages[i + 1]
                    });
                    i += 2;
                } else {
                    sheets.push({
                        index: index++,
                        front: pages[i],
                        back: null
                    });
                    i += 1;
                }
            }

            return sheets;
        },

        /**
         * Returns amount of child panels in sheet
         * @memberof DPO.model.Selector#
         * @param {DPO.model.MasterPanel} masterPanel
         * @param {{front: DPO.model.Page, back: DPO.model.Page}} sheet
         * @returns {number}
         */
        amountPanelsInSheet: function amountPanelsInSheet(masterPanel, sheet) {
            var count = 0,
                pages = [sheet.front, sheet.back];
            for (var i = 0; i < pages.length && pages[i]; i++) {
                var page = pages[i];
                for (var j = 0; j < page.panels.length; j++) {
                    var panel = page.panels[j];
                    count += panel.master === masterPanel.id;
                }
            }

            return count;
        },

        /**
         * Returns sheet for specified page
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Page} page
         * @returns {*}
         */
        getSheet: function getSheet(page) {
            var sheet = {index: 0, front: null, back: null},
                pages = this.project.pages,
                index = 0, i = 0, p;
            while (i < pages.length) {
                p = pages[i];
                sheet.index = index++;
                if (p.doubleSided) {
                    sheet.front = p;
                    sheet.back = pages[i + 1];
                    i += 2;
                } else {
                    sheet.front = p;
                    sheet.back = null;
                    i += 1;
                }

                if (sheet.front === page || sheet.back === page) {
                    return sheet;
                }
            }

            return null;
        },

        /**
         * Checks if text block contains spans with defined property
         * @memberof DPO.model.Selector#
         * @param {DPO.model.TextBlock} field
         * @param {String} property
         * @returns {boolean}
         */
        isPropertyOnField: function isMailMergeField(field, property) {
            var paragraphs = field.text.textFlow.paragraphs,
                spans;
            for (var i = 0; i < paragraphs.length; i++) {
                spans = paragraphs[i].spans;
                for (var j = 0; j < spans.length; j++) {
                    if (spans[j][property]) {
                        return true;
                    }
                }
            }
            return false;
        },

        /**
         * Returns count of serial number combinations
         * @memberof DPO.model.Selector#
         * @param {DPO.model.SerialNumber} serialNumber
         * @returns {number}
         */
        serialNumbersCount: function serialNumbersCount(serialNumber) {
            if (!serialNumber) {
                return 0;
            }

            var start, end;
            switch (serialNumber.serialNumberType) {
                case 'Numeric Serial Number' :
                    start = serialNumber.startValue - 0;
                    end = serialNumber.endValue - 0;
                    return Math.floor((Math.max(start, end) - Math.min(start, end)) / serialNumber.step + 1);
                case 'Alphabetic Serial Number'  :
                    start = this.convertBase26ToNumber(this.convertStringToBase26(serialNumber.startValue));
                    end = this.convertBase26ToNumber(this.convertStringToBase26(serialNumber.endValue));
                    return Math.floor((Math.max(start, end) - Math.min(start, end)) / serialNumber.step + 1);
                default :
                    return 0;
            }
        },

        /**
         * Returns serial number by it's identifier.
         * @memberof DPO.model.Selector#
         * @param {string} id
         * @returns {DPO.model.SerialNumber}
         */
        getSerialNumber: function getSerialNumber(id) {
            var serialNumbers = this.project.serialNumbers;
            for (var i = 0; i < serialNumbers.length; i++) {
                if (serialNumbers[i].id === id) {
                    return serialNumbers[i];
                }
            }
            return null;
        },

        /**
         * Generating text for current serial number field for Numeric Type
         * @memberof DPO.model.Selector#
         * @param {number} index - number of panel (number of current serial number)
         * @param {DPO.model.SerialNumber} serialNumber - field
         * @returns {string}
         */
        generateNumericalNumber: function generateNumericalNumber(index, serialNumber) {
            var value,
                start = serialNumber.startValue - 0,
                end = serialNumber.endValue - 0,
                zeros = serialNumber.leadingZeros;

            if (start <= end) {
                value = index * serialNumber.step + start;
            } else {
                value = start - index * serialNumber.step;
            }

            if (value >= Math.min(start, end) && value <= Math.max(start, end)) {
                var str = Math.pow(10, zeros).toString() + value.toString();
                str = str.substr(str.length - Math.max(value.toString().length, zeros));

                if (serialNumber.prefix) {
                    str = serialNumber.prefix + str;
                }
                if (serialNumber.suffix) {
                    str += serialNumber.suffix;
                }
                return str;
            }

            return '';
        },

        /**
         * Generating text for current serial number field for Alphabetical Type
         * @memberof DPO.model.Selector#
         * @param {number} index - number of panel (number of current serial number)
         * @param {DPO.model.SerialNumber} serialNumber - field
         * @returns {string}
         */
        generateAlphabeticalNumber: function generateAlphabeticalNumber(index, serialNumber) {
            var value = index * serialNumber.step,
                stVal = this.convertBase26ToNumber(this.convertStringToBase26(serialNumber.startValue)),
                endVal = this.convertBase26ToNumber(this.convertStringToBase26(serialNumber.endValue));

            if (stVal <= endVal) {
                value = index * serialNumber.step + stVal;
            } else {
                value = stVal - index * serialNumber.step;
            }

            if (value >= Math.min(stVal, endVal) && value <= Math.max(stVal, endVal)) {
                var base26 = this.convertNumberToBase26(value),
                    str = this.convertBase26ToString(
                        base26,
                        serialNumber.startValue,
                        Math.min(serialNumber.startValue.length, serialNumber.endValue.length)
                    );

                if (serialNumber.prefix) {
                    str = serialNumber.prefix + str;
                }
                if (serialNumber.suffix) {
                    str += serialNumber.suffix;
                }
                return str;
            }

            return '';
        },

        /**
         * Convert base-26 number system (a-0 ... z-25) to integer.
         * @memberof DPO.model.Selector#
         * @param {number[]} value
         * @returns {number}
         */
        convertBase26ToNumber: function convertBase26ToNumber(value) {
            var result = 0;
            for (var i = 0; i < value.length; i++) {
                result += Math.pow(26, value.length - i - 1) * value[i];
            }

            return result;
        },

        /**
         * Convert integer to base-26 number system (a-0 ... z-25).
         * @memberof DPO.model.Selector#
         * @param {number} value
         * @returns {number[]}
         */
        convertNumberToBase26: function convertNumberToBase26(value) {
            var result = [],
                remainder = 0,
                order = value;
            do
            {
                remainder = order % 26;
                order /= 26;
                result.unshift(remainder);
            }
            while ((order >> 0) > 0);

            return result;
        },

        /**
         * Convert base-26 number system (a-0 ... z-25) to String.
         * @memberof DPO.model.Selector#
         * @param value - array of base 26 numbers
         * @param startValue - from this num the value is counted
         * @param leadingZeros - amount of zeros on beginning of the value i.e. 0005 has 3 leading zeros
         * @return {string}
         */
        convertBase26ToString: function convertBase26ToString(value, startValue, leadingZeros) {
            var result = '';
            while (value.length < leadingZeros) {
                value.unshift(0);
            }

            for (var i = 0; i < value.length; i++) {
                if (startValue.charCodeAt(i) > 90) {
                    result += String.fromCharCode(value[i] + 'a'.charCodeAt(0));
                } else {
                    result += String.fromCharCode(value[i] + 'A'.charCodeAt(0));
                }
            }
            return result;
        },

        /**
         * Returns text for sequential number - switcher
         * @memberof DPO.model.Selector#
         * @param indexSerialNum - current serialNum (number of panel)
         * @param serialNumber - field
         * @return {string}
         */
        getTextForSerialNumber: function getTextForSerialNumber(indexSerialNum, serialNumber) {
            switch (serialNumber.serialNumberType) {
                case 'Numeric Serial Number' :
                    return this.generateNumericalNumber(indexSerialNum, serialNumber);
                case 'Alphabetic Serial Number'  :
                    return this.generateAlphabeticalNumber(indexSerialNum, serialNumber);
                default :
                    return '';
            }
        },

        /**
         * Convert String to base-26 number system (a-0 ... z-25).
         * @memberof DPO.model.Selector#
         * @param {string} value - number in string format
         * @return {number[]}
         */
        convertStringToBase26: function convertStringToBase26(value) {
            var result = [];
            for (var i = 0; i < value.length; i++) {
                result.push(value.charAt(i).toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0));
            }
            return result;
        },

        /**
         * Returns panel index
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} panel
         * @returns {number}
         */
        panelIndex: function panelIndex(panel) {
            this.collectData();
            var indexes = this.cache.panelIndexes[panel.master];
            return indexes.indexOf(panel);
        },

        /**
         * Returns panel index from page
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} panel
         * @param {DPO.model.Page} page
         * @returns {number}
         */
        getPanelPositionOnPage: function getPanelPositionOnPage(panel, page) {
            var panels = page.panels;
            for (var i = 0; i < panels.length; i++) {
                var curPanel = panels[i];
                if (panel === curPanel) {
                    return i;
                }
            }
            return -1;
        },

        /**
         * Check if fields belong to master panel(s)
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Field[]} fields
         * @param {DPO.model.MasterPanel} [masterPanel]
         * @returns {object[]}
         */
        belongToMasterPanel: function belongToMasterPanel(fields, masterPanel) {
            var me = this;
            me.collectData();

            var masters = [],
                result = [],
                field, index, i, j;
            if (masterPanel) {
                masters.push(masterPanel.id);
            } else {
                masters = Object.keys(me.cache.masterMap);
            }

            for (i = 0; i < masters.length; i++) {
                var master = masters[i],
                    panel = me.cache.masterMap[master],
                    array = [].concat(
                        panel.images,
                        panel.barcodes,
                        panel.drawings,
                        panel.textBlocks,
                        panel.textPaths,
                        panel.textLines,
                        panel.backgrounds
                    );

                for (j = 0; j < fields.length; j++) {
                    field = fields[j];
                    index = array.indexOf(field);
                    if (index !== -1) {
                        result.push({
                            masterPanel: panel,
                            field: field
                        });
                    }
                }
            }

            return result;
        },

        /**
         * Selects panels rectangle is page coordinate system
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Page} page
         * @returns {DPO.math.Rect[]}
         */
        selectPanelsRectangles: function selectPanelsRectangles(page) {
            var panels = page.panels,
                result = [];
            for (var i = 0; i < panels.length; i++) {
                var panel = panels[i],
                    mp = this.selectMasterPanel(panel),
                    x1 = panel.position.x,
                    y1 = panel.position.y,
                    x2 = x1 + mp.width,
                    y2 = y1 + mp.height,
                    m = (new DPO.math.Matrix()).rotate(360 - panel.rotation, x1, y1),
                    xs = [m.x(x1, y1), m.x(x2, y1), m.x(x2, y2), m.x(x1, y2)],
                    ys = [m.y(x1, y1), m.y(x2, y1), m.y(x2, y2), m.y(x1, y2)];
                x1 = Math.min.apply(Math, xs);
                y1 = Math.min.apply(Math, ys);
                x2 = Math.max.apply(Math, xs);
                y2 = Math.max.apply(Math, ys);
                result.push(new DPO.math.Rect(x1, y1, x2, y2));
            }

            return result;
        },

        /**
         * Checks if rectangle inside background area
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel} panel
         * @param {DPO.math.Rect} rect
         * @returns {boolean}
         */
        insideBackgroundArea: function insideBackgroundArea(panel, rect) {
            var master = this.selectMasterPanel(panel),
                d = master.bleed ? 90 : -90,
                w = master.width + 2 * d,
                h = master.height + 2 * d,
                r = new DPO.math.Rect(-d, -d, d + 2 * w, d + 2 * h),
                inside = true;
            inside = inside && rect.x1 >= r.x1;
            inside = inside && rect.y1 >= r.y1;
            inside = inside && rect.x2 <= r.x2;
            inside = inside && rect.y2 <= r.y2;
            return inside;
        },

        /**
         * Selects all backgrounds for specified panel
         * @memberof DPO.model.Selector#
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {boolean} [includeSolid]
         * @returns {DPO.model.Background[]}
         */
        selectBackgrounds: function selectBackgrounds(panel, includeSolid) {
            var me = this,
                backgrounds = [],
                mp = me.selectMasterPanel(panel),
                panels = [panel], i, j, bg, p;
            if (panel instanceof DPO.model.MasterPanel) {
                panels = me.selectChildPanels(mp);

                for (i = 0; i < mp.backgrounds.length; i++) {
                    bg = mp.backgrounds[i];
                    if (bg.source || includeSolid) {
                        backgrounds.push(bg);
                    }
                }
            }

            for (i = 0; i < panels.length; i++) {
                p = panels[i];
                for (j = 0; j < p.backgrounds.length; j++) {
                    bg = p.backgrounds[j];
                    if (bg.source || includeSolid) {
                        backgrounds.push(bg);
                    }
                }
            }
            return backgrounds;
        }
    });

    return Selector;
});
DPO.def('model.Deserializer', function () {
    /**
     * @class DPO.model.Deserializer
     * @memberof DPO.model
     * @extends DPO.xml.Deserializer
     * @param {class} cls
     * @param {object} cfg
     * @constructor
     */
    function Deserializer(cls, cfg) {
        DPO.xml.Deserializer.apply(this, arguments);
        this.introspector = new DPO.model.Introspector(cfg);
    }

    DPO.inherit(Deserializer, DPO.xml.Deserializer);
    return Deserializer;
});
DPO.def('model.Serializer', function() {
    /**
     * @class DPO.model.Serializer
     * @memberof DPO.model
     * @extends DPO.xml.Serializer
     * @property {DPO.model.Introspector} introspector
     * @param {object} cfg
     * @constructor
     */
    function Serializer(cfg) {
        cfg = cfg || {};
        DPO.xml.Serializer.apply(this, arguments);
        this.normalizeDefaultsValues = !!cfg.normalizeDefaultsValues;
        this.introspector = new DPO.model.Introspector(cfg);
    }

    DPO.inherit(Serializer, DPO.xml.Serializer);
    DPO.mixin(Serializer.prototype, {
        /**
         * Serializes whole model to XML format
         * @memberof DPO.model.Serializer#
         * @param {DPO.xml.Model} model
         * @param {?string} [ns]
         * @param {string} [root]
         * @returns {string}
         */
        serializeToXML: function serializeToXML(model, ns, root) {
            ns = ns == null ? 'http://print.avery.com' : ns;
            root = root || 'avery:project';

            var xml = DPO.xml.Serializer.prototype.serializeToXML.call(this, model, ns, root);
            if (xml.indexOf('xmlns:avery="http://print.avery.com"') == -1) {
                xml = xml.replace('<avery:project ', '<avery:project xmlns:avery="http://print.avery.com" ');
            }
            return xml;
        }
    });
    return Serializer;
});
DPO.def('text.FontMetrics', function () {
    // Metrics array
    // 0 - Font file name
    // 1 - Units Per Em
    // 2 - Ascender
    // 3 - Descender
    // 4 - Cap Height
    var allMetrics = {
        'DPO8Fallback': {
            'Regular': ['dpo8-fallback.ttf', 2048, 2189, -555, 1466, 1061]
        },
        'Amatic SC': {
            'Regular': ['AmaticSC-Regular.ttf', 2048, 2081, -501, 1581, 1361],
            'Bold': ['AmaticSC-Bold.ttf', 2048, 2081, -501, 1588, 1353]
        },
        'Andy': {
            'Regular': ['andy.ttf', 2048, 1769, -692, 1433, 999]
            // 'Bold': ['andyb.ttf', 2048, 1769, -692, 1433, 999],
            // 'Italic': ['andyi.ttf', 2048, 1769, -692, 1433, 999],
            // 'Bold Italic': ['andybi.ttf', 2048, 1769, -692, 1433, 999]
        },
        'Anonymous Pro': {
            'Regular': ['AnonymousPro-Regular.ttf', 2048, 1675, -373, 1305, 932],
            'Bold': ['AnonymousPro-Bold.ttf', 2048, 1675, -373, 1305, 932],
            'Italic': ['AnonymousPro-Italic.ttf', 2048, 1675, -373, 1305, 932],
            'Bold Italic': ['AnonymousPro-BoldItalic.ttf', 2048, 1675, -373, 1305, 932]
        },
        'Arial': {
            'Bold': ['arialbd.ttf', 2048, 1854, -434, 1466, 1062],
            'Italic': ['ariali.ttf', 2048, 1854, -434, 1466, 1062],
            'Bold Italic': ['arialbi.ttf', 2048, 1854, -434, 1466, 1062],
            'Regular': ['ariad.ttf', 2048, 1854, -434, 1466, 1062]
        },
        // 'Arimo': {
        //     'Regular': ['Arimo-Regular.ttf', 2048, 1854, -434, 1409, 1082],
        //     'Bold': ['Arimo-Bold.ttf', 2048, 1854, -434, 1409, 1082],
        //     'Italic': ['Arimo-Italic.ttf', 2048, 1854, -434, 1409, 1082],
        //     'Bold Italic': ['Arimo-BoldItalic.ttf', 2048, 1854, -434, 1409, 1082]
        // },
        'Arvo': {
            'Regular': ['Arvo-Regular.ttf', 2048, 1968, -506, 1516, 1036],
            'Bold': ['Arvo-Bold.ttf', 2048, 1968, -506, 1516, 1036],
            'Italic': ['Arvo-Italic.ttf', 2048, 1968, -506, 1516, 1036],
            'Bold Italic': ['Arvo-BoldItalic.ttf', 2048, 1968, -506, 1516, 1036]
        },
        'Ascender Sans': {
            'Regular': ['ascsan.ttf', 2048, 1854, -434, 1409, 1082],
            'Bold': ['ascsanb.ttf', 2048, 1854, -434, 1409, 1082],
            'Italic': ['ascsani.ttf', 2048, 1854, -434, 1409, 1082],
            'Bold Italic': ['ascsanbi.ttf', 2048, 1854, -434, 1409, 1082]
        },
        'Ascender Serif': {
            'Regular': ['ascser.ttf', 2048, 1825, -443, 1341, 940],
            'Bold': ['ascserb.ttf', 2048, 1825, -443, 1341, 940],
            'Italic': ['ascseri.ttf', 2048, 1825, -443, 1341, 940],
            'Bold Italic': ['ascserbi.ttf', 2048, 1825, -443, 1341, 940]
        },
        'Ashley Crawford': {
            'Regular': ['ashleycrawford.ttf', 2048, 2226, -555, 1491, 1554]
            // 'Bold': ['ashleycrawfordb.ttf', 2048, 2226, -555, 1491, 1554],
            // 'Italic': ['ashleycrawfordi.ttf', 2048, 2226, -555, 1491, 1554],
            // 'Bold Italic': ['ashleycrawfordbi.ttf', 2048, 2226, -555, 1491, 1554]
        },
        'Bella Donna': {
            'Regular': ['bella donna.ttf', 1000, 864, -322, 755, 266]
        },
        'Bernhard Fashion Com': {
            'Regular': ['bernhardfashioncom.ttf', 1000, 973, -168, 841, 279]
        },
        'BodoniAnt': {
            'Regular': ['b044003t.ttf', 2048, 1911, -546, 1365, 806]
        },
        'BRADDON': {
            'Regular': ['braddon_.ttf', 1000, 917, -252, 714, 447],
            'Bold': ['braddb__.ttf', 1000, 917, -262, 734, 466],
            'Italic': ['braddi__.ttf', 1000, 907, -251, 714, 447],
            'Bold Italic': ['braddbi_.ttf', 1000, 917, -262, 734, 466]
        },
        'BRODY': {
            'Regular': ['brody___.ttf', 1000, 940, -252, 709, 568],
            'Bold': ['brodyb__.ttf', 1000, 950, -262, 729, 594],
            'Italic': ['brodyi__.ttf', 1000, 940, -252, 709, 568],
            'Bold Italic': ['brodybi_.ttf', 1000, 950, -262, 729, 594]
        },
        'Bubblegum Sans': {
            'Regular': ['BubblegumSans-Regular.ttf', 1000, 852, -311, 720, 537]
        },
        'Butcherman': {
            'Regular': ['Butcherman-Regular.ttf', 2048, 1700, -363, 1922, 1631]
        },
        'CAMPBELL': {
            'Regular': ['campbell.ttf', 1000, 939, -251, 667, 560],
            'Bold': ['campbb__.ttf', 1000, 949, -261, 686, 579],
            'Italic': ['campbi__.ttf', 1000, 939, -251, 667, 560],
            'Bold Italic': ['campbbi_.ttf', 1000, 949, -261, 686, 579]
        },
        'Chicory': {
            'Regular': ['chicory.ttf', 2048, 1702, -618, 1009, 846]
            // 'Bold': ['chicoryb.ttf', 2048, 1702, -618, 1009, 846],
            // 'Italic': ['chicoryi.ttf', 2048, 1702, -618, 1009, 846],
            // 'Bold Italic': ['chicorybi.ttf', 2048, 1702, -618, 1009, 846]
        },
        'Corsiva': {
            'Regular': ['corsiva.ttf', 2048, 1618, -621, 1368, 1225]
            // 'Bold': ['corsivab.ttf', 2048, 1618, -621, 1368, 1225],
            // 'Italic': ['corsivai.ttf', 2048, 1618, -621, 1368, 1225],
            // 'Bold Italic': ['corsivabi.ttf', 2048, 1618, -621, 1368, 1225]
        },
        // 'Cousine': {
        //     'Regular': ['Cousine-Regular.ttf', 2048, 1705, -615, 1349, 1082],
        //     'Bold': ['Cousine-Bold.ttf', 2048, 1705, -615, 1349, 1082],
        //     'Italic': ['Cousine-Italic.ttf', 2048, 1705, -615, 1349, 1082],
        //     'Bold Italic': ['Cousine-BoldItalic.ttf', 2048, 1705, -615, 1349, 1082]
        // },
        'Crafty Girls': {
            'Regular': ['CraftyGirls.ttf', 1024, 1001, -461, 859, 592]
        },
        'Creepster': {
            'Regular': ['Creepster-Regular.ttf', 1024, 974, -223, 786, 771]
        },
        'Cuprum': {
            'Regular': ['Cuprum-Regular.ttf', 1000, 890, -260, 700, 500],
            'Bold': ['Cuprum-Bold.ttf', 1000, 895, -260, 700, 500],
            'Italic': ['Cuprum-Italic.ttf', 1000, 895, -260, 700, 500],
            'Bold Italic': ['Cuprum-BoldItalic.ttf', 1000, 895, -260, 700, 500]
        },
        'Dorchester Script': {
            'Regular': ['dorch.ttf', 2048, 1870, -676, 1214, 545]
            // 'Bold': ['dorchb.ttf', 2048, 1870, -676, 1214, 545],
            // 'Italic': ['dorchi.ttf', 2048, 1870, -676, 1214, 545],
            // 'Bold Italic': ['dorchbi.ttf', 2048, 1870, -676, 1214, 545]
        },
        'Endurance Pro': {
            'Regular': ['endurancepro.ttf', 2048, 2169, -541, 1409, 1022],
            'Bold': ['endurancepro-bold.ttf', 2048, 2169, -541, 1409, 1034],
            'Italic': ['endurancepro-italic.ttf', 2048, 2169, -541, 1409, 1022],
            'Bold Italic': ['endurancepro-bolditalic.ttf', 2048, 2169, -541, 1409, 1034]
        },
        'Endurance Pro Light': {
            'Regular': ['endurancepro-light.ttf', 2048, 2089, -457, 1409, 1014],
            'Italic': ['endurancepro-lightitalic.ttf', 2048, 2089, -457, 1409, 1014]
        },
        'Endurance Pro Black': {
            'Regular': ['endurancepro-black.ttf', 2048, 2204, -578, 1409, 1044],
            'Italic': ['endurancepro-blackitalic.ttf', 2048, 2204, -578, 1409, 1044]
        },
        'Falstaff': {
            'Regular': ['falstaff_.ttf', 2048, 1950, -512, 1489, 983]
            // 'Bold': ['falstaffb.ttf', 2048, 1950, -512, 1489, 983],
            // 'Italic': ['falstaffi.ttf', 2048, 1950, -512, 1489, 983],
            // 'Bold Italic': ['falstaffbi.ttf', 2048, 1950, -512, 1489, 983]
        },
        'Falstaff Festival': {
            'Regular': ['falstafffestival.ttf', 2048, 1930, -410, 1490, 1490]
            // 'Bold': ['falstafffestivalb.ttf', 2048, 1930, -410, 1490, 1490],
            // 'Italic': ['falstafffestivali.ttf', 2048, 1930, -410, 1490, 1490],
            // 'Bold Italic': ['falstafffestivalbi.ttf', 2048, 1930, -410, 1490, 1490]
        },
        'FELTPOINT': {
            'Regular': ['feltp___.ttf', 1000, 1061, -321, 795, 487],
            'Bold': ['feltpb__.ttf', 1000, 1071, -331, 815, 507],
            'Italic': ['feltpi__.ttf', 1000, 1061, -321, 795, 487],
            'Bold Italic': ['feltpbi_.ttf', 1000, 1071, -331, 815, 507]
        },
        'Finger Paint': {
            'Regular': ['FingerPaint-Regular.ttf', 1000, 1097, -377, 787, 602]
        },
        'FIRSTHOME': {
            'Regular': ['first___.ttf', 1000, 917, -202, 675, 500],
            'Bold': ['firstb__.ttf', 1000, 920, -212, 694, 519],
            'Italic': ['firsti__.ttf', 1000, 917, -202, 675, 500],
            'Bold Italic': ['firstbi_.ttf', 1000, 920, -212, 694, 519]
        },
        'Garamond': {
            'Regular': ['gara.ttf', 2048, 1765, -539, 1308, 790],
            'Bold': ['garabd.ttf', 2048, 1765, -539, 1301, 816],
            'Italic': ['garait.ttf', 2048, 1765, -539, 1323, 835],
            'Bold Italic': ['garabit.ttf', 2048, 1765, -539, 1323, 835]
        },
        'Gasoline Alley NF': {
            'Regular': ['gasolinealleynf.ttf', 1000, 817, -355, 611, 427]
        },
        'GENUINE': {
            'Regular': ['genuine_.ttf', 1000, 937, -250, 714, 586],
            'Bold': ['genuib__.ttf', 1000, 947, -260, 734, 606],
            'Italic': ['genuii__.ttf', 1000, 937, -250, 714, 586],
            'Bold Italic': ['genuibi_.ttf', 1000, 947, -260, 734, 606]
        },
        'Georgia': {
            'Regular': ['georgia.ttf', 2048, 1878, -449, 1419, 986],
            'Bold': ['georgiab.ttf', 2048, 1878, -449, 1419, 992],
            'Italic': ['georgiai.ttf', 2048, 1878, -449, 1419, 1020],
            'Bold Italic': ['georgiaz.ttf', 2048, 1878, -449, 1419, 1042]
        },
        'Gill Sans': {
            'Regular': ['gil_____.ttf', 2048, 2143, -677, 1397, 920],
            'Bold': ['gilb____.ttf', 2048, 2143, -677, 1397, 944],
            'Italic': ['gili____.ttf', 2048, 2143, -677, 1397, 920],
            'Bold Italic': ['gilbi___.ttf', 2048, 2143, -677, 1397, 930]
        },
        'Gill Sans Alt One': {
            'Regular': ['gila____.ttf', 2048, 2143, -677, 1397, 920],
            'Bold': ['gilab___.ttf', 2048, 2143, -677, 1397, 944],
            'Italic': ['gilai___.ttf', 2048, 2143, -677, 1397, 920],
            'Bold Italic': ['gilabi__.ttf', 2048, 2143, -677, 1397, 930]
        },
        'Gill Sans Alt One Light': {
            'Regular': ['gilal___.ttf', 2048, 2143, -677, 1397, 920],
            'Italic': ['gilali__.ttf', 2048, 2143, -677, 1397, 920]
        },
        'Graduate': {
            'Regular': ['Graduate-Regular.ttf', 1000, 953, -186, 750, 650]
        },
        'HANA': {
            'Regular': ['hana____.ttf', 1000, 873, -207, 667, 547],
            'Bold': ['hanab___.ttf', 1000, 883, -217, 687, 567],
            'Italic': ['hanai___.ttf', 1000, 873, -207, 667, 547],
            'Bold Italic': ['hanabi__.ttf', 1000, 883, -217, 687, 567]
        },
        'HelveticaNeue': {
            'Regular': ['helveticaneue.ttf', 1000, 714, -286, 714, 517],
            'Bold': ['helveticaneue bold.ttf', 1000, 714, -286, 714, 517],
            'Italic': ['helveticaneue italic.ttf', 1000, 714, -286, 714, 517],
            'Bold Italic': ['helveticaneue bold italic.ttf', 1000, 714, -286, 714, 517]
        },
        'Helvetica LT Pro': {
            'Regular': ['helveticaltpro-roman.ttf', 2048, 1970, -541, 1470, 1071],
            'Bold': ['helveticaltpro-bold.ttf', 2048, 1970, -541, 1470, 1090]
        },
        'Helvetica LT CYR': {
            'Italic': ['helveticaltcyr-italic.ttf', 1000, 718, -212, 718, 523],
            'Bold Italic': ['helveticaltcyr-bolditalic.ttf', 1000, 718, -212, 718, 532]
        },
        'HogarthScrD': {
            'Regular': ['h008000d.ttf', 2048, 1888, -569, 1969, 656]
        },
        'Homemade Apple': {
            'Regular': ['HomemadeApple.ttf', 1024, 1327, -666, 1042, 843]
        },
        'HUNTSON': {
            'Regular': ['huntson_.ttf', 1000, 951, -257, 752, 237],
            'Bold': ['huntsb__.ttf', 1000, 961, -267, 771, 257],
            'Italic': ['huntsi__.ttf', 1000, 951, -257, 752, 237],
            'Bold Italic': ['huntsbi_.ttf', 1000, 961, -267, 771, 257]
        },
        'Inlove': {
            'Regular': ['inlove light.ttf', 1000, 721, -234, 721, 487],
            'Bold': ['inlove bold.ttf', 1000, 750, -250, 719, 483]
        },
        'IRIS': {
            'Regular': ['iris____.ttf', 1000, 863, -337, 705, 352],
            'Bold': ['irisb___.ttf', 1000, 879, -347, 725, 372],
            'Italic': ['irisi___.ttf', 1000, 863, -337, 705, 352],
            'Bold Italic': ['irisbi__.ttf', 1000, 879, -347, 725, 372]
        },
        'JACKIE': {
            'Regular': ['jackie__.ttf', 1000, 937, -263, 677, 473],
            'Bold': ['jackib__.ttf', 1000, 947, -273, 697, 493],
            'Italic': ['jackii__.ttf', 1000, 937, -263, 677, 473],
            'Bold Italic': ['jackibi_.ttf', 1000, 947, -273, 697, 493]
        },
        'Julius Sans One': {
            'Regular': ['JuliusSansOne-Regular.ttf', 1000, 863, -228, 715, 649]
        },
        'KENDRIC': {
            'Regular': ['kendric_.ttf', 1000, 913, -300, 896, 474],
            'Bold': ['kendrb__.ttf', 1000, 923, -310, 916, 498],
            'Italic': ['kendri__.ttf', 1000, 913, -300, 896, 474],
            'Bold Italic': ['kendrbi_.ttf', 1000, 923, -310, 916, 498]
        },
        'Lakki Reddy': {
            'Regular': ['LakkiReddy-Regular.ttf', 1024, 938, -365, 705, 516]
        },
        'LIVINGWELL': {
            'Regular': ['livin___.ttf', 1000, 1006, -235, 771, 556],
            'Bold': ['livinb__.ttf', 1000, 1020, -245, 791, 576],
            'Italic': ['livini__.ttf', 1000, 1006, -235, 771, 556],
            'Bold Italic': ['livinbi_.ttf', 1000, 1020, -245, 791, 576]
        },
        'Lobster Two': {
            'Regular': ['LobsterTwo-Regular.ttf', 1000, 1000, -250, 750, 566],
            'Bold': ['LobsterTwo-Bold.ttf', 1000, 1000, -250, 750, 570],
            'Italic': ['LobsterTwo-Italic.ttf', 1000, 1000, -250, 750, 563],
            'Bold Italic': ['LobsterTwo-BoldItalic.ttf', 1000, 1000, -250, 750, 563]
        },
        'Lora': {
            'Regular': ['Lora-Regular.ttf', 2048, 1934, -551, 1434, 1024],
            'Bold': ['Lora-Bold.ttf', 2048, 2061, -563, 1434, 1024],
            'Italic': ['Lora-Italic.ttf', 2048, 1968, -556, 1434, 1070],
            'Bold Italic': ['Lora-BoldItalic.ttf', 2048, 2116, -563, 1434, 1070]
        },
        'Loved by the King': {
            'Regular': ['LovedbytheKing.ttf', 2048, 1898, -837, 1796, 1685]
        },
        'LuedickitalD': {
            'Regular': ['l044003d.ttf', 2048, 1536, -512, 1403, 1036],
            'Bold': ['l044006d.ttf', 2048, 1536, -512, 1444, 1076]
        },
        'LuedickitalD Light': {
            'Regular': ['l044002d.ttf', 2048, 1536, -512, 1362, 996]
        },
        'Luckiest Guy': {
            'Regular': ['LuckiestGuy.ttf', 2048, 1440, -608, 1462, 1416]
        },
        'LYNN': {
            'Regular': ['lynn____.ttf', 1000, 896, -223, 662, 448],
            'Bold': ['lynnb___.ttf', 1000, 906, -233, 681, 467],
            'Italic': ['lynni___.ttf', 1000, 896, -223, 662, 448],
            'Bold Italic': ['lynnbi__.ttf', 1000, 906, -233, 681, 467]
        },
        'MAXIMO': {
            'Regular': ['maximo__.ttf', 1000, 953, -257, 700, 385],
            'Bold': ['maximb__.ttf', 1000, 1024, -267, 720, 405],
            'Italic': ['maximi__.ttf', 1000, 974, -257, 700, 385],
            'Bold Italic': ['maximbi_.ttf', 1000, 1022, -267, 720, 405]
        },
        'MetaPro-Normal': {
            'Regular': ['metapro.ttf', 1000, 980, -349, 686, 498]
        },
        'Neographik': {
            'Regular': ['neo_____.ttf', 2048, 2044, -784, 1575, 1257],
            'Bold': ['neob.ttf', 2048, 2044, -784, 1575, 1257],
            'Italic': ['neoi.ttf', 2048, 2044, -784, 1575, 1257],
            'Bold Italic': ['neobi.ttf', 2048, 2044, -784, 1575, 1257]
        },
        'Noto Sans': {
            'Regular': ['NotoSans-Regular.ttf', 2048, 2189, -600, 1462, 1098],
            'Bold': ['NotoSans-Bold.ttf', 2048, 2189, -600, 1462, 1118],
            'Italic': ['NotoSans-Italic.ttf', 2048, 2189, -600, 1462, 1098],
            'Bold Italic': ['NotoSans-BoldItalic.ttf', 2048, 2189, -600, 1462, 1118]
        },
        'Noto Serif': {
            'Regular': ['NotoSerif-Regular.ttf', 2048, 2189, -600, 1462, 1098],
            'Bold': ['NotoSerif-Bold.ttf', 2048, 2189, -600, 1462, 1098],
            'Italic': ['NotoSerif-Italic.ttf', 2048, 2189, -600, 1462, 1098],
            'Bold Italic': ['NotoSerif-BoldItalic.ttf', 2048, 2189, -600, 1462, 1098]
        },
        'Nunito': {
            'Regular': ['Nunito-Regular.ttf', 2048, 2030, -675, 1434, 1001],
            'Bold': ['Nunito-Bold.ttf', 2048, 2071, -723, 1453, 1001]
            // 'Light': ['Nunito-Light.ttf', 2048, 1992, -632, 1426, 991]
        },
        'OLIVEOIL': {
            'Regular': ['oliveoil.ttf', 1000, 1022, -304, 777, 511],
            'Bold': ['oliveb__.ttf', 1000, 1032, -324, 799, 547],
            'Italic': ['olivei__.ttf', 1000, 1022, -304, 779, 522],
            'Bold Italic': ['olivebi_.ttf', 1000, 1032, -324, 803, 560]
        },
        'Open Sans': {
            'Regular': ['OpenSans-Regular.ttf', 2048, 2189, -600, 1462, 1096],
            'Bold': ['OpenSans-Bold.ttf', 2048, 2189, -600, 1462, 1118],
            'Italic': ['OpenSans-Italic.ttf', 2048, 2189, -600, 1462, 1096],
            'Bold Italic': ['OpenSans-BoldItalic.ttf', 2048, 2189, -600, 1462, 1118]
        },
        'Pacifico': {
            'Regular': ['Pacifico.ttf', 2048, 2668, -928, 1888, 896]
        },
        'Patrick Hand': {
            'Regular': ['PatrickHand-Regular.ttf', 1000, 1042, -312, 666, 469]
        },
        'Playfair Display': {
            'Regular': ['PlayfairDisplay-Regular.ttf', 2048, 2216, -514, 1450, 1055],
            'Bold': ['PlayfairDisplay-Bold.ttf', 2048, 2216, -514, 1450, 1059],
            'Italic': ['PlayfairDisplay-Italic.ttf', 2048, 2216, -514, 1450, 1110],
            'Bold Italic': ['PlayfairDisplay-BoldItalic.ttf', 2048, 2216, -514, 1450, 1116]
        },
        'Poiret One': {
            'Regular': ['PoiretOne-Regular.ttf', 1000, 962, -208, 750, 450]
        },
        'Princess Sofia': {
            'Regular': ['PrincessSofia-Regular.ttf', 1024, 1010, -574, 1108, 487]
        },
        'PT Sans': {
            'Regular': ['PT_Sans-Web-Regular.ttf', 1000, 1018, -276, 700, 500],
            'Bold': ['PT_Sans-Web-Bold.ttf', 1000, 1018, -276, 700, 500],
            'Italic': ['PT_Sans-Web-Italic.ttf', 1000, 1018, -276, 700, 500],
            'Bold Italic': ['PT_Sans-Web-BoldItalic.ttf', 1000, 1018, -276, 700, 500]
        },
        'PT Serif': {
            'Regular': ['PT_Serif-Web-Regular.ttf', 1000, 1039, -286, 700, 500],
            'Bold': ['PT_Serif-Web-Bold.ttf', 1000, 1039, -286, 700, 500],
            'Italic': ['PT_Serif-Web-Italic.ttf', 1000, 1039, -286, 700, 513],
            'Bold Italic': ['PT_Serif-Web-BoldItalic.ttf', 1000, 1039, -286, 700, 518]
        },
        'Raleway': {
            'Regular': ['Raleway-Regular.ttf', 1000, 940, -234, 710, 521],
            'Bold': ['Raleway-Bold.ttf', 1000, 940, -234, 710, 524]
        },
        'Report Rg': {
            'Regular': ['report rg.ttf', 1000, 700, -300, 703, 475],
            'Bold': ['report bd.ttf', 1000, 700, -300, 703, 475]
        },
        'Roboto': {
            'Regular': ['Roboto-Regular.ttf', 2048, 2146, -555, 1456, 1082],
            'Bold': ['Roboto-Bold.ttf', 2048, 2146, -555, 1456, 1082],
            'Italic': ['Roboto-Italic.ttf', 2048, 2146, -555, 1456, 1082],
            'Bold Italic': ['Roboto-BoldItalic.ttf', 2048, 2146, -555, 1456, 1082]
        },
        'Sacramento': {
            'Regular': ['Sacramento-Regular.ttf', 2048, 1905, -1084, 1594, 674]
        },
        'Scada': {
            'Regular': ['Scada-Regular.ttf', 1000, 955, -289, 700, 500],
            'Bold': ['Scada-Bold.ttf', 1000, 955, -289, 700, 500],
            'Italic': ['Scada-Italic.ttf', 1000, 955, -289, 700, 500],
            'Bold Italic': ['Scada-BoldItalic.ttf', 1000, 955, -289, 700, 500]
        },
        'Scripts': {
            'Regular': ['scripts.ttf', 2048, 1950, -516, 1450, 873]
            // 'Bold': ['scriptsb.ttf', 2048, 1950, -516, 1450, 873],
            // 'Italic': ['scriptsi.ttf', 2048, 1950, -516, 1450, 873],
            // 'Bold Italic': ['scriptsbi.ttf', 2048, 1950, -516, 1450, 873]
        },
        'Segoe Print': {
            'Regular': ['segoepr.ttf', 2048, 2555, -1014, 1603, 1234],
            'Bold': ['segoeprb.ttf', 2048, 2555, -1014, 1596, 1245]
        },
        'SimSun': {
            'Regular': ['simsun.ttf', 256, 220, -36, 171, 112]
        },
        'Shadows Into Light Two': {
            'Regular': ['ShadowsIntoLightTwo-Regular.ttf', 1024, 1145, -341, 859, 610]
        },
        'Slate Std Bk': {
            'Regular': ['slatestd-bk.ttf', 1000, 655, -345, 635, 458],
            'Bold': ['slatestd-bkbold.ttf', 1000, 654, -346, 635, 475],
            'Italic': ['slatestd-bkitalic.ttf', 1000, 655, -345, 635, 459]
        },
        'Special Elite': {
            'Regular': ['SpecialElite.ttf', 2048, 1440, -608, 1451, 1065]
        },
        'Sue Ellen Francisco': {
            'Regular': ['SueEllenFrancisco.ttf', 1024, 1062, -434, 1014, 453]
        },
        'Tangerine': {
            'Regular': ['Tangerine_Regular.ttf', 1000, 750, -250, 644, 256],
            'Bold': ['Tangerine_Bold.ttf', 1000, 750, -250, 644, 256]
        },
        'Tinos': {
            'Regular': ['Tinos-Regular.ttf', 2048, 1825, -443, 1341, 940],
            'Bold': ['Tinos-Bold.ttf', 2048, 1825, -443, 1341, 940],
            'Italic': ['Tinos-Italic.ttf', 2048, 1825, -443, 1341, 940],
            'Bold Italic': ['Tinos-BoldItalic.ttf', 2048, 1825, -443, 1341, 940]
        },
        'Times New Roman': {
            'Regular': ['times.ttf', 2048, 1825, -443, 1356, 916],
            'Bold': ['timesbd.ttf', 2048, 1825, -443, 1356, 935],
            'Italic': ['timesi.ttf', 2048, 1825, -443, 1356, 929],
            'Bold Italic': ['timesbi.ttf', 2048, 1825, -443, 1356, 955]
        },
        'Ubuntu': {
            'Regular': ['Ubuntu-Regular.ttf', 1000, 932, -189, 693, 520],
            'Bold': ['Ubuntu-Bold.ttf', 1000, 932, -189, 693, 526],
            'Italic': ['Ubuntu-Italic.ttf', 1000, 932, -189, 693, 520],
            'Bold Italic': ['Ubuntu-BoldItalic.ttf', 1000, 932, -189, 693, 526]
        },
        'Ubuntu Mono': {
            'Regular': ['UbuntuMono-Regular.ttf', 1000, 830, -170, 619, 464],
            'Bold': ['UbuntuMono-Bold.ttf', 1000, 830, -170, 619, 470],
            'Italic': ['UbuntuMono-Italic.ttf', 1000, 830, -170, 619, 464],
            'Bold Italic': ['UbuntuMono-BoldItalic.ttf', 1000, 830, -170, 619, 470]
        },
        'UnifrakturMaguntia': {
            'Regular': ['UnifrakturMaguntia-Book.ttf', 2048, 1607, -513, 1866, 1501]
        },
        'Verdana': {
            'Regular': ['verdana.ttf', 2048, 2059, -430, 1489, 1117],
            'Bold': ['verdana-bold.ttf', 2048, 2059, -430, 1489, 1123],
            'Italic': ['verdana-italic.ttf', 2048, 2059, -430, 1489, 1117],
            'Bold Italic': ['verdana-bolditalic.ttf', 2048, 2059, -430, 1489, 1123]
        },
        'Waiting for the Sunrise': {
            'Regular': ['WaitingfortheSunrise.ttf', 1024, 946, -447, 711, 554]
        },
        'Graphik': {
            'Regular': ['Graphik-LCG-TT-Regular.ttf', 1000, 818, -182, 715, 523],
            'Italic': ['Graphik-LCG-TT-Italic.ttf', 1000, 818, -182, 715, 523],
            'Bold Italic': ['Graphik-LCG-TT-BoldItalic.ttf', 1000, 818, -182, 715, 523],
            'Bold': ['Graphik-LCG-TT-Bold.ttf', 1000, 818, -182, 715, 523]
        }
    };

    /**
     * Creates a new font metrics object.
     * @class DPO.text.FontMetrics
     * @memberof DPO.text
     * @param {object} metrics
     * @param {object} [fallbackFontFamily]
     * @property {object} fallbackFontFamily
     * @property {object} metrics
     * @property {string[]} names
     * @constructor
     */
    function FontMetrics(metrics, fallbackFontFamily) {
        var me = this;
        me.metrics = metrics;
        me.names = Object.keys(metrics).sort();
        me.fallbackFontFamily = fallbackFontFamily || allMetrics.DPO8Fallback;
        me.fallbackFontFamilyName = 'Arial';

        if (fallbackFontFamily) {
            me.fallbackFontFamily = fallbackFontFamily;
            for (var i = 0; i < me.names.length; i++) {
                var name = me.names[i];
                if (me.metrics[name] === me.fallbackFontFamily) {
                    me.fallbackFontFamilyName = name;
                    break;
                }
            }
        } else {
            me.fallbackFontFamily = allMetrics.DPO8Fallback;
            me.fallbackFontFamilyName = 'Arial';
        }
    }

    DPO.mixin(FontMetrics.prototype, {
        /**
         * Returns font metrics
         * @param {*} metrics
         * @param {string} path
         * @returns {string}
         */
        getFontURL: function getFontURL(metrics, path) {
            return path + metrics[0];
        },

        /**
         * Calculates font ascender value for specified font size
         * @memberof DPO.text.FontMetrics#
         * @param {*} metrics
         * @param {number} fontSize
         * @returns {number}
         */
        getAscender: function getAscender(metrics, fontSize) {
            var unitsPerEm = metrics[1],
                ascender = metrics[2];
            return ascender / unitsPerEm * fontSize;
        },

        /**
         * Calculates font descender value for specified font size
         * @memberof DPO.text.FontMetrics#
         * @param {*} metrics
         * @param {number} fontSize
         * @returns {number}
         */
        getDescender: function getAscender(metrics, fontSize) {
            var unitsPerEm = metrics[1],
                descender = metrics[3];
            return descender / unitsPerEm * fontSize;
        },

        /**
         * Calculates font cap height value for specified font size
         * @memberof DPO.text.FontMetrics#
         * @param {*} metrics
         * @param {number} fontSize
         * @returns {number}
         */
        getCapHeight: function getCapHeight(metrics, fontSize) {
            var unitsPerEm = metrics[1],
                ascender = metrics[4];
            return ascender / unitsPerEm * fontSize;
        },

        /**
         * Returns font family metrics
         * @param {string} family
         * @returns {object}
         */
        getFontFamilyMetrics: function getFontFamilyMetrics(family) {
            return this.metrics[family];
        },

        /**
         * Returns subfamily name
         * @memberof DPO.text.FontMetrics#
         * @param {boolean} bold
         * @param {boolean} italic
         * @returns {string}
         */
        getSubfamilyName: function getSubfamilyName(bold, italic) {
            var subfamily = 'Regular';
            if (bold && italic) {
                subfamily = 'Bold Italic';
            } else if (bold) {
                subfamily = 'Bold';
            } else if (italic) {
                subfamily = 'Italic';
            }
            return subfamily;
        },

        /**
         * Returns font metrics for specified font family
         * @memberof DPO.text.FontMetrics#
         * @param {string} family
         * @param {boolean} bold
         * @param {boolean} italic
         * @returns {*}
         */
        getMetrics: function getMetrics(family, bold, italic) {
            var familyMetrics = this.getFontFamilyMetrics(family) || this.fallbackFontFamily,
                subfamily = this.getSubfamilyName(bold, italic);
            return familyMetrics[subfamily] || this.fallbackFontFamily.Regular;
        },

        /**
         * Returns font metrics for specified span
         * @memberof DPO.text.FontMetrics#
         * @param {DPO.model.Span} span
         * @returns {*}
         */
        getMetricsForSpan: function getMetricsForSpan(span) {
            return this.getMetrics(
                span.fontFamily,
                span.fontWeight === 'bold',
                span.fontStyle === 'italic'
            );
        },

        /**
         * Returns font styles intersection
         * @memberof DPO.text.FontMetrics#
         * @param {string[]} fontFamilies
         * @returns {string[]}
         */
        getFontsStylesIntersection: function getFontsStylesIntersection(fontFamilies) {
            if (!fontFamilies || !fontFamilies.length) {
                return [];
            }

            var styleSet = ['Regular', 'Bold', 'Italic', 'Bold Italic'];

            function removeFromSet(value) {
                var index = styleSet.indexOf(value);
                if (index !== -1) {
                    styleSet.splice(index, 1);
                }
            }

            for (var i = 0; i < fontFamilies.length; i++) {
                var family = fontFamilies[i],
                    metrics = this.metrics[family],
                    keys;
                if (!metrics) {
                    return [];
                }

                keys = Object.keys(metrics);
                if (keys.indexOf('Regular') === -1) {
                    removeFromSet('Regular');
                }
                if (keys.indexOf('Bold') === -1) {
                    removeFromSet('Bold');
                }
                if (keys.indexOf('Italic') === -1) {
                    removeFromSet('Italic');
                }
                if (keys.indexOf('Bold Italic') === -1) {
                    removeFromSet('Bold Italic');
                }
            }
            return styleSet;
        },

        /**
         * Returns required font styles settings
         * @param {string[]} styleSet
         * @returns {object}
         */
        getRequiredStyles: function getRequiredStyles(styleSet) {
            var index = 0,
                table = [
                    null,                                          // []
                    {fontStyle: 'normal', fontWeight: 'normal'}, // ['Regular']
                    {fontStyle: 'normal', fontWeight: 'bold'}, // ['Bold']
                    {fontStyle: 'normal', fontWeight: 'normal'}, // ['Regular', 'Bold']
                    {fontStyle: 'italic', fontWeight: 'normal'}, // ['Italic']
                    {fontStyle: 'normal', fontWeight: 'normal'}, // ['Regular', 'Italic']
                    {fontStyle: 'normal', fontWeight: 'bold'}, // ['Bold', 'Italic']
                    {fontStyle: 'normal', fontWeight: 'normal'}, // ['Regular', 'Bold', 'Italic']
                    {fontStyle: 'italic', fontWeight: 'bold'}, // ['Bold Italic']
                    {fontStyle: 'normal', fontWeight: 'normal'}, // ['Regular', 'Bold Italic']
                    {fontStyle: 'italic', fontWeight: 'bold'}, // ['Bold', 'Bold Italic']
                    {fontStyle: 'normal'}, // ['Regular', 'Bold', 'Bold Italic']
                    {fontStyle: 'italic', fontWeight: 'bold'}, // ['Italic', 'Bold Italic']
                    {fontWeight: 'normal'}, // ['Regular', 'Italic', 'Bold Italic']
                    {fontStyle: 'italic', fontWeight: 'bold'}, // ['Bold', 'Italic', 'Bold Italic']
                    {}                                             // ['Regular', 'Bold', 'Italic', 'Bold Italic']
                ];
            for (var i = 0; i < styleSet.length; i++) {
                switch (styleSet[i]) {
                    case 'Regular':
                        index |= 1;
                        break;
                    case 'Bold':
                        index |= 2;
                        break;
                    case 'Italic':
                        index |= 4;
                        break;
                    case 'Bold Italic':
                        index |= 8;
                        break;
                }
            }
            return table[index];
        },

        /**
         * Returns value of font family for CSS attribute
         * @memberof DPO.text.FontMetrics#
         * @param {string} family
         * @returns {string}
         */
        getCSSFontFamily: function getCSSFontFamily(family) {
            return '\'DPO8 ' + family + '\',' + this.fallbackFontFamilyName;
        },

        /**
         * Returns model font family from CSS font family
         * @param cssFontFamily
         * @returns {XML|string|*|void}
         */
        getModelFontFamily: function getModelFontFamily(cssFontFamily) {
            return cssFontFamily.match(/'DPO8\s+(.+)'/)[1];
        },

        /**
         * Defines custom fonts for specified HTML document
         * @memberof DPO.text.FontMetrics#
         * @param {Document} document
         * @param {string} path
         */
        defineFontFaces: function defineFontFaces(document, path) {
            if (document.getElementById('dpo8-font-faces')) {
                return;
            }

            var head = document.getElementsByTagName('head')[0],
                style = document.createElement('style'),
                css = '', metrics, name, faces, face;
            style.id = 'dpo8-font-faces';
            style.type = 'text/css';
            for (var i = 0; i < this.names.length; i++) {
                name = this.names[i];
                faces = Object.keys(this.metrics[name]);
                for (var j = 0; j < faces.length; j++) {
                    face = faces[j];
                    metrics = this.metrics[name][face];
                    css += '@font-face {';
                    css += '    font-family: "DPO8 ' + name + '";';
                    css += '    font-weight: ' + (face.indexOf('Bold') === -1 ? 'normal;' : 'bold;');
                    css += '    font-style: ' + (face.indexOf('Italic') === -1 ? 'normal;' : 'italic;');
                    css += '    src: url(\'' + path + metrics[0] + '\')format(\'truetype\');';
                    css += '}\n';
                }
            }

            style.appendChild(document.createTextNode(css));
            head.appendChild(style);
        },

        /**
         * Creates subset of font metrics.
         * @param {string[]} fonts
         * @returns {DPO.text.FontMetrics}
         */
        createSubset: function createSubset(fonts) {
            var subset = {}, name, m;
            for (var i = 0; i < fonts.length; i++) {
                name = fonts[i];
                m = this.metrics[name];
                if (m) {
                    subset[name] = m;
                }
            }

            return new FontMetrics(subset);
        }
    });

    /**
     * Default font metrics
     * @memberof DPO.text
     * @type {DPO.text.FontMetrics}
     */
    DPO.text.DefaultMetrics = new FontMetrics(allMetrics);

    /**
     * All font metrics
     * @memberof DPO.text
     * @type {DPO.text.FontMetrics}
     */
    DPO.text.AllMetrics = new FontMetrics(allMetrics);
    return FontMetrics;
});
DPO.def('text.Line', function () {
    /**
     * @class DPO.text.Line
     * @memberof DPO.text
     * @param {DPO.model.Span[]} [spans]
     * @param {DPO.model.Span[]} [visibleSpans]
     * @property {number} capHeight
     * @property {number} ascender
     * @property {number} descender
     * @property {object[]} words
     * @property {DPO.model.Span[]} spans line spans
     * @property {DPO.model.Span[]} visibleSpans spans line spans without trailing whitespace
     * @property {number} width line width in points
     * @property {number} height line height in points
     * @property {number} offsetX x-offset in container space
     * @property {number} offsetY y-offset in container space
     * @property {DPO.math.Polygon} geometry in text container coordinates
     * @constructor
     */
    function Line(spans, visibleSpans) {
        var me = this;
        me.spans = spans;
        me.visibleSpans = visibleSpans;
        me.width = 0;
        me.height = 0;
        me.offsetX = 0;
        me.offsetY = 0;
    }

    DPO.inherit(Line, DPO.model.Introspector);
    DPO.mixin(Line.prototype, {
        /**
         * Returns largest span element
         * @memberof DPO.text.Line#
         * @returns {DPO.model.Span}
         */
        getLargestSpan: function getLargestSpan() {
            var max = Number.NEGATIVE_INFINITY,
                span = null;
            for (var i = 0; i < this.spans.length; i++) {
                var s = this.spans[i];
                if (max < s.fontSize) {
                    span = s;
                    max = s.fontSize;
                }
            }
            return span;
        },

        /**
         * Returns line length including trailing whitespace
         * @memberof DPO.text.Line#
         * @returns {number}
         */
        totalLength: function totalLength() {
            var length = 0;
            for (var i = 0; i < this.spans.length; i++) {
                var s = this.spans[i];
                length += s.value.length;
            }
            return length;
        },

        /**
         * Returns line plain text including trailing whitespace
         * @memberof DPO.text.Line#
         * @returns {string}
         */
        getPlainText: function getPlainText() {
            var text = '';
            for (var i = 0; i < this.spans.length; i++) {
                var s = this.spans[i];
                text += s.value;
            }
            return text;
        }
    });

    return Line;
});

DPO.def('text.Container', function () {
    /**
     * @class DPO.text.Container
     * @memberof DPO.text
     * @param {DPO.model.Paragraph} paragraph
     * @param {number} width
     * @param {number} height
     * @property {DPO.text.Line[]} lines
     * @property {number} lineSpacing
     * @property {number} width
     * @property {number} height
     * @property {number} preferredWidth
     * @property {boolean} collapsable
     * @constructor
     */
    function Container(paragraph, width, height) {
        this.paragraph = paragraph;
        this.spans = [].concat(paragraph.spans);
        this.lines = [];
        this.width = width;
        this.height = height;
    }

    DPO.mixin(Container.prototype, {
        lineSpacing: 1.2
    });

    return Container;
});
DPO.def('text.Layout', function () {
    /**
     * @class DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @property {boolean} expandedText
     * @constructor
     */
    function Layout(lm, textBlock, expandedText) {
        this.lm = lm;
        this.expandedText = !!expandedText;
        this.textBlock = textBlock;
        this.initContainers();
    }

    var spaceRegExp = /(^\s+)/;

    DPO.mixin(Layout.prototype, {
        /**
         * Returns word width
         * @memberof DPO.text.Layout#
         * @param {object} word
         * @param {object} [force]
         * @returns {object}
         */
        calculateWordMetrics: function calculateWordMetrics(word, force) {
            var me = this,
                wordWidth = word.wordWidth, i, span, font;
            if (wordWidth !== undefined && !force) {
                return word;
            }

            wordWidth = 0;
            for (i = 0; i < word.text.length; i++) {
                var t = word.text[i];
                span = me.spansCache[t.spanIndex];
                font = me.lm.getFontForSpan(span);
                t.width = me.lm.getTextWidth(t.value, span.fontSize, font);
                wordWidth += t.width;
            }

            var spaceWidth = 0;
            for (i = 0; i < word.spaces.length; i++) {
                var s = word.spaces[i];
                span = me.spansCache[s.spanIndex];
                font = me.lm.getFontForSpan(span);
                s.width = me.lm.getTextWidth(s.value, span.fontSize, font);
                spaceWidth += s.width;
            }

            word.wordWidth = wordWidth;
            word.spaceWidth = spaceWidth;
            return word;
        },

        /**
         * Returns container's text with
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container} container
         * @returns {number}
         */
        getContainerWidth: function getMaxContainerWidth(container) {
            return this.lm.getSpansWidth(container.spans);
        },

        getLineOffsetX: function getLineOffsetX(align, width, containerWidth) {
            switch (align) {
                case 'right':
                    return containerWidth - width;
                case 'center':
                    return (containerWidth - width) / 2;
                default:
                    return 0;
            }
        },

        /**
         * Removes invisible spans from specified line(s)
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Line[]|DPO.text.Line} lines
         * @returns {DPO.text.Layout}
         */
        cleanupLines: function cleanupLines(lines) {
            lines = lines instanceof Array ? lines : [lines];

            for (var i = 0; i < lines.length; i++) {
                var line = lines[i],
                    spans = line.spans, span, j;

                for (j = spans.length - 1; j >= 0 && spans.length > 1; j--) {
                    span = spans[j];
                    if (!span.value) {
                        spans.splice(j, 1);
                    }
                }

                spans = line.visibleSpans;
                for (j = spans.length - 1; j >= 0 && spans.length > 1; j--) {
                    span = spans[j];
                    if (!span.value) {
                        spans.splice(j, 1);
                    }
                }
            }

            return this;
        },

        /**
         * Removes invisible spans from specified container(s)
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container[]|DPO.text.Container} containers
         * @returns {DPO.text.Container[]}
         */
        cleanupContainers: function cleanupContainers(containers) {
            containers = containers instanceof Array ? containers : [containers];
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                for (var j = 0; j < container.lines.length; j++) {
                    this.cleanupLines(container.lines);
                }
            }
            return containers;
        },

        /**
         * Calculates container metrics
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container} container
         * @param {number} width
         */
        calculateContainerMetrics: function calculateContainerMetrics(container, width) {
            var me = this,
                dm = me.lm.fontMetrics,
                lines = container.lines,
                offset = 0,
                containerWidth = 0,
                containerHeight = 0;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i],
                    span = line.getLargestSpan(),
                    m = dm.getMetricsForSpan(span);

                line.capHeight = dm.getCapHeight(m, span.fontSize);
                line.width = me.lm.getSpansWidth(line.spans);
                line.visibleWidth = me.lm.getSpansWidth(line.visibleSpans);
                line.height = container.collapsable ? 0 : span.fontSize * container.lineSpacing;
                line.ascender = dm.getAscender(m, span.fontSize);
                line.descender = dm.getDescender(m, span.fontSize);
                line.offsetX = me.getLineOffsetX(container.paragraph.textAlign, line.visibleWidth, width);
                line.offsetY = offset + line.ascender;
                line.geometry = new DPO.math.Polygon([
                    line.offsetX,
                    line.offsetY,
                    line.offsetX + line.width,
                    line.offsetY
                ]);

                offset += line.height;
                containerHeight += line.height;
                containerWidth = Math.max(containerWidth, line.width);
            }

            container.preferredWidth = containerWidth;
            container.height = containerHeight;
            container.width = width;
        },

        /**
         * Returns container's scale factors
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container[]} containers
         * @param {number} width
         * @param {number} height
         * @returns {{scale: number, fontScale: number, widthScale: number}}
         */
        getScaleFactors: function getScaleFactors(containers, width, height) {
            var me = this,
                fontScale = -Infinity,
                textWidth = 0,
                textHeight = 0,
                span, scale, j;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i],
                    collapse = container.collapsable && !me.expandedText,
                    maxLineHeight = 0;
                for (j = 0; j < container.spans.length; j++) {
                    span = container.spans[j];
                    scale = collapse ? -Infinity : me.lm.getMinFontSize(span) / span.fontSize;
                    fontScale = Math.max(fontScale, scale);
                    maxLineHeight = Math.max(maxLineHeight, span.fontSize * container.lineSpacing);
                }

                textHeight += collapse ? 0 : maxLineHeight;
                textWidth = Math.max(me.getContainerWidth(container), textWidth);
            }

            var widthScale = width / textWidth,
                heightScale = height / textHeight;
            scale = Math.max(fontScale, widthScale);
            return {
                scale: scale,
                shrinkScale: Math.max(Math.min(fontScale, 1), Math.min(widthScale, heightScale, 1)),
                fontScale: fontScale,
                widthScale: widthScale,
                heightScale: heightScale,
                boxScale: Math.min(widthScale, heightScale)
            };
        },

        /**
         * Extracts words from spans
         * @memberof DPO.text.Layout#
         * @param {DPO.model.Span[]} spans
         * @returns {object[]}
         */
        grabWords: function grabWords(spans) {
            var me = this,
                result = [],
                info = {
                    text: [],
                    spaces: []
                },
                match;

            function pushInfo() {
                result.push(info);
                info = {
                    text: [],
                    spaces: []
                };
            }

            var text = null,
                current = 0,
                span, spanIndex, spaceIndex;
            while (spans[current] || text) {
                if (text === null) {
                    span = spans[current];
                    spanIndex = me.spansCache.indexOf(span);
                    text = span.value;
                }

                spaceIndex = text.indexOf(' ');
                switch (spaceIndex) {
                    case -1:
                        if (info.spaces.length) {
                            pushInfo();
                        }

                        info.text.push({spanIndex: spanIndex, value: text});
                        text = null;
                        current++;
                        break;
                    case 0:
                        match = spaceRegExp.exec(text);
                        if (match.input === match[1]) {
                            info.spaces.push({spanIndex: spanIndex, value: text});
                            text = null;
                            current++;
                        } else {
                            info.spaces.push({spanIndex: spanIndex, value: match[1]});
                            pushInfo();

                            text = text.substr(match[1].length);
                        }
                        break;
                    default:
                        if (info.spaces.length) {
                            pushInfo();
                        }

                        info.text.push({spanIndex: spanIndex, value: text.substr(0, spaceIndex)});
                        text = text.substr(spaceIndex);
                        break;
                }
            }

            pushInfo();
            return result;
        },

        /**
         * Extracts words from spans
         * @memberof DPO.text.Layout#
         */
        grabWordsIfNeeded: function grabWordsIfNeeded() {
            var me = this;
            for (var i = 0; i < me.containers.length; i++) {
                var container = me.containers[i];
                container.words = container.words || me.grabWords(container.spans);
            }
        },

        /**
         * Checks if spans can be collapsed
         * @memberof DPO.text.Layout#
         * @param {DPO.model.Span[]} spans
         * @returns {boolean}
         */
        canCollapse: function isCollapsable(spans) {
            var regexp = /^\s*$/,
                whiteSpaces = true,
                hasMailMarge = false;
            for (var i = 0; i < spans.length; i++) {
                var s = spans[i];
                whiteSpaces = whiteSpaces && regexp.test(s.value);
                hasMailMarge = hasMailMarge || !!s.mailMergeField;
            }
            return whiteSpaces && hasMailMarge && !this.expandedText;
        },

        /**
         * Initializes text containers & span cache
         * @memberof DPO.text.Layout#
         * @param {number} [scaleFactor]
         * @returns {DPO.text.Container[]}
         */
        initContainers: function initContainers(scaleFactor) {
            var me = this,
                paragraphs = me.textBlock.text.textFlow.paragraphs,
                spansCache = [],
                containers = [];
            scaleFactor = scaleFactor || 1;

            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i],
                    container = new DPO.text.Container(p, Infinity, Infinity),
                    spans = scaleFactor === 1 ? container.spans : me.lm.clone(container.spans);

                for (var j = 0; scaleFactor !== 1 && j < spans.length; j++) {
                    var span = spans[j];
                    span.fontSize *= scaleFactor;
                }

                spansCache = spansCache.concat(spans);
                container.collapsable = me.canCollapse(spans);
                container.spans = spans;
                containers.push(container);
            }

            me.spansCache = spansCache;
            me.containers = containers;

            return containers;
        },

        /**
         * Creates text line from specified spans
         * @memberof DPO.text.Layout#
         * @param {DPO.model.Span[]} spans
         * @returns {DPO.text.Line}
         */
        lineFromSpans: function lineFromSpans(spans) {
            var me = this,
                s1, s2, i;
            spans = me.lm.clone(spans);

            // Merge spans width equal styles
            for (i = spans.length - 1; i > 0; i--) {
                s1 = spans[i];
                s2 = spans[i - 1];
                if (s2 && s1.isStylesEqual(s2)) {
                    s2.value += s1.value;
                    spans.splice(i, 1);
                }
            }

            // Remove trailing spaces
            var redExp1 = /\s+$/,
                visible = [].concat(spans);
            for (i = visible.length - 1; i >= 0; i--) {
                s1 = visible[i];
                if (redExp1.test(s1.value)) {
                    s1 = me.lm.clone(s1);
                    s1.value = s1.value.replace(redExp1, '');
                    visible[i] = s1;
                } else {
                    break;
                }
            }

            // Remove empty spans. At least one span have to be in array
            var first = visible[0];
            for (i = visible.length - 1; i >= 0; i--) {
                s1 = visible[i];
                if (!s1.value) {
                    visible.splice(i, 1);
                }
            }

            return new DPO.text.Line(spans, visible.length ? visible : [first]);
        },

        /**
         * Creates text line from specified words
         * @memberof DPO.text.Layout#
         * @param {object} words
         * @returns {DPO.text.Line}
         */
        lineFromWords: function lineFromWords(words) {
            var me = this,
                visible = [],
                styleSpan = null,
                span = null, s, i, j, obj;

            function pushSpan(array, obj) {
                if (obj && array.indexOf(obj) === -1) {
                    array.push(obj);
                }
            }

            for (i = 0; i < words.length; i++) {
                var word = words[i];
                for (j = 0; j < word.text.length; j++) {
                    obj = word.text[j];
                    s = me.spansCache[obj.spanIndex];
                    if (!styleSpan || !s.isStylesEqual(styleSpan)) {
                        pushSpan(visible, span);
                        span = me.lm.clone(s);
                        span.value = '';
                        styleSpan = s;
                    }

                    span.value += obj.value;
                }

                for (j = 0; j < word.spaces.length && i < words.length - 1; j++) {
                    obj = word.spaces[j];
                    s = me.spansCache[obj.spanIndex];
                    if (!styleSpan || !s.isStylesEqual(styleSpan)) {
                        pushSpan(visible, span);
                        span = me.lm.clone(s);
                        span.value = '';
                        styleSpan = s;
                    }

                    span.value += obj.value;
                }
            }

            pushSpan(visible, span);

            var last = words[words.length - 1],
                spans = me.lm.clone(visible);
            span = spans[spans.length - 1];
            if (last.spaces.length) {
                for (j = 0; j < last.spaces.length; j++) {
                    obj = last.spaces[j];
                    s = me.spansCache[obj.spanIndex];
                    if (styleSpan !== s) {
                        pushSpan(spans, span);
                        span = me.lm.clone(s);
                        span.value = '';
                        styleSpan = s;
                    }

                    span.value += obj.value;
                }

                pushSpan(spans, span);
            }

            if (visible.length === 0) {
                s = me.lm.clone(spans[0]);
                s.value = '';
                visible = [s];
            }

            return new DPO.text.Line(spans, visible);
        },

        /**
         * Performs vertical alignment
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container[]} containers
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performVerticalAlignment: function performVerticalLayout(containers, height) {
            var textBlock = this.textBlock,
                align = textBlock.text.textFlow.verticalAlign,
                offset = 0, container;
            for (var i = 0; i < containers.length; i++) {
                container = containers[i];
                offset += container.height;
            }

            switch (align) {
                case 'top':
                    offset = 0;
                    break;
                case 'middle':
                    offset = (height - offset) / 2;
                    break;
                case 'bottom':
                    offset = height - offset;
                    break;
            }

            for (i = 0; i < containers.length; i++) {
                container = containers[i];
                container.offset += offset;
            }
            return containers;
        },

        /**
         * Returns container's size & aspect ratio
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container[]} containers
         * @returns {{aspect: number, height: number, width: number}}
         */
        getContainersSize: function getContainersSize(containers) {
            var h = 0,
                w = 0;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                for (var j = 0; j < container.lines.length; j++) {
                    var line = container.lines[j];
                    w = Math.max(w, line.width);
                }

                h += container.height;
            }

            return {
                aspect: w / h,
                height: h,
                width: w
            };
        },

        /**
         * Clones containers
         * @memberof DPO.text.Layout#
         * @param {DPO.text.Container[]} containers
         * @returns {DPO.text.Container[]}
         */
        cloneContainer: function cloneContainer(containers) {
            var array = [];
            for (var i = 0; i < containers.length; i++) {
                var c = containers[i],
                    clone = new DPO.text.Container(c.paragraph, Infinity, Infinity);
                clone.words = c.words; // Reuse parsed words for better performance
                array.push(clone);
            }
            return array;
        },

        /**
         * Performs text layout
         * @memberof DPO.text.Layout#
         * @virtual
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            return [];
        }
    });

    return Layout;
});

DPO.def('text.FitLayout', function () {
    /**
     * @class DPO.text.FitLayout
     * @extends DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @constructor
     */
    function FitLayout(lm, textBlock, expandedText) {
        DPO.text.Layout.apply(this, arguments);
    }

    DPO.inherit(FitLayout, DPO.text.Layout);
    DPO.mixin(FitLayout.prototype, {
        /**
         * Performs text layout
         * @memberof DPO.text.FitLayout#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            var me = this,
                containers = me.containers,
                scaleFactors = me.getScaleFactors(containers, width, height),
                offset = 0;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i],
                    spans = me.lm.clone(container.spans);

                for (var j = 0; j < spans.length; j++) {
                    var span = spans[j];
                    span.fontSize *= scaleFactors.boxScale;
                }

                var line = me.lineFromSpans(spans);
                container.lines.push(line);

                me.cleanupContainers(container);
                me.calculateContainerMetrics(container, width);
                container.offset = offset;
                offset += container.height;
            }

            return me.performVerticalAlignment(containers, height);
        }
    });

    return FitLayout;
});

DPO.def('text.ShrinkLayout', function () {
    /**
     * @class DPO.text.ShrinkLayout
     * @extends DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @constructor
     */
    function ShrinkLayout(lm, textBlock, expandedText) {
        DPO.text.Layout.apply(this, arguments);
    }

    DPO.inherit(ShrinkLayout, DPO.text.Layout);
    DPO.mixin(ShrinkLayout.prototype, {
        /**
         * Performs text layout
         * @memberof DPO.text.ShrinkLayout#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            var me = this,
                containers = me.containers,
                scaleFactors = me.getScaleFactors(containers, width, height),
                scale = Math.min(scaleFactors.boxScale, 1),
                offset = 0;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];

                for (var j = 0; j < container.spans.length; j++) {
                    var span = container.spans[j];
                    span.fontSize *= scale;
                }

                var line = me.lineFromSpans(container.spans);
                container.lines.push(line);

                me.cleanupContainers(container);
                me.calculateContainerMetrics(container, width);
                container.offset = offset;
                offset += container.height;
            }

            return me.performVerticalAlignment(containers, height);
        }
    });

    return ShrinkLayout;
});
DPO.def('text.WrapLayout', function () {
    /**
     * @class DPO.text.WrapLayout
     * @extends DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @constructor
     */
    function WrapLayout(lm, textBlock, expandedText) {
        DPO.text.Layout.apply(this, arguments);
        this.grabWordsIfNeeded();
    }

    DPO.inherit(WrapLayout, DPO.text.Layout);
    DPO.mixin(WrapLayout.prototype, {
        /**
         * Splits single word to fit line width
         * @memberof DPO.text.WrapLayout#
         * @param {object} word
         * @param {number} lineWidth
         * @returns {object[]}
         */
        splitWord: function splitWord(word, lineWidth) {
            var array = [],
                text = [].concat(word.text),
                me = this,
                index, t;

            function split(t, index) {
                array.push({
                    text: [{
                        spanIndex: t.spanIndex,
                        value: t.value.substr(0, index)
                    }],
                    spaces: []
                });

                var rest = t.value.substr(index);
                if (rest) {
                    text[0] = {
                        value: rest,
                        spanIndex: t.spanIndex
                    };
                } else {
                    text.splice(0, index);
                }
            }

            function splitter(width, advance, kerning) {
                if (width + advance + kerning > lineWidth) {
                    split(t, advance >= lineWidth ? 1 : index);
                    return true;
                }

                index++;
                return false;
            }

            while (text.length) {
                t = text[0];

                var span = me.spansCache[t.spanIndex],
                    font = me.lm.getFontForSpan(span);
                index = 0;
                me.lm.getTextWidth(t.value, span.fontSize, font, splitter);

                if (index === t.value.length && index > 0) {
                    array.push({
                        text: [t],
                        spaces: []
                    });
                    text.splice(0, 1);
                }
            }

            var last = array[array.length - 1];
            last.spaces = word.spaces;
            return array;
        },

        /**
         * Splits multiple words to fit line width
         * @memberof DPO.text.WrapLayout#
         * @param {object[]} words
         * @param {number} lineWidth
         * @returns {Array}
         */
        splitWords: function splitWords(words, lineWidth) {
            var result = [];
            for (var i = 0; i < words.length; i++) {
                var word = words[i];
                this.calculateWordMetrics(word);

                if (word.wordWidth > lineWidth) {
                    var r = this.splitWord(word, lineWidth);
                    result = result.concat(r);
                } else {
                    result.push(word);
                }
            }

            return result;
        },

        /**
         * Wraps words to fit line width
         * @memberof DPO.text.WrapLayout#
         * @param {object} words
         * @param {number} lineWidth
         * @returns {object[]}
         */
        wrapWords: function wrapWords(words, lineWidth) {
            var spaceLeft = lineWidth,
                result = [],
                line = [];

            function pushLine() {
                if (line.length) {
                    result.push(line);
                }
                line = [];
            }

            var prevSpaceWidth = 0,
                word, wordWidth;
            for (var i = 0; i < words.length; i++) {
                word = words[i];
                this.calculateWordMetrics(word);
                wordWidth = word.wordWidth;
                if (wordWidth + prevSpaceWidth > spaceLeft) {
                    pushLine();
                    spaceLeft = lineWidth - wordWidth;
                } else {
                    spaceLeft -= wordWidth;
                }
                spaceLeft -= prevSpaceWidth;
                prevSpaceWidth = word.spaceWidth;
                line.push(word);
            }

            pushLine();
            return result;
        },

        /**
         * Performs text layout
         * @memberof DPO.text.WrapLayout#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            var me = this,
                containers = me.containers,
                offset = 0;

            for (var i = 0; i < containers.length; i++) {
                var container = containers[i],
                    words = container.words,
                    lines;

                words = me.splitWords(words, width);
                lines = me.wrapWords(words, width);
                for (var j = 0; j < lines.length; j++) {
                    container.lines.push(me.lineFromWords(lines[j]));
                }
                me.cleanupContainers(container);
                me.calculateContainerMetrics(container, width);
                container.offset = offset;
                offset += container.height;
            }

            return me.performVerticalAlignment(containers, height);
        }
    });

    return WrapLayout;
});
DPO.def('text.ShrinkWrapLayout', function () {
    /**
     * @class DPO.text.ShrinkWrapLayout
     * @extends DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @constructor
     */
    function ShrinkWrapLayout(lm, textBlock, expandedText) {
        DPO.text.WrapLayout.apply(this, arguments);
    }

    DPO.inherit(ShrinkWrapLayout, DPO.text.WrapLayout);
    DPO.mixin(ShrinkWrapLayout.prototype, {
        /**
         * Performs text layout
         * @memberof DPO.text.ShrinkWrapLayout#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            var me = this,
                containers = me.containers,
                scaleFactors = me.getScaleFactors(containers, width, height),
                offset = 0;
            containers = me.initContainers(scaleFactors.shrinkScale);

            if (scaleFactors.shrinkScale <= scaleFactors.fontScale) {
                me.grabWordsIfNeeded();
                return me.$super.performLayout.apply(me, arguments);
            }

            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                container.lines.push(me.lineFromSpans(container.spans));
                me.cleanupContainers(container);
                me.calculateContainerMetrics(container, width);
                container.offset = offset;
                offset += container.height;
            }

            return me.performVerticalAlignment(containers, height);
        }
    });

    return ShrinkWrapLayout;
});

DPO.def('text.WrapShrinkLayout', function () {
    /**
     * @class DPO.text.WrapShrinkLayout
     * @extends DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @constructor
     */
    function WrapShrinkLayout(lm, textBlock, expandedText) {
        DPO.text.WrapLayout.apply(this, arguments);
    }

    DPO.inherit(WrapShrinkLayout, DPO.text.WrapLayout);
    DPO.mixin(WrapShrinkLayout.prototype, {
        /**
         * @memberof DPO.text.WrapShrinkLayout#
         * @param {DPO.text.Container[]} containers
         * @param {number} width
         * @returns {DPO.text.Container[]}
         */
        fastWrapLayout: function fastWrapLayout(containers, width) {
            var me = this;

            function getWordsWidth(words) {
                var w = 0,
                    word;
                for (var i = 0; i < words.length; i++) {
                    word = words[i];
                    w += word.wordWidth;
                    w += word.spaceWidth;
                }

                word = words[words.length - 1];
                return Math.max(w - word.spaceWidth, 0);
            }

            for (var i = 0; i < containers.length; i++) {
                var container = containers[i],
                    words = container.words,
                    lines = me.wrapWords(words, width),
                    containerHeight = 0;
                for (var j = 0; j < lines.length; j++) {
                    var lineWords = lines[j],
                        textLine = me.lineFromWords(lineWords),
                        span = textLine.getLargestSpan();
                    textLine.width = getWordsWidth(lineWords);
                    textLine.height = container.collapsable ? 0 : span.fontSize * container.lineSpacing;
                    textLine.words = lineWords;
                    container.lines.push(textLine);
                    containerHeight += textLine.height;
                }

                container.width = width;
                container.height = containerHeight;
            }

            return containers;
        },

        /**
         * Returns min & max word width
         * @memberof DPO.text.WrapShrinkLayout#
         * @param {DPO.text.Container[]} containers
         * @returns {{minWidth: number, maxWidth: number}}
         */
        getWordsMetrics: function getWordsMetrics(containers) {
            var maxWidth = -Infinity,
                minWidth = Infinity;

            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                for (var j = 0; j < container.lines.length; j++) {
                    var line = container.lines[j];
                    for (var k = 0; k < line.words.length; k++) {
                        var word = line.words[k];
                        maxWidth = Math.max(maxWidth, word.wordWidth);
                        minWidth = Math.min(minWidth, word.wordWidth);
                    }
                }
            }
            return {minWidth: minWidth, maxWidth: maxWidth};
        },

        /**
         * Applies font scale factor to specified containers
         * @memberof DPO.text.WrapShrinkLayout#
         * @param {DPO.text.Container[]} containers
         * @param {number} scale
         * @param {number} width
         * @returns {DPO.text.Container[]}
         */
        applyScale: function applyScale(containers, scale, width) {
            var me = this,
                result = [],
                spans = [],
                offset = 0,
                i, j, container;
            for (i = 0; i < containers.length; i++) {
                var c1 = containers[i],
                    c2 = new DPO.text.Container(c1.paragraph, width, Infinity);

                for (j = 0; j < c1.lines.length; j++) {
                    var line = c1.lines[j],
                        l = new DPO.text.Line(me.lm.clone(line.spans), me.lm.clone(line.visibleSpans));
                    spans = spans.concat(l.spans);
                    spans = spans.concat(l.visibleSpans);
                    c2.lines.push(l);
                }

                c2.collapsable = c1.collapsable;
                result.push(c2);
            }

            for (i = 0; i < spans.length; i++) {
                var span = spans[i];
                span.fontSize *= scale;
            }

            for (i = 0; i < result.length; i++) {
                container = result[i];
                container.collapsable = me.canCollapse(container.spans);
                me.cleanupContainers(container);
                me.calculateContainerMetrics(container, width);
                container.offset = offset;
                offset += container.height;
            }

            return result;
        },

        /**
         * Performs text layout
         * @memberof DPO.text.WrapShrinkLayout#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            var me = this,
                containers = me.fastWrapLayout(me.containers, width),
                size = me.getContainersSize(containers);
            if (size.height < height && size.width < width) {
                containers = me.applyScale(containers, 1, width);
                return me.performVerticalAlignment(containers, height);
            }

            var wrap = me.cloneContainer(containers),
                aspect = width / height,
                iterations = [];
            wrap = me.fastWrapLayout(wrap, Infinity);
            size = me.getContainersSize(wrap);
            iterations.push({
                containers: wrap,
                delta: Math.abs(aspect - size.aspect),
                size: size
            });

            var metrics = me.getWordsMetrics(wrap),
                left = size.width,
                right = metrics.maxWidth;
            while (Math.abs(left - right) > 1) {
                var mid = (left + right) / 2;
                wrap = me.cloneContainer(containers);
                wrap = me.fastWrapLayout(wrap, mid);
                size = me.getContainersSize(wrap);
                iterations.push({
                    containers: wrap,
                    delta: Math.abs(aspect - size.aspect),
                    size: size
                });

                if (aspect < size.aspect) {
                    left = mid;
                } else {
                    right = mid;
                }
            }

            iterations = iterations.sort(function (a, b) {
                return a.delta - b.delta;
            });

            var best = iterations[0],
                scale = Math.min(height / best.size.height, width / best.size.width);
            containers = me.applyScale(best.containers, scale, width);
            return me.performVerticalAlignment(containers, height);
        }
    });

    return WrapShrinkLayout;
});

DPO.def('text.TextPathLayout', function () {
    /**
     * @class DPO.text.TextPathLayout
     * @extends DPO.text.Layout
     * @param {DPO.text.LayoutManager} lm
     * @param {DPO.model.TextBlock} textBlock
     * @param {boolean} [expandedText]
     * @property {DPO.text.LayoutManager} lm
     * @property {DPO.model.TextBlock} textBlock
     * @constructor
     */
    function TextPathLayout(lm, textBlock, expandedText) {
        DPO.text.Layout.apply(this, arguments);
    }

    DPO.inherit(TextPathLayout, DPO.text.Layout);
    //noinspection JSUnusedLocalSymbols
    DPO.mixin(TextPathLayout.prototype, {
        /**
         * Calculates text line geometry
         * @memberof DPO.text.TextPathLayout#
         * @param {DPO.text.Line} line
         */
        calculateLineGeometry: function calculateLineGeometry(line) {
            var me = this,
                halfLineTwips = line.width * 10;
            if (!halfLineTwips) { // Line is empty nothing to do
                return;
            }

            // Perform calculation in twips for better accuracy
            var textPath = /** @type DPO.model.TextPath*/me.textBlock,
                width = textPath.width,
                height = textPath.height,
                middleAngleDeg = (720 - textPath.textAngle) % 360,
                center = new DPO.math.Point(width / 2, height / 2),
                baseLineEllipse = new DPO.math.Ellipse(center, width / 2, height / 2),
                middleAngleRad = DPO.math.rad(middleAngleDeg),
                halfAngleRad = baseLineEllipse.endOfCircumference(middleAngleRad, halfLineTwips, 1) - middleAngleRad,
                halfAngleDeg = Math.min(DPO.math.deg(halfAngleRad), 180);

            // Go to points
            var a = textPath.width / 40,
                b = textPath.height / 40,
                c = new DPO.math.Point(a, b),
                outerDelta = 0, //textPath.rotateSense === 'ccw' ? line.ascender : 0,
                outerEllipse = new DPO.math.Ellipse(c, a + outerDelta, b + outerDelta),
                startAngle = middleAngleDeg - halfAngleDeg,
                endAngle = middleAngleDeg + halfAngleDeg,
                steps = Math.round(line.width / 4),
                polygon = outerEllipse.polygonize(startAngle, endAngle, steps);
            if (textPath.rotateSense === 'cw') {
                polygon.reverse();
            }
            line.geometry = polygon;
        },

        /**
         * Performs text layout
         * @memberof DPO.text.TextPathLayout#
         * @param {number} width
         * @param {number} height
         * @returns {DPO.text.Container[]}
         */
        performLayout: function performLayout(width, height) {
            var me = this,
                containers = me.containers,
                offset = 0;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i],
                    line = me.lineFromSpans(container.spans);
                container.lines.push(line);

                me.cleanupLines(line);
                me.calculateContainerMetrics(container, width);
                me.calculateLineGeometry(line);

                container.offset = offset;
                container.width = line.width;
                offset += container.height;
            }

            return containers;
        }
    });

    return TextPathLayout;
});

DPO.def('text.LayoutManager', function () {
    /**
     * @class DPO.text.HttpFontLoader
     * @memberof DPO.text
     * @param {DPO.text.LayoutManager} layoutManager
     * @constructor
     */
    function HttpFontLoader(layoutManager) {
        this.layoutManager = layoutManager;
    }

    DPO.mixin(HttpFontLoader.prototype, {
        /**
         * Loads fonts by it relative & absolute paths
         * @memberof DPO.text.LayoutManager#
         * @param {string} relative
         * @param {string} absolute
         */
        loadFont: function loadFont(relative, absolute) {
            var me = this,
                request = new XMLHttpRequest();
            request.open('get', absolute, true);
            request.responseType = 'arraybuffer';
            request.onload = function onLoad() {
                var arrayBuffer = request.response,
                    font = null;
                try {
                    font = opentype.parse(arrayBuffer);
                }
                catch (e) {
                    font = null;
                    DPO.emptyFn(e);
                }

                me.layoutManager.decRequestCount(font, relative);
            };

            request.onerror = function onError() {
                me.layoutManager.decRequestCount(null, relative);
            };

            request.send();
        }
    });
    
    /**
     * @class DPO.text.LayoutManager
     * @extends DPO.mixins.Observable
     * @memberof DPO.text
     * @param {string} fontPath
     * @param {DPO.text.FontMetrics} [fontMetrics]
     * @param {object} [cfg]
     * @property {object} fallbackFontFamily
     * @property {object} fallbackFont
     * @property {DPO.text.FontMetrics} fontMetrics
     * @fires fonts:loaded
     * @constructor
     */
    function LayoutManager(fontPath, fontMetrics, cfg) {
        var me = this;
        DPO.model.Introspector.apply(me, [cfg]);
        me.fontMetrics = fontMetrics || DPO.text.DefaultMetrics;
        me.requestCount = 0;
        me.fontPath = fontPath;
        me.fonts = {};
        me.fallbackFontFamily = me.fontMetrics.fallbackFontFamily;
        me.fallbackFontPath = me.fontMetrics.fallbackFontFamily.Regular[0];
        me.fontLoader = me.fontLoader || new HttpFontLoader(me);
        me.resetObservable();
    }

    DPO.inherit(LayoutManager, DPO.model.Introspector);
    DPO.mixin(LayoutManager.prototype, DPO.mixins.Observable);
    DPO.mixin(LayoutManager.prototype, {
        minimumCharacterHeight: 3,

        layoutMap: {
            'shrinkwrap': DPO.text.ShrinkWrapLayout,
            'wrapshrink': DPO.text.WrapShrinkLayout,
            'wrap': DPO.text.WrapLayout,
            'shrink': DPO.text.ShrinkLayout,
            'fit': DPO.text.FitLayout
        },

        /**
         * Returns all fonts
         * @returns {object[]}
         */
        getAllFonts: function getAllFonts() {
            var keys = Object.keys(this.fonts),
                result = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                result.push(this.fonts[key]);
            }

            return result;
        },

        /**
         * Returns font metrics for specified span
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Span|{fontFamily: string, fontStyle: string, fontWeight: string}} span
         * @returns {object}
         */
        getMetricsForSpan: function getMetricsForSpan(span) {
            var dm = this.fontMetrics,
                familyMetrics = dm.getFontFamilyMetrics(span.fontFamily) || {},
                subfamily = dm.getSubfamilyName(span.fontWeight === 'bold', span.fontStyle === 'italic');
            return familyMetrics[subfamily] || this.fallbackFontFamily.Regular;
        },

        /**
         * Returns style for specified font
         * @memberof DPO.text.LayoutManager#
         * @param {*} font
         * @returns {?{fontFamily: string, fontStyle: string, fontWeight: string}}
         */
        getFontStyle: function getFontStyle(font) {
            var urls = Object.keys(this.fonts),
                dm = this.fontMetrics,
                u, i, url;
            for (i = 0; !url && i < urls.length; i++) {
                u = urls[i];
                if (this.fonts[u] === font) {
                    url = u;
                }
            }

            for (i = 0; i < dm.names.length; i++) {
                var name = dm.names[i],
                    m = dm.metrics[name],
                    subfamilies = Object.keys(m);
                for (var j = 0; j < subfamilies.length; j++) {
                    var subfamily = subfamilies[j],
                        attr = m[subfamily];
                    if (attr[0] === url) {
                        return {
                            fontFamily: name,
                            fontStyle: subfamily.indexOf('Italic') === -1 ? 'normal' : 'italic',
                            fontWeight: subfamily.indexOf('Bold') === -1 ? 'normal' : 'bold'
                        };
                    }
                }
            }

            return null;
        },

        /**
         * Returns font for specified span
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Span} span
         * @returns {object}
         */
        getFontForSpan: function getFontForSpan(span) {
            var metrics = this.getMetricsForSpan(span);
            return this.getFont(metrics[0]) || this.fallbackFont;
        },

        /**
         * Returns text width
         * @memberof DPO.text.LayoutManager#
         * @param {string} text
         * @param {number} fontSize
         * @param {object} font
         * @param {function} [collector]
         */
        getTextWidth: function getTextWidth(text, fontSize, font, collector) {
            var width = 0,
                fallbackFont = this.fallbackFont,
                notDefGlyph = font.glyphs.get(0),
                stop = false;
            for (var j = 0; !stop && j < text.length; j++) {
                var kerningFont = font,
                    left = font.charToGlyph(text[j]),
                    fallbackCount = 0;
                if (left === notDefGlyph) {
                    left = fallbackFont.charToGlyph(text[j]);
                    kerningFont = fallbackFont;
                    fallbackCount++;
                }

                var fontScale = 1 / kerningFont.unitsPerEm * fontSize,
                    advance = left.advanceWidth * fontScale,
                    kerning = 0;
                if (j + 1 < text.length) {
                    var right = font.charToGlyph(text[j + 1]);
                    if (right === notDefGlyph) {
                        right = fallbackFont.charToGlyph(text[j]);
                        fallbackCount++;
                    }

                    if (fallbackCount % 2 === 0) {
                        kerning = kerningFont.getKerningValue(left, right) * fontScale;
                    }
                }

                if (collector) {
                    stop = !!collector(width, advance, kerning);
                }
                width += advance + kerning;
            }

            return width;
        },

        /**
         * Returns spans width
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Span[]} spans
         * @param {function} [collector]
         */
        getSpansWidth: function getSpansWidth(spans, collector) {
            var me = this,
                width = 0;
            for (var i = 0; i < spans.length; i++) {
                var span = spans[i];
                width += me.getTextWidth(span.value, span.fontSize, me.getFontForSpan(span), collector);
            }

            return width;
        },

        getLineOffsetX: function getLineOffsetX(align, width, containerWidth) {
            switch (align) {
                case 'right':
                    return containerWidth - width;
                case 'center':
                    return (containerWidth - width) / 2;
                default:
                    return 0;
            }
        },

        /**
         * Returns minimum font size
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Span} span
         * @returns {number}
         */
        getMinFontSize: function getMinFontSize(span) {
            var me = this,
                metrics = me.getMetricsForSpan(span),
                xHeight = metrics[5],
                unitsPerEm = metrics[1];
            return me.minimumCharacterHeight * unitsPerEm / xHeight;
        },

        /**
         * Returns char index at line length
         * DPO.text.LayoutManager#
         * @param {DPO.text.Line} line
         * @param {number} length
         * @returns {number}
         */
        getCharIndexAtLength: function getCharIndexAtLength(line, length) {
            var counter = 0,
                index = -1;

            function collector(width) {
                if (width <= length) {
                    index = counter;
                }
                counter++;
            }

            this.getSpansWidth(line.visibleSpans, collector);
            return index === -1 ? counter : index;
        },

        /**
         * Layout text block
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.TextBlock} textBlock
         * @param {boolean} [expanded]
         * @returns {DPO.text.Container[]}
         */
        layoutTextBlock: function layoutTextBlock(textBlock, expanded) {
            var width = textBlock.width / 20,
                height = textBlock.height / 20,
                textStyle = textBlock.textStyle,
                cls = this.layoutMap[textStyle.overflow] || DPO.text.WrapShrinkLayout;
            if (textBlock instanceof DPO.model.TextPath) {
                cls = DPO.text.TextPathLayout;
            }

            var layout = /** @type DPO.text.Layout*/ new cls(this, textBlock, expanded);
            return layout.performLayout(width, height);
        },

        /**
         * Layout plain text
         * @memberof DPO.text.LayoutManager#
         * @param {*} layoutCls
         * @param {string} text
         * @param {number} width
         * @param {number} height
         * @param {object} [style]
         * @param {string} [textAlign=left]
         * @param {string} [verticalAlign=top]
         * @returns {DPO.text.Container[]}
         */
        layoutPlainText: function layoutPlainText(layoutCls, text, width, height, style, textAlign, verticalAlign) {
            var me = this,
                textBlock = me.instantiate('TextBlock'),
                textFlow = me.instantiate('TextFlow'),
                paragraph = me.instantiate('Paragraph'),
                span = DPO.mixin(me.instantiate('Span'), style);
            span.value = text;

            paragraph.textAlign = textAlign || 'left';
            paragraph.spans.push(span);

            textFlow.verticalAlign = verticalAlign || 'top';
            textFlow.paragraphs.push(paragraph);

            textBlock.position = new DPO.model.Position();
            textBlock.text = new DPO.model.Text();
            textBlock.text.textFlow = textFlow;

            var layout = /** @type DPO.text.Layout*/ new layoutCls(this, textBlock);
            return layout.performLayout(width, height);
        },

        /**
         * Calculate text block geometry to fit inner text
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.TextBlock} textBlock
         * @param {?string} [verticalAlign]
         * @param {boolean} [expanded]
         * @returns {{position: DPO.model.Position, width: number, height: number}}
         */
        calculateTextBlockGeometry: function calculateTextBlockGeometry(textBlock, verticalAlign, expanded) {
            var me = this,
                g = {
                    position: me.clone(textBlock.position),
                    width: textBlock.width,
                    height: textBlock.height
                };
            if (textBlock instanceof DPO.model.TextPath) {
                return g;
            }

            verticalAlign = verticalAlign || textBlock.text.textFlow.verticalAlign;

            var containers = me.layoutTextBlock(textBlock, expanded),
                rotation = textBlock.rotation,
                dy = 0,
                height = 0;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                height += container.height;
            }

            // Add additional height in case glyph overflows own line
            // Do this staff for last line only
            var lc = containers[containers.length - 1],
                ll = lc.lines[lc.lines.length - 1];
            height += Math.max(0, ll.ascender - ll.descender - ll.height);
            height *= 20;

            switch (verticalAlign) {
                case 'middle':
                    dy = (textBlock.height - height) / 2;
                    break;
                case 'bottom':
                    dy = textBlock.height - height;
                    break;
            }

            var m = new DPO.math.Matrix();
            m.rotate(360 - rotation, 0, 0);

            var point = m.point(0, dy);
            g.position.x += point.x;
            g.position.y += point.y;
            g.height = height;
            return g;
        }
    });

    DPO.mixin(LayoutManager.prototype, {
        /**
         * Clears fonts cache
         * @memberof DPO.text.LayoutManager#
         */
        clearCache: function clearCache() {
            this.fonts = {};
        },

        /**
         * Returns font by its relative path
         * @memberof DPO.text.LayoutManager#
         * @param {string} url
         * @returns {object}
         */
        getFont: function getFont(url) {
            return this.fonts[url];
        },

        /**
         * Check if layout manager is ready to perform text layout
         * @memberof DPO.text.LayoutManager#
         * @returns {boolean}
         */
        isReady: function isReady() {
            return this.requestCount === 0;
        },

        /**
         * Decrements request count by one and notifies objects when all fonts are loaded
         * @param {object} font
         * @param {string} relative
         */
        decRequestCount: function decRequestCount(font, relative) {
            var me = this;
            if (font) {
                me.fonts[relative] = font;
            } else {
                delete me.fonts[relative];
            }
            me.requestCount--;
            if (me.requestCount === 0) {
                me.fallbackFont = me.fonts[me.fallbackFontPath];
                me.fire('fonts:loaded', [me]);
            }
        },

        /**
         * Collects fonts from specified spans collection
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Span[]} spans
         * @param {object} map
         */
        collectFontsForSpans: function loadFontsForParagraph(spans, map) {
            var dm = this.fontMetrics;
            for (var j = 0; j < spans.length; j++) {
                var span = spans[j],
                    metrics = dm.getMetricsForSpan(span),
                    url = dm.getFontURL(metrics, '');
                map[url] = metrics;
            }
        },

        /**
         * Collects fonts from specified paragraphs collection
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Paragraph[]} paragraphs
         * @param {object} map
         */
        collectFontsForParagraphs: function loadFontsForParagraph(paragraphs, map) {
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i];
                this.collectFontsForSpans(p.spans, map);
            }
        },

        /**
         * Collects fonts from specified text block collection
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.TextBlock[]} blocks
         * @param {object} map
         */
        collectFontsForTextBlocks: function loadFontsForTextBlocks(blocks, map) {
            for (var i = 0; i < blocks.length; i++) {
                var textBlock = blocks[i];
                this.collectFontsForParagraphs(textBlock.text.textFlow.paragraphs, map);
            }
        },

        /**
         * Loads font for specified project
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Project} project
         */
        collectFontsForProject: function collectFontsForProject(project) {
            var me = this,
                map = {},
                i, j;
            for (i = 0; i < project.pages.length; i++) {
                var page = project.pages[i];
                for (j = 0; j < page.panels.length; j++) {
                    var panel = page.panels[j];
                    me.collectFontsForTextBlocks(panel.textBlocks, map);
                    me.collectFontsForTextBlocks(panel.textPaths, map);
                }
            }

            for (i = 0; i < project.masterPanels.length; i++) {
                var mp = project.masterPanels[i];
                me.collectFontsForTextBlocks(mp.textBlocks, map);
                me.collectFontsForTextBlocks(mp.textPaths, map);
            }

            return map;
        },

        /**
         * Loads font for specified font family
         * @memberof DPO.text.LayoutManager#
         * @param {object} fontFamily
         * @returns {boolean}
         */
        loadFontFamily: function loadFontfamily(fontFamily) {
            var me = this,
                dm = me.fontMetrics,
                faces = Object.keys(fontFamily),
                map = {};
            for (var j = 0; j < faces.length; j++) {
                var face = faces[j],
                    metric = fontFamily[face],
                    url = dm.getFontURL(metric, '');
                map[url] = 1;
            }

            return me.loadFontMap(map);
        },

        /**
         * Loads font from fonts map
         * @memberof DPO.text.LayoutManager#
         * @param {object} map
         * @param {boolean} [cleanup]
         * @returns {boolean}
         */
        loadFontMap: function loadFontMap(map, cleanup) {
            var me = this,
                relative, absolute, i;

            map[me.fallbackFontFamily.Regular[0]] = me.fallbackFontFamily.Regular;

            if (cleanup) {
                var current = Object.keys(me.fonts);
                for (i = 0; i < current.length; i++) {
                    relative = current[i];
                    if (!map[relative]) {
                        delete me.fonts[relative];
                    }
                }
            }

            map = Object.keys(map);
            for (i = map.length - 1; i >= 0; i--) {
                relative = map[i];
                if (me.fonts[relative] !== undefined) {
                    map.splice(i, 1);
                } else {
                    me.fonts[relative] = false;
                }
            }

            me.requestCount += map.length;

            for (i = 0; i < map.length; i++) {
                relative = map[i];
                absolute = me.fontPath + relative;
                me.fontLoader.loadFont(relative, absolute);
            }

            return map.length > 0;
        },

        /**
         * Loads font for specified project
         * @memberof DPO.text.LayoutManager#
         * @param {DPO.model.Project} project
         * @param {boolean} [cleanup]
         */
        loadFonts: function loadFonts(project, cleanup) {
            var me = this,
                map = me.collectFontsForProject(project);
            return me.loadFontMap(map, cleanup);
        }

        ///**
        // * Removed web safe font from map
        // * @memberof DPO.text.LayoutManager#
        // * @param {object} map
        // */
        //excludeWhiteFont: function excludeWhiteFont(map) {
        //    var whiteList = [
        //        'arialbd.ttf',
        //        'ariali.ttf',
        //        'arialbi.ttf',
        //        'ariad.ttf',
        //        'arialuni.ttf',
        //        'georgia.ttf',
        //        'georgiab.ttf',
        //        'georgiai.ttf',
        //        'georgiaz.ttf',
        //        'verdana.ttf',
        //        'verdana-bold.ttf',
        //        'verdana-italic.ttf',
        //        'verdana-bolditalic.ttf',
        //        'times.ttf',
        //        'timesbd.ttf',
        //        'timesi.ttf',
        //        'timesbi.ttf'
        //    ];
        //    for (var i = 0; i < whiteList.length; i++) {
        //        delete map[whiteList[i]];
        //    }
        //},
        //
        ///**
        // * Prepares font for embedding
        // * @memberof DPO.text.LayoutManager#
        // * @param {object} map
        // * @param {function} callback
        // */
        //embeddedFonts: function embeddedFonts(map, callback) {
        //    var me = this,
        //        dm = me.fontMetrics,
        //        embedded = '',
        //        tpl = '',
        //        counter = 1, absolute, i;
        //    tpl += '@font-face {\n';
        //    tpl += '    font-family: "DPO8 {name}";\n';
        //    tpl += '    font-weight: {weight};\n';
        //    tpl += '    font-style: {style};\n';
        //    tpl += '    src: url("data:application/x-font-ttf;charset=utf-8;base64,{base64}");\n';
        //    tpl += '}\n';
        //
        //    function decRequestCount() {
        //        counter--;
        //        if (counter === 0) {
        //            callback(embedded);
        //        }
        //    }
        //
        //    function fn(fontFace, absolute) {
        //        var request = new XMLHttpRequest();
        //        request.open('get', absolute, true);
        //        request.responseType = 'arraybuffer';
        //        request.onload = function onLoad() {
        //            var arrayBuffer = request.response,
        //                base64 = DPO.base64ArrayBuffer(arrayBuffer);
        //            embedded += fontFace.replace('{base64}', base64) + '\n';
        //            decRequestCount();
        //        };
        //
        //        request.onerror = decRequestCount;
        //        request.send();
        //    }
        //
        //    me.excludeWhiteFont(map);
        //
        //    var keys = Object.keys(map),
        //        array = [];
        //    counter += keys.length;
        //    for (i = 0; i < keys.length; i++) {
        //        var key = keys[i];
        //        array.push(map[key]);
        //    }
        //
        //    for (i = 0; i < dm.names.length; i++) {
        //        var name = dm.names[i],
        //            faces = Object.keys(dm.metrics[name]);
        //        for (var j = 0; j < faces.length; j++) {
        //            var face = faces[j],
        //                metrics = dm.metrics[name][face];
        //            if (array.indexOf(metrics) !== -1) {
        //                var weight = face.indexOf('Bold') === -1 ? 'normal' : 'bold',
        //                    style = face.indexOf('Italic') === -1 ? 'normal' : 'italic',
        //                    fontFace = tpl;
        //                fontFace = fontFace.replace('{name}', name);
        //                fontFace = fontFace.replace('{weight}', weight);
        //                fontFace = fontFace.replace('{style}', style);
        //                absolute = me.fontPath + metrics[0];
        //                fn(fontFace, absolute);
        //            }
        //        }
        //    }
        //
        //    decRequestCount();
        //}
    });

    return LayoutManager;
});

DPO.def('text.Editor', function () {
    /**
     * @class DPO.text.Editor
     * @extends DPO.mixins.Observable
     * @extends DPO.mixins.TimeMachine
     * @extends DPO.model.Introspector
     * @memberof DPO.text
     * @param {DPO.model.TextBlock} textBlock
     * @param {number} recordIndex
     * @param {DPO.project.Context} context
     * @param {object} [cfg]
     * @property {DPO.model.TextBlock} originalTextBlock
     * @property {DPO.model.TextBlock} textBlock
     * @property {DPO.model.TextFlow} textFlow
     * @property {DPO.project.Transformer} pt
     * @property {string} textBlockId
     * @property {number} index
     * @fires text:changed
     * @fires style:changed
     * @constructor
     */
    function Editor(textBlock, recordIndex, context, cfg) {
        cfg = cfg || {};

        var me = this;
        me.index = recordIndex;
        me.context = context;
        me.binder = context.binder;
        me.pt = cfg.projectEditor || context.projectEditor;
        me.pt.on('time-travel', me.onTimeTravel, me);
        me.pt.on('broke:reference', me.onBrokeReference, me);
        me.pt.on('created:snapshot', me.onSnapshotCreated, me);
        me.pt.on(/changed:field:.*/, me.onFieldChanged, me);
        me.bindedTextBlock = me.binder.bindDataToTextBlock(me.clone(textBlock), me.index);
        me.record = me.binder.getRecord(me.index);
        me.changes = {
            wholeText: false,
            paragraphs: [],
            spans: []
        };
        me.resetObservable();
        me.initTimeMachine({
            textBlockId: null
        });
        me.registerTimeResource('textBlockId');
        me.storeTimeResource('textBlockId', textBlock.id, me.pt.getFieldCreationTime(textBlock));
        DPO.mixin(me, cfg || {});
    }

    DPO.inherit(Editor, DPO.model.Introspector);
    DPO.mixin(Editor.prototype, DPO.mixins.Observable, DPO.mixins.TimeMachine);
    DPO.mixin(Editor.prototype, {
        commitChanges: true,
        disableMailMergeEditing: false,

        spanEditable: function spanEditable() {
            var me = this;
            return me[me.disableMailMergeEditing ? 'spanMailMergeNotEditable' : 'spanMailMergeEditable'].apply(me, arguments);
        },

        /**
         * Check if span is editable (disableMailMergeEditing === false)
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Span} span
         * @returns {boolean}
         */
        spanMailMergeEditable: function spanMailMergeEditable(span) {
            return !span.serialNumberField;
        },

        /**
         * Check if span is editable (disableMailMergeEditing === true)
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Span} span
         * @returns {boolean}
         */
        spanMailMergeNotEditable: function spanMailMergeNotEditable(span) {
            return !span.serialNumberField && !span.mailMergeField;
        },

        /**
         * Begins transaction
         * @memberof DPO.text.Editor#
         * @returns {DPO.text.Editor}
         */
        beginTransaction: function beginTransaction() {
            var me = this,
                textBlock = me.clone(me.originalTextBlock);
            me.transactionTextBlock = me.binder.bindDataToTextBlock(textBlock, me.index);
            return me;
        },

        /**
         * Commits transaction
         * @memberof DPO.text.Editor#
         * @returns {*}
         */
        commitTransaction: function commitTransaction() {
            var me = this,
                pe = me.pt,
                provider = me.context.provider,
                dataSource = provider.getDataSource(),
                textBlock = me.textBlock,
                original = me.originalTextBlock,
                properties = me.context.selector.getFieldProperties(textBlock, 'content'),
                transactionTextBlock = me.transactionTextBlock;
            me.transactionTextBlock = null;
            if (me.commitChanges) {
                pe.beginUpdates();
                dataSource.setRecordData(me.index, me.record);
                pe.setProperties(original, properties);
                pe.endUpdates();

                textBlock = me.clone(me.originalTextBlock);
                me.bindedTextBlock = me.binder.bindDataToTextBlock(textBlock, me.index);
            } else {
                me.bindedTextBlock = transactionTextBlock;
            }

            return me;
        },

        /**
         * Rollback transaction
         * @memberof DPO.text.Editor#
         * @returns {DPO.text.Editor}
         */
        rollbackTransaction: function rollbackTransaction() {
            var me = this;
            me.transactionTextBlock = null;
            return me;
        },

        /**
         * Collect all binding data
         * @memberof DPO.text.Editor#
         * @param {object} record
         * @param {*} obj
         * @returns {object}
         */
        collectBindingData: function collectBindingData(record, obj) {
            function collectSpansBindingData(spans) {
                for (var i = 0; i < spans.length; i++) {
                    var s = spans[i];
                    if (s.mailMergeField) {
                        record[s.mailMergeField] = s.value;
                    }
                }
            }

            function collectTextFlowBindingData(textFlow) {
                var paragraphs = textFlow.paragraphs;
                for (var i = 0; i < paragraphs.length; i++) {
                    collectSpansBindingData(paragraphs[i].spans);
                }
            }

            function collect(elements) {
                for (var i = 0; i < elements.length; i++) {
                    var el = elements[i];
                    switch (el.constructor) {
                        case DPO.model.TextBlock:
                        case DPO.model.TextPath:
                            collectTextFlowBindingData(el.text.textFlow);
                            break;
                        case DPO.model.TextFlow:
                            collectTextFlowBindingData(el);
                            break;
                        case DPO.model.Paragraph:
                            collectSpansBindingData(el.spans);
                            break;
                        case DPO.model.Span:
                            collectSpansBindingData([el]);
                            break;
                    }
                }
            }

            collect(obj instanceof Array ? obj : [obj]);
            return record;
        },

        /**
         * Returns changed binding data
         * @memberof DPO.text.Editor#
         * @returns {object}
         */
        getBindingData: function getBindingData() {
            var me = this,
                paragraphs = me.textFlow.paragraphs,
                data = {};
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i];
                for (var j = 0; j < p.spans.length; j++) {
                    var span = p.spans[j];
                    if (span.mailMergeField) {
                        data[span.mailMergeField] = span.value;
                    }
                }
            }
            return data;
        },

        /**
         * Normalize edit changes (remove duplications)
         * @memberof DPO.text.Editor#
         * @returns {DPO.text.Editor}
         */
        normalizeChanges: function normalizeChanges() {
            var me = this,
                changes = me.changes,
                index, i;
            if (changes.wholeText) {
                changes.paragraphs = [];
                changes.spans = [];
            }

            for (i = changes.paragraphs.length - 1; i >= 0; i--) {
                index = changes.paragraphs.indexOf(changes.paragraphs[i]);
                if (index !== i) {
                    changes.paragraphs.splice(i, 1);
                }
            }

            for (i = changes.spans.length - 1; i >= 0; i--) {
                index = changes.spans.indexOf(changes.spans[i]);
                if (index !== i) {
                    changes.spans.splice(i, 1);
                }
            }

            return me;
        },

        /**
         * Fires text:changed event
         * @memberof DPO.text.Editor#
         * @returns {DPO.text.Editor}
         */
        notifyTextChanged: function notifyTextChanged() {
            var me = this;
            me.normalizeChanges().fire('text:changed', [me, me.changes]);
            me.changes = {
                wholeText: false,
                paragraphs: [],
                spans: []
            };
            return me;
        },

        /**
         * Fires style:changed event
         * @memberof DPO.text.Editor#
         * @returns {DPO.text.Editor}
         */
        notifyStyleChanged: function notifyStyleChanged() {
            var me = this;
            me.normalizeChanges().fire('style:changed', [me, me.changes]);
            me.changes = {
                wholeText: false,
                paragraphs: [],
                spans: []
            };
            return me;
        },

        /**
         * Return paragraph position
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Paragraph} p
         * @returns {number}
         */
        getParagraphIndex: function getParagraphIndex(p) {
            var paragraphs = this.textFlow.paragraphs;
            return paragraphs.indexOf(p);
        },

        /**
         * Returns span position
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Span} span
         * @returns {?{paragraphIndex: *, paragraph: *, spanIndex: *, span: *}}
         */
        getSpanPosition: function getSpanPosition(span) {
            var me = this,
                paragraphs = me.textFlow.paragraphs,
                textOffset = 0;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i],
                    index = p.spans.indexOf(span);
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j];
                    if (s === span) {
                        return {
                            textOffset: textOffset,
                            paragraphIndex: i,
                            paragraph: p,
                            spanIndex: index,
                            span: span
                        };
                    } else {
                        textOffset += s.value.length;
                    }
                }

                textOffset++;
            }

            return null;
        },

        /**
         * Returns plain text
         * @memberof DPO.text.Editor#
         * @returns {string}
         */
        getPlainText: function getPlainText() {
            return this.textBlock.getPlainText();
        },

        /**
         * Returns binding position in plain text
         * @memberof DPO.text.Editor#
         * @returns {object[]}
         */
        getBindingPositions: function getBindingPositions() {
            var positions = [],
                pos = 0,
                paragraphs = this.textFlow.paragraphs;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i];
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j];
                    if (s.serialNumberField || s.mailMergeField) {
                        positions.push({
                            span: s,
                            start: pos,
                            end: pos + s.value.length
                        });
                    }

                    pos += s.value.length;
                }

                pos++;
            }

            return positions;
        },

        /**
         * Returns paragraph by char index
         * @memberof DPO.text.Editor#
         * @param {number} charIndex
         * @returns {*}
         */
        splitPosition: function splitPosition(charIndex) {
            if (charIndex < 0) {
                return null;
            }

            var paragraphs = this.textFlow.paragraphs;
            for (var i = 0; i < paragraphs.length; i++, charIndex--) {
                var p = paragraphs[i],
                    lineLength = 0;
                for (var j = 0; j < p.spans.length; j++) {
                    var s = p.spans[j],
                        l = s.value.length;
                    if (charIndex <= l + lineLength) {
                        return {
                            line: i,
                            char: charIndex,
                            newLineChar: (j === p.spans.length - 1) && (charIndex === l + lineLength),
                            span: s,
                            spanIndex: j,
                            spanChar: charIndex - lineLength,
                            paragraph: paragraphs[i],
                            paragraphIndex: i
                        };
                    }
                    lineLength += l;
                }

                charIndex -= lineLength;
            }

            return null;
        },

        /**
         * Convert line/column position to plain text positions
         * @memberof DPO.text.Editor#
         * @param {number} line
         * @param {number} index
         * @returns {number}
         */
        combinePosition: function combinePosition(line, index) {
            if (line < 0) {
                return 0;
            }

            var paragraphs = this.textFlow.paragraphs,
                total = 0,
                pos = 0;
            for (var i = 0; i < paragraphs.length; i++) {
                var p = paragraphs[i];
                total++;
                if (i < line) {
                    pos++;
                }

                for (var j = 0; j < p.spans.length; j++) {
                    if (i < line) {
                        pos += p.spans[j].value.length;
                    }

                    total += p.spans[j].value.length;
                }
            }

            pos = Math.max(0, pos + index);
            pos = Math.min(total - 1, pos);
            return pos;
        },

        /**
         * Normalizes paragraphs & spans
         * @memberof DPO.text.Editor#
         * @returns {DPO.text.Editor}
         */
        normalize: function normalize() {
            var me = this,
                paragraphs = me.textFlow.paragraphs,
                allSpans = [],
                p, j, s1, s2;
            for (var i = 0; i < paragraphs.length; i++) {
                p = paragraphs[i];
                for (j = p.spans.length - 1; j > 0; j--) {
                    s1 = p.spans[j];
                    s2 = p.spans[j - 1];
                    if (s2 && s1.canMergeWith(s2)) {
                        s2.value += s1.value;
                        p.spans.splice(j, 1);
                        me.changes.wholeText = true;
                    }
                }

                for (j = p.spans.length - 1; j >= 0; j--) {
                    s1 = p.spans[j];
                    // Remove all empty spans & keep at least one span per paragraph
                    if (!s1.mailMergeField && !s1.serialNumberField && !s1.value && (p.spans.length > 1)) {
                        p.spans.splice(j, 1);
                        me.changes.wholeText = true;
                    }
                }

                allSpans = allSpans.concat(p.spans);
            }

            me.binder.bindDataToSpans(allSpans, me.index, me.record);
            return me;
        },

        /**
         * Force span merge
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Span[]} spans
         * @param {DPO.model.Span[]} array
         */
        forceMerge: function forceMerge(spans, array) {
            var index = spans.indexOf(array[0]),
                length = array.length;
            for (var i = array.length - 1; i > 0; i--) {
                var s1 = array[i],
                    s2 = array[i - 1];
                if (s2 && s1.canMergeWith(s2, true)) {
                    s2.value += s1.value;
                    array.splice(i, 1);
                }
            }

            spans.splice.apply(spans, [index, length].concat(array));
        },

        /**
         * Returns paragraphs for specified position
         * @memberof DPO.text.Editor#
         * @param {number} [start]
         * @param {number} [end]
         * @returns {DPO.model.Paragraph[]}
         */
        getParagraphs: function getParagraphs(start, end) {
            var me = this,
                paragraphs = [],
                sp = me.splitPosition(start),
                ep = me.splitPosition(end);
            sp = sp || me.splitPosition(0);
            ep = ep || me.splitPosition(me.getPlainText().length);

            for (var i = sp.paragraphIndex; i <= ep.paragraphIndex; i++) {
                var p = me.textFlow.paragraphs[i];
                paragraphs.push(p);
            }

            return paragraphs;
        },

        /**
         * Returns spans for specified position
         * @memberof DPO.text.Editor#
         * @param {number} start
         * @param {number} end
         * @returns {DPO.model.Span[]}
         */
        getSpans: function getSpans(start, end) {
            var me = this,
                spans = [],
                sp = me.splitPosition(start),
                ep = me.splitPosition(end);
            sp = sp || me.splitPosition(0);
            ep = ep || me.splitPosition(me.getPlainText().length);

            for (var i = sp.paragraphIndex; i <= ep.paragraphIndex; i++) {
                var p = me.textFlow.paragraphs[i],
                    s = i === sp.paragraphIndex ? sp.spanIndex : 0,
                    e = i === ep.paragraphIndex ? ep.spanIndex : p.spans.length - 1;
                for (var j = s; j <= e; j++) {
                    spans.push(p.spans[j]);
                }
            }

            return spans;
        },

        /**
         * Applies text alignment for specified position
         * @memberof DPO.text.Editor#
         * @param {string} alignment
         * @param {number} start
         * @param {number} length
         * @returns {DPO.text.Editor}
         */
        applyTextAlignment: function applyTextAlignment(alignment, start, length) {
            var me = this.beginTransaction(),
                paragraphs = me.getParagraphs(start, start + length);
            for (var i = 0; i < paragraphs.length; i++) {
                paragraphs[i].textAlign = alignment;
                me.changes.paragraphs.push(paragraphs[i]);
            }

            return me.commitTransaction().notifyStyleChanged();
        },

        /**
         * Applies vertical alignment for textFlow
         * @memberof DPO.text.Editor#
         * @param {string} alignment
         * @returns {DPO.text.Editor}
         */
        applyVerticalTextAlignment: function applyVerticalTextAlignment(alignment) {
            var me = this;
            me.beginTransaction();
            me.textFlow.verticalAlign = alignment;
            me.changes.wholeText = true;
            return me.commitTransaction().notifyStyleChanged();
        },

        /**
         * Applies rotate sense for textBlock
         * @memberof DPO.text.Editor#
         * @param {string} type
         * @returns {DPO.text.Editor}
         */
        applyRotateSense: function applyRotateSense(type) {
            var me = this;
            me.beginTransaction();
            me.textBlock.rotateSense = type;
            me.changes.wholeText = true;
            return me.commitTransaction().notifyStyleChanged();
        },

        /**
         * Applies text overflow method
         * @memberof DPO.text.Editor#
         * @param {string} type
         * @returns {DPO.text.Editor}
         */
        applyTextOverflow: function applyTextOverflow(type) {
            var me = this;
            me.beginTransaction();
            me.textBlock.textStyle.overflow = type;
            me.changes.wholeText = true;
            return me.commitTransaction().notifyStyleChanged();
        },

        /**
         * Normalizes style
         * @param {object} style
         */
        normalizeStyle: function normalizeStyle(style) {
            var s = DPO.mixin({}, style),
                color = s.color;
            delete s.color;

            if (color && color instanceof DPO.model.Color) {
                s.color = color.css;
                s.spotColor = color.spot;
            }

            if (style.fontSize !== undefined) {
                s.fontSize -= 0;
            }

            return s;
        },

        /**
         * Applies text style for specified position
         * @memberof DPO.text.Editor#
         * @param {object} style Style to apply
         * @param {number} index Char index
         * @param {number} length Text length to remove
         */
        applyStyle: function applyStyle(style, index, length) {
            var me = this.beginTransaction(),
                sp = me.splitPosition(index),
                ep = me.splitPosition(index + length),
                span, value, rest;
            if (sp == null) {
                return me.rollbackTransaction();
            }

            style = me.normalizeStyle(style);
            ep = ep || me.splitPosition(me.getPlainText().length);
            if (sp.span === ep.span) {
                if (sp.span.serialNumberField || sp.span.mailMergeField) {
                    DPO.mixin(sp.span, style);
                    me.changes.spans.push(sp.span);
                } else {
                    value = sp.span.value;
                    sp.span.value = value.substr(0, sp.spanChar);

                    span = DPO.mixin(me.clone(sp.span), style);
                    span.value = value.substr(sp.spanChar, length);

                    rest = me.clone(ep.span);
                    rest.value = value.substr(ep.spanChar);

                    ep.paragraph.spans.splice(ep.spanIndex + 1, 0, rest);
                    sp.paragraph.spans.splice(sp.spanIndex + 1, 0, span);
                    me.changes.wholeText = true;
                }

                return me.normalize().commitTransaction().notifyStyleChanged();
            }

            for (var i = sp.paragraphIndex; i <= ep.paragraphIndex; i++) {
                var p = me.textFlow.paragraphs[i],
                    s = i === sp.paragraphIndex ? sp.spanIndex + 1 : 0,
                    e = i === ep.paragraphIndex ? ep.spanIndex : p.spans.length;
                for (var j = s; j < e; j++) {
                    span = p.spans[j];
                    value = span.value;
                    DPO.mixin(span, style);
                    span.value = value;
                    me.changes.spans.push(span);
                }
            }

            if (ep.span.serialNumberField || sp.span.mailMergeField) {
                DPO.mixin(ep.span, style);
                me.changes.spans.push(ep.span);
            } else {
                value = ep.span.value;
                ep.span.value = value.substr(ep.spanChar);

                span = DPO.mixin(me.clone(ep.span), style);
                span.value = value.substr(0, ep.spanChar);
                ep.paragraph.spans.splice(ep.spanIndex, 0, span);

                me.changes.wholeText = true;
            }

            if (sp.span.serialNumberField || sp.span.mailMergeField) {
                DPO.mixin(sp.span, style);
                me.changes.spans.push(sp.span);
            } else {
                value = sp.span.value;
                sp.span.value = value.substr(0, sp.spanChar);

                span = DPO.mixin(me.clone(sp.span), style);
                span.value = value.substr(sp.spanChar, length);
                sp.paragraph.spans.splice(sp.spanIndex + 1, 0, span);

                me.changes.wholeText = true;
            }

            return me.normalize().commitTransaction().notifyStyleChanged();
        },

        /**
         * Removes text
         * @memberof DPO.text.Editor#
         * @param {number} index
         * @param {number} count
         * @returns {number}
         */
        removeText: function removeText(index, count) {
            count = Math.max(count, 0);
            if (count === 0) {
                return 0;
            }

            var me = this,
                sp = me.splitPosition(index),
                ep = me.splitPosition(index + count);
            if (sp == null) {
                return 0;
            }

            function calculateOffset() {
                me.normalize();
                var pos = me.getSpanPosition(sp.span);
                return pos ? pos.textOffset - index + sp.spanChar : 0;
            }

            function setValue(span, value) {
                if (value === span.value) {
                    return;
                }

                if (me.spanEditable(sp.span)) {
                    span.value = value;
                } else {
                    span.value = '';
                    delete span.serialNumberField;
                    delete span.mailMergeField;
                }

                if (span.mailMergeField) {
                    var record = me.collectBindingData({}, span);
                    DPO.mixin(me.record, record);
                }
            }

            if (ep == null) {
                setValue(sp.span, sp.span.value.substr(0, sp.spanChar));
                sp.paragraph.spans.splice(sp.spanIndex + 1, sp.paragraph.spans.length);
                me.textFlow.paragraphs.splice(sp.paragraphIndex + 1, me.textFlow.paragraphs.length);
                me.changes.spans.push(sp.span);
                return calculateOffset();
            }

            if (sp.span === ep.span) {
                var v = sp.span.value;
                setValue(sp.span, v.substr(0, sp.spanChar) + v.substr(sp.spanChar + count));
                me.changes.spans.push(sp.span);
                return calculateOffset();
            }

            setValue(sp.span, sp.span.value.substr(0, sp.spanChar));
            setValue(ep.span, ep.span.value.substr(ep.spanChar));

            me.changes.spans.push(sp.span);
            me.changes.spans.push(ep.span);
            me.changes.paragraphs.push(sp.paragraph);

            if (sp.paragraph === ep.paragraph) {
                sp.paragraph.spans.splice(sp.spanIndex + 1, ep.spanIndex - sp.spanIndex - 1);
                me.changes.wholeText = true;
                return calculateOffset();
            }

            sp.paragraph.spans.splice(sp.spanIndex + 1, sp.paragraph.spans.length);
            ep.paragraph.spans.splice(0, ep.spanIndex);
            sp.paragraph.spans = sp.paragraph.spans.concat(ep.paragraph.spans);
            me.changes.paragraphs.push(ep.paragraph);

            var paragraphs = me.textFlow.paragraphs,
                array = [];
            for (var i = 0; i < paragraphs.length; i++) {
                if (sp.line >= i || i > ep.line) {
                    array.push(paragraphs[i]);
                } else {
                    me.changes.wholeText = true;
                }
            }

            me.textFlow.paragraphs = array;
            return calculateOffset();
        },

        /**
         * Inserts spans to specified index.
         * @param {number} index
         * @param {DPO.model.Span[]} spans
         * @return {number}
         */
        insertSpans: function insertSpans(index, spans) {
            var me = this.beginTransaction(),
                sp = me.splitPosition(index),
                args = null,
                clone;
            if (sp == null || !spans || spans.length === 0) {
                me.rollbackTransaction();
                return -1;
            }

            //noinspection IfStatementWithTooManyBranchesJS
            if (!sp.span.serialNumberField && !sp.span.mailMergeField) {
                var v = sp.span.value;
                sp.span.value = v.substr(0, sp.spanChar);

                clone = me.clone(sp.span);
                clone.value = v.substr(sp.spanChar);

                args = [sp.spanIndex + 1, 0].concat(spans);
                args.push(clone);
            } else if (sp.spanChar === sp.span.value.length) {
                args = [sp.spanIndex + 1, 0].concat(spans);
            } else if (sp.spanChar === 0) {
                args = [sp.spanIndex, 0].concat(spans);
            } else {
                var pos = sp.spanIndex + (sp.spanChar * 2 < sp.span.value.length ? 0 : 1);
                args = [pos, 0].concat(spans);
            }

            var pss = sp.paragraph.spans;
            pss.splice.apply(pss, args);

            var spanPos = me.getSpanPosition(args[args.length - 1]);
            me.changes.wholeText = true;
            me.normalize().commitTransaction().notifyTextChanged();
            return spanPos.textOffset + spanPos.span.value.length;
        },

        /**
         * Insert/remove value
         * @memberof DPO.text.Editor#
         * @param {number} index Char index
         * @param {number} count Count to remove
         * @param {string|DPO.model.Span|DPO.model.Span[]} [value] Value to insert
         * @returns {number}
         */
        spliceText: function spliceText(index, count, value) {
            var me = this;
            me.beginTransaction();

            var ep = me.splitPosition(index + count),
                sp = me.splitPosition(index),
                offset = me.removeText(index, count),
                valueSnaps = [],
                clone;
            if (sp == null || !value) {
                me.normalize().commitTransaction().notifyTextChanged();
                return offset;
            }

            if (value instanceof Array) {
                valueSnaps = value;
            } else if (value instanceof DPO.model.Span) {
                valueSnaps = [value];
            } else if (typeof value === 'string') {
                var styleSpan = ep ? ep.span : sp.span;
                clone = me.clone(sp.span);
                clone.value = value;
                clone.copyStyle(styleSpan);
                if (!me.spanEditable(clone)) {
                    delete clone.serialNumberField;
                    delete clone.mailMergeField;
                }
                valueSnaps = [clone];
            }

            var spans = sp.paragraph.spans,
                forceMerge = me.spanEditable(sp.span) && !!sp.span.mailMergeField,
                args = null, pos;
            //noinspection IfStatementWithTooManyBranchesJS
            if (me.spanEditable(sp.span)) {
                var v = sp.span.value;
                sp.span.value = v.substr(0, sp.spanChar);

                clone = me.clone(sp.span);
                clone.value = v.substr(sp.spanChar);

                args = [sp.spanIndex + 1, 0].concat(valueSnaps);
                args.push(clone);
            } else if (sp.spanChar === sp.span.value.length) {
                args = [sp.spanIndex + 1, 0].concat(valueSnaps);
            } else if (sp.spanChar === 0) {
                args = [sp.spanIndex, 0].concat(valueSnaps);
            }

            if (args) {
                spans.splice.apply(spans, args);
                if (forceMerge) {
                    me.forceMerge(spans, [sp.span].concat(args.slice(2)));
                    var record = me.collectBindingData({}, sp.span);
                    DPO.mixin(me.record, record);
                }
                me.changes.wholeText = true;
                me.normalize().commitTransaction().notifyTextChanged();
            }

            pos = me.getSpanPosition(sp.span);
            return pos ? (pos.textOffset - index + sp.spanChar) : 0;
        },

        /**
         * Overrides paragraphs
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Paragraph[]} paragraphs
         */
        overrideParagraphs: function overrideParagraphs(paragraphs) {
            var me = this;
            me.beginTransaction();
            me.textFlow.paragraphs = me.clone(paragraphs);
            me.changes.wholeText = true;
            me.normalize().commitTransaction().notifyTextChanged();
        },

        /**
         * Appends paragraphs to text block
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Paragraph[]} paragraphs
         */
        appendParagraph: function appendParagraph(paragraphs) {
            var me = this;
            me.beginTransaction();
            var ps = me.textFlow.paragraphs;
            ps.push.apply(ps, paragraphs);
            me.changes.wholeText = true;
            me.normalize().commitTransaction().notifyTextChanged();
        },

        /**
         * Inserts new paragraph
         * @memberof DPO.text.Editor#
         * @param {number} index Paragraph position
         * @param {number} count Count of characters to remove
         * @param {DPO.model.Paragraph[]} [paragraphsToAdd]
         */
        insertParagraph: function insertParagraph(index, count, paragraphsToAdd) {
            var me = this;
            me.beginTransaction();
            me.spliceText(index, count, '');

            var pos = me.splitPosition(index),
                clone;
            if (pos == null) {
                me.commitTransaction();
                return;
            }

            paragraphsToAdd = me.clone(paragraphsToAdd || []);

            var span = pos.span,
                special = span.serialNumberField || span.mailMergeField;
            if (!special || pos.spanChar === span.value.length || pos.spanChar === 0) {
                clone = me.clone(pos.paragraph);
                clone.spans.splice(0, pos.spanIndex);
                clone.spans[0].value = span.value.substr(pos.spanChar);
                if (pos.spanChar === 0) {
                    delete span.serialNumberField;
                    delete span.mailMergeField;
                }

                if (pos.spanChar === span.value.length) {
                    delete clone.spans[0].serialNumberField;
                    delete clone.spans[0].mailMergeField;
                }

                span.value = span.value.substr(0, pos.spanChar);
                pos.paragraph.spans.splice(pos.spanIndex + 1, pos.paragraph.spans.length);

                var args = [pos.paragraphIndex + 1, 0],
                    ps = me.textFlow.paragraphs,
                    p;
                for (var i = 0; i < paragraphsToAdd.length; i++) {
                    p = paragraphsToAdd[i];
                    for (var j = 0; j < p.spans.length; j++) {
                        p.spans[j].copyStyle(span);
                    }
                    args.push(p);
                }

                args.push(clone);
                ps.splice.apply(ps, args);
            }

            me.changes.wholeText = true;
            me.normalize().commitTransaction().notifyTextChanged();
        },


        /**
         * Clones spans & removes all data binding properties
         * @memberof DPO.text.Editor#
         * @param {DPO.model.Span} span
         * @param {string} [value]
         * @returns {DPO.model.Span}
         */
        cloneSpan: function cloneSpan(span, value) {
            var result = this.clone(span);
            result.value = value === undefined ? result.value : value;
            delete result.serialNumberField;
            delete result.mailMergeField;
            delete result.mailMergeId;
            return result;
        },

        onTimeTravel: function onTimeTravel(pt, timestamp) {
            var me = this;
            me.timeTravel(timestamp);

            var original = me.originalTextBlock;
            if (original) {
                me.bindedTextBlock = me.binder.bindDataToTextBlock(me.clone(original), me.index);
                me.fire('text:restored', [me]);
            } else {
                me.fire('text:destroyed', [me]);
            }
        },

        onBrokeReference: function onBrokeReference(panel, changes) {
            var me = this,
                id = me.textBlockId;
            for (var i = 0; i < changes.length; i++) {
                var c = changes[i];
                if (c.masterField.id === id) {
                    me.timeTravel();
                    me.storeTimeResource('textBlockId', c.panelField.id);
                    return;
                }
            }
        },

        onSnapshotCreated: function onSnapshotCreated() {
            this.forgetFuture();
        },

        onFieldChanged: function onFieldChanged(fields) {
            var me = this;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (f.id === me.originalTextBlock.id) {
                    me.bindedTextBlock = me.binder.bindDataToTextBlock(me.clone(f), me.index);
                    return;
                }
            }
        },

        destroy: function destroy() {
            var me = this;
            me.resetObservable();
            me.pt.un('broke:reference', me.onBrokeReference, me);
            me.pt.un('created:snapshot', me.onSnapshotCreated, me);
            me.pt.un('time-travel', me.onTimeTravel, me);
            me.pt.un(/changed:field:.*/, me.onFieldChanged, me);
        }
    });

    Object.defineProperty(Editor.prototype, 'originalTextBlock', {
        get: function get() {
            var me = this,
                id = me.lookupTimeResource('textBlockId');
            return me.context.selector.getField(id);
        }
    });

    Object.defineProperty(Editor.prototype, 'textBlock', {
        get: function get() {
            var me = this;
            return me.transactionTextBlock || me.bindedTextBlock;
        }
    });

    Object.defineProperty(Editor.prototype, 'textBlockId', {
        get: function get() {
            return this.lookupTimeResource('textBlockId');
        }
    });

    Object.defineProperty(Editor.prototype, 'textFlow', {
        get: function get() {
            return this.textBlock.text.textFlow;
        }
    });

    return Editor;
});

DPO.def('text.UnitConverter', function () {
    /**
     * Create new Converter instance
     * @param locale - DPO.fc.Locale instance
     * @param value - value which we want convert
     * @constructor
     */
    function UnitConverter(locale, value) {
        var me = this;

        me.locale = locale;
        me.value = parseFloat(value) || 0;
        me.convertFromUnit = UnitConverter.DEFAULT_UNIT;
    }

    DPO.mixin(UnitConverter.prototype, {
        /**
         * Sets unit which we want convert from
         * @param fromUnit - unit which we want convert to (ex. mm, inch ..)
         * @returns {object}
         */
        from: function from(fromUnit) {
            var me = this;

            me.convertFromUnit = UnitConverter.getUnitKey(fromUnit);

            return me;
        },

        /**
         * Convert to passed unit
         * @param toUnit - unit which we want convert from (ex. mm, inch ..)
         * @param options - conversion options
         * @returns {string}
         */
        to: function to(toUnit, options) {
            var me = this;

            me.convertToUnit = UnitConverter.getUnitKey(toUnit);

            return me.calculate(options);
        },

        /**
         * Convert to current measurement system unit
         * @param options - conversion options
         * @returns {string}
         */
        toLocale: function toLocale(options) {
            var me = this;

            me.convertToUnit = UnitConverter.getUnitByMeasurementSystems(me.locale.measurementSystem);

            return me.calculate(options);
        },

        /**
         * Calculate conversion
         * @param options - conversion options
         * @returns {string}
         */
        calculate: function calculate(options) {
            var me = this,
                proportion = UnitConverter.proportions[me.convertFromUnit][me.convertToUnit],
                unitLabel = '';

            options = DPO.mixin({},
                UnitConverter.defaultOptions,
                options || {}
            );

            switch (proportion.operation) {
                case 'divide':
                    me.value = UnitConverter.preciseDivision(me.value, proportion.value);
                    break;

                case 'multiply':
                    me.value = UnitConverter.preciseMultiplication(me.value, proportion.value);
                    break;
            }

            // prevent exponential number
            if (options.label) {
                unitLabel = UnitConverter.getUnitLabel(me.value, me.convertToUnit, options.label);
            }

            switch (options.transform) {
                case 'round':
                    me.value = options.transformValue ? UnitConverter.decimalRound(me.value, options.transformValue) : Math.round(me.value);
                    break;

                case 'commonFraction':
                    me.value = UnitConverter.convertToCommonFraction(me.value, options.transformValue);
                    break;
            }

            return me.value + unitLabel;
        }
    });

    DPO.mixin(UnitConverter, {
        SYSTEM_IMPERIAL: 'imperial',
        SYSTEM_METRIC: 'metric',
        DEFAULT_UNIT: 'TW',

        units: {
            TW: ['twip', 'twip', 'twips'],
            MM: ['mm', 'millimeter', 'millimeters'],
            INCH: ['"', 'inch', 'inches']
        },

        defaultOptions: {
            label: true,
            transform: 'none'
        },

        proportions: {
            INCH: {
                TW: {
                    operation: 'multiply',
                    value: 1440
                },
                MM: {
                    operation: 'multiply',
                    value: 25.40005
                }
            },
            MM: {
                TW: {
                    operation: 'divide',
                    value: 0.017639
                },
                INCH: {
                    operation: 'divide',
                    value: 25.40005
                }
            },
            TW: {
                MM: {
                    operation: 'multiply',
                    value: 0.017639
                },
                INCH: {
                    operation: 'divide',
                    value: 1440
                }
            }
        },

        /**
         * Get unit key by label
         * @param unit - unit label
         * @returns {string}
         */
        getUnitKey: function getUnitKey(unit) {
            var unitKey = null;

            for (var key in UnitConverter.units) {
                if (UnitConverter.units.hasOwnProperty(key) && UnitConverter.units[key].indexOf(unit) !== -1) {
                    unitKey = key;
                    break;
                }
            }

            return unitKey;
        },

        /**
         * Return measurement system unit
         * @param system - measurement system
         * @returns {string}
         */
        getUnitByMeasurementSystems: function getUnitByMeasurementSystems(system) {
            switch (system) {
                case UnitConverter.SYSTEM_IMPERIAL:
                    return 'INCH';
                default:
                    return 'MM';
            }
        },

        /**
         * Create unit label base on type, conversion result
         * @param result - conversion result
         * @param unit - unit
         * @param labelType - labelType (full, abbr)
         * @returns {string}
         */
        getUnitLabel: function getUnitLabel(result, unit, labelType) {
            var label = '',
                labels = UnitConverter.units[unit];

            if (labelType === 'full') {
                label = (result > 1 ? labels[2] : labels[1]);
            } else {
                label = labels[0];
            }

            return label;
        },

        /**
         * Decimal round
         * @param value - value
         * @param decimals - digits after point
         * @returns {number}
         */
        decimalRound: function decimalRound(value, decimals) {
            return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);
        },

        /**
         * Convert decimal fraction to common fraction
         * @param value - number
         * @param maxDenominator - max denominator
         * @returns {*}
         */
        convertToCommonFraction: function convertToCommonFraction(value, maxDenominator) {
            var integer = Math.abs(parseInt(value)),
                sign = value < 0 ? '-' : '',
                fraction = {
                    nominator: UnitConverter.getDecimals(value),
                    denominator: Math.pow(10, UnitConverter.getCountOfDecimals(value))
                };

            maxDenominator = maxDenominator || 48;

            if (!fraction.nominator) {
                return sign + integer;
            }

            UnitConverter.reduceFraction(fraction);

            if (fraction.denominator > maxDenominator) {
                var proportion = UnitConverter.preciseDivision(fraction.denominator, maxDenominator);
                fraction.nominator = Math.round(UnitConverter.preciseDivision(fraction.nominator, proportion));
                fraction.denominator = maxDenominator;
            }

            if (!fraction.nominator) {
                return sign + integer;
            }

            UnitConverter.reduceFraction(fraction);

            return sign + (integer ? integer + ' ' : '') + fraction.nominator + '/' + fraction.denominator;
        },

        reduceFraction: function reduceFraction(fraction) {
            var gcd = UnitConverter.getGCD(fraction.nominator, fraction.denominator);

            fraction.nominator /= gcd;
            fraction.denominator /= gcd;

            return fraction;
        },

        /**
         * Multiplies two numbers without loosing precise
         * @param a - first multiplier
         * @param b - second multiplier
         * @returns {number}
         */
        preciseMultiplication: function preciseMultiplication(a, b) {
            var corrector = UnitConverter.getOperationCorrector(a, b);

            return (a * corrector) * (b * corrector) / corrector / corrector;
        },

        /**
         * Divides two numbers without loosing precise
         * @param a - first multiplier
         * @param b - second multiplier
         * @returns {number}
         */
        preciseDivision: function preciseDivision(a, b) {
            var corrector = UnitConverter.getOperationCorrector(a, b);

            return (a * corrector) / (b * corrector);
        },

        /**
         * Returns corrector operation on two numbers
         * @param a - number
         * @param b - number
         * @returns {number}
         */
        getOperationCorrector: function getOperationCorrector(a, b) {
            var countOfDecimals = Math.max(UnitConverter.getCountOfDecimals(a), UnitConverter.getCountOfDecimals(b));

            return Math.pow(10, countOfDecimals);
        },

        /**
         * Returns count of decimal digits
         * @param number
         * @returns {number}
         */
        getCountOfDecimals: function getCountOfDecimals(number) {
            var decimals = UnitConverter.getDecimals(number);

            return (decimals || '').length;
        },

        /**
         * Returns decimals of number
         * @param number
         * @returns {number}
         */
        getDecimals: function getDecimals(number) {
            var parts = (number + '').split('.') || [];

            return parts[1] || 0;
        },

        /**
         * Returns greatest common divide of two integer numbers
         * @param a - number
         * @param b - number
         * @returns {number}
         */
        getGCD: function getGCD(a, b) {
            var temp;

            while (b !== 0) {
                temp = b;
                b = a % b;
                a = temp;
            }

            return a;
        }
    });

    return function (locale) {
        return {
            convert: function convert(value) {
                return new UnitConverter(locale, value);
            },

            convertToLocale: function convertToLocale(value, options) {
                var me = this;

                return me.convert(value).toLocale(options);
            }
        };
    };
});
DPO.def('project.Context', function () {
    /**
     * Creates new context for project components
     * @class DPO.project.Context
     * @extends DPO.mixins.Observable
     * @memberof DPO.project
     * @param {DPO.model.Project} project
     * @param {DPO.text.LayoutManager} layoutManager
     * @param {DPO.project.Storage} [storage?]
     * @param {DPO.project.DataSourceProvider} [provider]
     * @property {DPO.model.Project} project
     * @property {DPO.text.LayoutManager} layoutManager
     * @property {DPO.project.Storage} storage
     * @property {DPO.project.DataSourceProvider} provider
     * @property {DPO.project.Transformer} projectTransformer
     * @property {DPO.project.Editor} projectEditor
     * @property {DPO.model.Selector} selector
     * @property {DPO.project.Binder} binder
     * @property {DPO.project.Validator} validator
     * @property {DPO.project.Filter} filter
     * @constructor
     */
    function Context(project, layoutManager, storage, provider) {
        var me = this;
        me.resetObservable();
        me._layoutManager = layoutManager;
        me._storage = storage || new DPO.project.Storage();
        me._provider = provider || new DPO.project.DataSourceProvider();
        me.project = project;
        me.filter = DPO.project.Filter.MatchAll;
    }

    DPO.mixin(Context.prototype, DPO.mixins.Observable, {
        /**
         * Handlers new snapshot
         * @memberof DPO.project.Context#
         * @param {DPO.project.Transformer} pt
         * @param {number} timestamp
         */
        onSnapshotCreated: function onSnapshotCreated(pt, timestamp) {
            var me = this;
            me.provider.forgetFuture();
            me.provider.timeTravel(timestamp);
            me.storage.resetUrlRedefinition();
        },

        /**
         * Disables data records when panels where removed
         * @memberof DPO.project.Context#
         * @param {DPO.model.Panel[]} panels
         * @param {number[]} indexes
         */
        onPanelsRemoved: function onPanelsRemoved(panels, indexes) {
            var ds = this.provider.getDataSource();
            ds.disableRecords(indexes, true);
        },

        /**
         * Updates time machine state
         * @memberof DPO.project.Context#
         * @param {DPO.project.Transformer} pt
         * @param {number} timestamp
         */
        onTimeTravel: function onTimeTravel(pt, timestamp) {
            var me = this;
            me.provider.timeTravel(timestamp);
            me.storage.resetUrlRedefinition();
        },

        /**
         * Invokes after project changing
         * @protected
         * @memberof DPO.project.Context#
         */
        afterProjectChanged: function afterProjectChanged() {
        }
    });

    Object.defineProperty(Context.prototype, 'layoutManager', {
        get: function get() {
            return this._layoutManager;
        }
    });

    Object.defineProperty(Context.prototype, 'storage', {
        get: function get() {
            return this._storage;
        }
    });

    Object.defineProperty(Context.prototype, 'provider', {
        get: function get() {
            return this._provider;
        }
    });

    Object.defineProperty(Context.prototype, 'projectTransformer', {
        get: function get() {
            return this._projectTransformer;
        }
    });

    Object.defineProperty(Context.prototype, 'projectEditor', {
        get: function get() {
            return this._projectEditor;
        }
    });

    Object.defineProperty(Context.prototype, 'selector', {
        get: function get() {
            return this._selector;
        }
    });

    Object.defineProperty(Context.prototype, 'binder', {
        get: function get() {
            return this._binder;
        }
    });

    Object.defineProperty(Context.prototype, 'validator', {
        get: function get() {
            return this._validator;
        }
    });

    Object.defineProperty(Context.prototype, 'project', {
        get: function get() {
            return this._project;
        },

        set: function set(value) {
            var me = this;
            if (me._project === value) {
                return;
            }

            if (me._project) {
                me._projectTransformer.resetObservable();
                me._projectEditor.resetObservable();
            }

            me._project = value;

            if (value) {
                me._projectTransformer = new DPO.project.Transformer(me.project);
                me._projectTransformer.on('created:snapshot', me.onSnapshotCreated, me);
                me._projectTransformer.on('time-travel', me.onTimeTravel, me);
                me._projectTransformer.on('removed:panels', me.onPanelsRemoved, me);

                me._projectEditor = new DPO.project.Editor(me._projectTransformer, null);
                me._selector = me.projectTransformer.selector;
                me._binder = new DPO.project.Binder(me.provider, null);
                me._binder.selector = me.selector;
                me._validator = new DPO.project.Validator(me.project, me.binder, me.layoutManager, me.selector, null);

                var recordsCount = me.provider.getDataSource().totalRecords();
                me._projectTransformer.adjustSheetForDataBinding(me._project.pages[0].panels[0], recordsCount);
            } else {
                me._projectTransformer = null;
                me._selector = null;
                me._binder = null;
                me._validator = null;
            }

            me.afterProjectChanged();
            me.fire('changed:project', [me, value]);
        }
    });

    return Context;
});
DPO.def('project.Storage', function () {
    /**
     * @class DPO.render.Storage
     * @extends DPO.mixins.Observable
     * @constructor
     */
    function Storage() {
        var me = this;
        me.resetObservable();
    }

    DPO.mixin(Storage.prototype, DPO.mixins.Observable);
    DPO.mixin(Storage.prototype, {
        /**
         * Check if all images are generated
         * @memberof DPO.bll.StubStorage#
         * @returns {boolean}
         */
        isReady: function isReady() {
            return true;
        },

        /**
         * Return URL for specified field's resource
         * @memberof DPO.bll.StubStorage#
         * @returns {string}
         */
        urlForField: function urlForField() {
            return  'data:image/svg+xml;base64,PD94bWw' +
                'gdmVyc2lvbj0iMS4wIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvM' +
                'jAwMC9zdmciIHZlcnNpb249IjEuMCIgdmlld0JveD0iMCAwIDMwMCAzMDAiID4' +
                '8Y2lyY2xlIGN4PSIxNTAiIGN5PSIxNTAiIHN0cm9rZT0iI0YwMCIgc3Ryb2tlL' +
                'XdpZHRoPSIzIiByPSIxNDAiIGZpbGw9Im5vbmUiLz48dGV4dCBzdHlsZT0idGV' +
                '4dC1hbmNob3I6bWlkZGxlO2ZpbGw6I0YwMDtmb250LXNpemU6MjRweDsiPjx0c' +
                '3BhbiB5PSIxMzAiIHg9IjE1MCI+Tk8gREFUQTwvdHNwYW4+PHRzcGFuIHk9IjE' +
                '3MCIgeD0iMTUwIj5BVkFJTEFCTEU8L3RzcGFuPjwvdGV4dD48L3N2Zz4=';
        },

        resetUrlRedefinition: function resetUrlRedefinition() {

        },

        redefineUrl: function redefineUrl() {

        }
    });
    return Storage;
});
DPO.def('project.DataSource', function () {
    /**
     * @class DPO.project.DataSource
     * @extends DPO.mixins.Observable
     * @memberof DPO.project
     * @constructor
     */
    function DataSource() {
        var me = this;
        me.resetObservable();
        me.initTimeMachine();
    }

    DPO.mixin(DataSource.prototype, DPO.mixins.Observable, DPO.mixins.TimeMachine);
    //noinspection JSUnusedLocalSymbols
    DPO.mixin(DataSource.prototype, {
        /**
         * Gets record data of specified index
         * @memberof DPO.project.DataSource#
         * @param {number} index
         * @returns {object}
         */
        getRecordData: function getRecordData(index) {
            return null;
        },

        /**
         * Sets record data for specified index
         * @memberof DPO.project.DataSource#
         * @param {number} index
         * @param {object} data
         */
        setRecordData: function setRecordData(index, data) {
        },

        /**
         * Disables/enables record by it's index
         * @memberof DPO.project.DataSource#
         * @param {number[]} records
         * @param {boolean} [disabled]
         */
        disableRecords: function disableRecords(records, disabled) {
        },

        /**
         * Returns total records count
         * @memberof DPO.project.DataSource#
         * @returns {number}
         */
        totalRecords: function totalRecords() {
            return 0;
        },

        /**
         * Returns clone of current data source
         * @memberof DPO.project.DataSource#
         * @returns {DPO.project.DataSource}
         */
        clone: function clone() {
            return new DataSource();
        }
    });

    return DataSource;
});

DPO.def('project.DataSourceProvider', function () {
    /**
     * @class DPO.project.DataSourceProvider
     * @extends DPO.mixins.Observable
     * @extends DPO.mixins.TimeMachine
     * @memberof DPO.project
     * @constructor
     */
    function DataSourceProvider() {
        var me = this;
        me.resetObservable();

        var fallback = {};
        fallback['data-source'] = {
            default: new DPO.project.DataSource()
        };
        me.initTimeMachine(fallback);
        me.registerTimeResource('data-source', me.lookupDataSource);
    }

    DPO.mixin(DataSourceProvider.prototype, DPO.mixins.Observable, DPO.mixins.TimeMachine);
    DPO.mixin(DataSourceProvider.prototype, {
        lookupDataSource: function lookupDataSource(state, name) {
            return state[name];
        },

        /**
         * Removed future state
         * @memberof DPO.mixins.DataSourceProvider#
         */
        forgetFuture: function forgetFuture() {
            DPO.mixins.TimeMachine.forgetFuture.apply(this, arguments);

            var ds = this.getDataSource();
            ds.forgetFuture();
        },

        /**
         * Changes current timestamp
         * @memberof DPO.mixins.TimeMachine#
         * @param {number} [timestamp]
         */
        timeTravel: function timeTravel(timestamp) {
            DPO.mixins.TimeMachine.timeTravel.apply(this, arguments);

            var ds = this.getDataSource();
            ds.timeTravel(timestamp);
        },

        /**
         * Forwards record changed event
         * @memberof DPO.project.DataSourceProvider#
         * @param {DPO.project.DataSource} dataSource
         * @param {number} index
         * @param {object} data
         */
        onRecordChanged: function onRecordChanged(dataSource, index, data) {
            this.fire('changed:data-source:record', [this, dataSource, index, data]);
        },

        /**
         * Gets data source for specified identifier
         * @memberof DPO.project.DataSourceProvider#
         * @param {string} [id=default]
         * @returns {DPO.project.DataSource}
         */
        getDataSource: function getDataSource(id) {
            return this.lookupTimeResource('data-source', id || 'default');
        },

        /**
         * Sets data source for specified identifier
         * @memberof DPO.project.DataSourceProvider#
         * @param {DPO.project.DataSource} dataSource
         * @param {string} [id=default]
         */
        setDataSource: function setDataSource(dataSource, id) {
            var me = this,
                ds = me.getDataSource(id);
            if (ds === dataSource) {
                return;
            }

            dataSource.on('changed:data-source:record', me.onRecordChanged, me);

            var obj = {};
            id = id || 'default';
            obj[id] = dataSource;
            me.forgetFuture();
            me.timeTravel();
            me.storeTimeResource('data-source', obj);
            me.fire('changed:data-source', [this, id, dataSource]);
        }
    });

    return DataSourceProvider;
});

DPO.def('project.Filter', function () {
    /**
     * @class DPO.project.Filter
     * @property {string[]} imagePlaceHolders
     * @property {string[]} textPlaceHolders
     * @param {object} [cfg]
     * @constructor
     */
    function Filter(cfg) {
        var me = this;
        cfg = cfg ||{};
        me.imagePlaceHolders = cfg.imagePlaceHolders || [];
        me.textPlaceHolders = cfg.textPlaceHolders || [];
    }

    DPO.mixin(Filter.prototype, {
        imagePlaceHolders: [],
        textPlaceHolders: [],

        /**
         * Check if field(s) matches filter criteria
         * @memberof DPO.project.Filter#
         * @param {DPO.model.Field} field
         * @returns {boolean}
         */
        matchField: function matchFields(field) {
            var me = this,
                isPlaceholder = false,
                textBlock, str, source;
            switch (field.constructor) {
                case DPO.model.TextBlock:
                case DPO.model.TextPath:
                    textBlock = /** @type DPO.model.TextBlock */field;
                    isPlaceholder = textBlock.containsDefaultText();
                    str = textBlock.getPlainText();
                    isPlaceholder = isPlaceholder || me.textPlaceHolders.indexOf(str) !== -1;
                    isPlaceholder = isPlaceholder && !textBlock.hasMergeData();
                    break;
                case DPO.model.Background:
                case DPO.model.Image:
                    source = field.source || '';
                    isPlaceholder = isPlaceholder || me.imagePlaceHolders.indexOf(source) !== -1;
                    break;
            }
            return !isPlaceholder;
        }
    });

    function trueFn() {
        return true;
    }

    /**
     * Match all filter
     * @memberof DPO.project.Filter
     * @type {DPO.project.Filter}
     */
    Filter.MatchAll = new Filter();
    Filter.MatchAll.matchField = trueFn;

    return Filter;
});

DPO.def('project.PrintFilter', function () {
    /**
     * @class DPO.project.PrintFilter
     * @property {string} type
     * @property {array} filterItems
     * @property {function} filter
     * @param {object} cfg
     * @constructor
     */
    function PrintFilter(cfg) {
        var me = this;
        this.cfg = cfg ||{};
        switch (cfg.type) {
            case 'panel':
                me.createPanelFilter(cfg);
                break;
            case 'page':
                me.createPageFilter(cfg);
                break;
            default:
                return null;
        }
    }

    DPO.mixin(PrintFilter.prototype, {

        pageFilterOptions : {
            front: 1,
            back: 0,
            all: true
        },

        /**
         * Generate panel filter
         * @memberof DPO.project.Filter#
         * @param {object} filterCfg
         * @returns {{type: *, filterBy: *, filter: filterFn}} DPO.project.PrintFilter
         */
        createPanelFilter: function createPanelFilter(filterCfg){
            function filterFn(project) {
                var pages = project.pages,
                    sheets = this.filterBy;
                for (var i = 0; sheets[i]; i++) {
                    var sheet = sheets[i],
                        array = [sheet.front, sheet.back];
                    for (var j = 0; array[j]; j++) {
                        var index = array[j].pageIndex,
                            hidden = array[j].arr,
                            page = pages[index];
                        for (var k = hidden.length - 1; k >= 0; k--) {
                            if (hidden[k]) {
                                page.panels.splice(k, 1);
                            }
                        }
                    }
                }
            }

            DPO.mixin(this,  {
                type: filterCfg.type,
                filterBy: filterCfg.filterBy,
                filter:filterFn
            });
        },

        /**
         * Generate panel filter
         * @memberof DPO.project.Filter#
         * @param {object} filterCfg
         * @returns {{type: *, filterBy: *, filter: filterFn}} DPO.project.PrintFilter
         */
        createPageFilter: function createPageFilter(filterCfg){
            function filterFn(project) {
                var me = this;
                var pages;
                if (me.filterBy === "all") {
                    return project;
                }

                pages = project.pages.filter(function (page, index){
                    return (index % 2) - me.pageFilterOptions[me.filterBy] ;
                });

                project.pages = pages;
                return project;
            }

            DPO.mixin(this,  {
                type: filterCfg.type,
                filterBy: filterCfg.filterBy,
                filter:filterFn
            });
        }
    });

    return PrintFilter;
});

DPO.def('project.Transformer', function () {
    var alignFunctions = {
        left: function left(f, base, bounds) {
            f.position.x += base.left - bounds.left;
        },
        center: function center(f, base, bounds) {
            f.position.x += base.cx - bounds.cx;
        },
        right: function right(f, base, bounds) {
            f.position.x += base.right - bounds.right;
        },
        top: function top(f, base, bounds) {
            f.position.y += base.top - bounds.top;
        },
        middle: function middle(f, base, bounds) {
            f.position.y += base.cy - bounds.cy;
        },
        bottom: function bottom(f, base, bounds) {
            f.position.y += base.bottom - bounds.bottom;
        }
    };

    function RemovedElement(array, element) {
        var index = array.indexOf(element);
        if (index !== -1) {
            array.splice(index, 1);
        }
    }

    /**
     * @param array
     * @param contentId
     * @returns {Array}
     * @objects[]
     */
    function RemovedByContentId(array, contentId) {
        var removed = [];
        for (var i = array.length - 1; i >= 0; i--) {
            if (array[i].contentId === contentId) {
                removed.push(array[i]);
                array.splice(i, 1);
            }
        }

        return removed;
    }

    /**
     * Extracts id number from string
     * @param {string} str
     * @returns {number}
     * @function
     */
    function ExtractId(str) {
        var regexp = /\d+/,
            res = regexp.exec(str);
        return res[0] - 0 || 0;
    }

    /**
     * Extracts max id number from fields array
     * @param array
     * @returns {Number}
     * @function
     */
    function ExtractMaxFieldId(array) {
        var id = Number.NEGATIVE_INFINITY;
        for (var i = 0; i < array.length; i++) {
            id = Math.max(id, ExtractId(array[i].id));
        }
        return id;
    }

    /**
     * @class DPO.project.Transformer
     * @extends DPO.model.Introspector
     * @extends DPO.mixins.Observable
     * @extends DPO.mixins.TimeMachine
     * @memberof DPO.project
     * @param {DPO.model.Project} project
     * @param {DPO.model.Selector} [selector]
     * @property {DPO.model.Project} project
     * @property {DPO.model.Selector} selector
     * @fires broke:reference
     * @fires restored:snapshot
     * @fires created:snapshot
     * @fires added:field
     * @fires deleted:field
     * @fires changed:field:geometry
     * @fires changed:field:style
     * @fires changed:field:content
     * @fires changed:field-order
     * @fires added:sheet
     * @fires removed:sheet
     * @fires changed:editOne
     * @constructor
     */
    function Transformer(project, selector) {
        var me = this;
        DPO.model.Introspector.call(me);
        me.project = project;
        me.selector = selector || new DPO.model.Selector(project);
        me.updateCounter = 0;
        me.idCounter = 0;
        me.pendingAccumulativeEvents = {};
        me.pendingPropertiesChanges = {};
        me.pendingSequentialEvents = [];
        me.initIdCounter();
        me.normalizeProject();
        me.resetObservable();
        me.clearHistory();
    }

    DPO.inherit(Transformer, DPO.model.Introspector);
    DPO.mixin(Transformer.prototype, DPO.mixins.Observable, DPO.mixins.TimeMachine);
    DPO.mixin(Transformer.prototype, {
        maxSnapshots: 50,
        sequenceCleanup: 300, // milliseconds

        /**
         * Returns field creation time
         * @memberof DPO.project.Transformer#
         * @param field
         * @returns {number}
         */
        getFieldCreationTime: function getFieldCreationTime(field) {
            var me = this,
                time = me.timeMachine.beginning;

            me.foreachSnapshot(function (state, timestamp) {
                var f = null;
                if (state.project) {
                    var selector = new DPO.model.Selector(state.project);
                    f = selector.getField(field.id);
                }

                if (f) {
                    time = timestamp;
                }

                return !!f;
            });
            return time;
        },

        /**
         * Performs sequence cleanup
         * @memberof DPO.mixins.TimeMachine#
         * @param {number[]} times
         * @param {number} last
         */
        doCleanupSnapshots: function doCleanupSnapshots(times, last) {
            var me = this,
                tm = me.timeMachine,
                lastSnapshot = tm.snapshots[last] || {},
                fieldsMap = {},
                state = {};

            function collectFields(fields) {
                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    fieldsMap[field.id] = field;
                }
            }

            function getFields() {
                var keys = Object.keys(fieldsMap),
                    array = [];
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    array.push(fieldsMap[key]);
                }
                return array;
            }

            function processSnapshot(snapshot) {
                DPO.mixin(state, snapshot);
                if (snapshot.project) {
                    fieldsMap = {};
                    state.project = snapshot.project;
                } else {
                    collectFields(state.fields || []);
                }
            }

            for (var i = 0; i < times.length; i++) {
                var time = times[i],
                    snapshot = tm.snapshots[time];
                processSnapshot(snapshot);
                delete tm.snapshots[time];
            }

            processSnapshot(lastSnapshot);
            state.fields = getFields();
            tm.snapshots[last] = state;
        },

        /**
         * Changes current timestamp
         * @memberof DPO.project.Transformer#
         * @param {number} [timestamp]
         */
        timeTravel: function timeTravel(timestamp) {
            var me = this;
            DPO.mixins.TimeMachine.timeTravel.apply(this, arguments);

            var project = me.lookupTimeResource('project');
            me.selector.clearCache();
            me.restoreProject(me.project, me.clone(project));

            var fields = {};
            me.foreachSnapshot(function (state) {
                if (state.project) {
                    fields = {};
                }

                var array = state.fields || [];
                for (var i = 0; i < array.length; i++) {
                    var field = array[i];
                    fields[field.id] = field;
                }
            });

            var ids = Object.keys(fields);
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i],
                    field = fields[id],
                    current = me.selector.getField(id);
                DPO.mixin(current, me.clone(field));
            }

            me.pendingAccumulativeEvents = {};
            me.pendingSequentialEvents = [];
            me.pendingPropertiesChanges = {};
            me.fire('time-travel', [me, me.timeMachine.timestamp]);
            me.fire('restored:snapshot', [me, me.timeMachine.timestamp]);
        },

        /**
         * @private
         * @memberof DPO.project.Transformer#
         * @returns {DPO.project.Transformer}
         */
        initIdCounter: function initIdCounter() {
            var me = this,
                counter = Number.NEGATIVE_INFINITY,
                mps = me.project.masterPanels,
                pgs = me.project.pages,
                max = Math.max,
                i, j, k;
            for (i = 0; i < pgs.length; i++) {
                var panels = pgs[i].panels;
                for (j = 0; j < panels.length; j++) {
                    var panel = panels[j],
                        refs = panel.fieldRefs;
                    for (k = 0; k < refs.length; k++) {
                        counter = max(counter, ExtractId(refs[k].id));
                        counter = max(counter, ExtractId(refs[k].contentId));
                    }

                    counter = max(counter, ExtractMaxFieldId(panel.images));
                    counter = max(counter, ExtractMaxFieldId(panel.backgrounds));
                    counter = max(counter, ExtractMaxFieldId(panel.barcodes));
                    counter = max(counter, ExtractMaxFieldId(panel.drawings));
                    counter = max(counter, ExtractMaxFieldId(panel.textBlocks));
                    counter = max(counter, ExtractMaxFieldId(panel.textPaths));
                    counter = max(counter, ExtractMaxFieldId(panel.textLines));
                }
            }

            for (i = 0; i < mps.length; i++) {
                var mp = mps[i];
                counter = max(counter, ExtractId(mp.id));
                counter = max(counter, ExtractMaxFieldId(mp.images));
                counter = max(counter, ExtractMaxFieldId(mp.backgrounds));
                counter = max(counter, ExtractMaxFieldId(mp.barcodes));
                counter = max(counter, ExtractMaxFieldId(mp.drawings));
                counter = max(counter, ExtractMaxFieldId(mp.textBlocks));
                counter = max(counter, ExtractMaxFieldId(mp.textPaths));
                counter = max(counter, ExtractMaxFieldId(mp.textLines));
            }

            me.idCounter = counter;
            return me;
        },

        /**
         * Fixed text path
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.TextPath} textPath
         */
        joinParagraphsIfNeeded: function joinParagraphsIfNeeded(textPath) {
            if (textPath.text.textFlow.paragraphs.length <= 1) {
                return;
            }

            var paragraphs = textPath.text.textFlow.paragraphs,
                p = paragraphs[0];
            for (var i = 1; i < paragraphs.length; i++) {
                p.spans = p.spans.concat(paragraphs[i].spans);
            }

            paragraphs.splice(1, Infinity);
        },

        /**
         * Normalizes project
         * @memberof DPO.project.Transformer#
         */
        normalizeProject: function normalizeProject() {
            var me = this,
                pgs = me.project.pages,
                i, j, k, f, r;
            for (i = 0; i < pgs.length; i++) {
                var panels = pgs[i].panels;
                for (j = 0; j < panels.length; j++) {
                    var panel = panels[j],
                        refs = panel.fieldRefs;
                    for (k = refs.length - 1; k >= 0; k--) {
                        r = refs[k];
                        f = me.selector.getField(r.contentId);

                        while (!f && r) {
                            r = me.selector.getRef(r.contentId);
                            if (r) {
                                f = me.selector.getField(r.contentId);
                            }
                        }

                        if (!f) {
                            refs.splice(k, 1);
                        } else if (refs[k] !== r) {
                            refs[k].contentId = f.id;
                            refs[k].styleId = f.id;
                            me.selector.clearCache();
                        }
                    }

                    var order = me.selector.getFieldOrder(panel);
                    me.applyFieldOrder(order, true);
                }
            }

            me.selector.collectData();
            var cache = me.selector.cache,
                keys = Object.keys(cache.fieldsMap);
            for (i = 0; i < keys.length; i++) {
                f = me.selector.getField(keys[i]);
                if (f instanceof DPO.model.TextPath) {
                    me.joinParagraphsIfNeeded(f);
                }
            }
        },

        /**
         * Removed all placeholder from project
         * @memberof DPO.project.Transformer#
         * @param {DPO.project.Filter} filter
         */
        cleanupProject: function cleanupProject(filter) {
            var me = this;
            me.selector.collectData();

            var cache = me.selector.cache,
                keys = Object.keys(cache.fieldsMap),
                placeholders = [];

            for (var i = 0; i < keys.length; i++) {
                var key = keys[i],
                    field = cache.fieldsMap[key];
                if (!filter.matchField(field)) {
                    placeholders.push(field);
                }
            }

            me.beginUpdates();
            me.deleteFields(placeholders);
            me.endUpdates();
        },

        /**
         * Applies print filters before generating pdf
         * @memberof DPO.project.Transformer#
         * @param {DPO.project.PrintFilter []} printFilters
         */
        applyPrintFilters: function applyPrintFilters(printFilters) {
            var me = this;

            me.beginUpdates();

            for (var i = 0; i < printFilters.length; i++) {
                var printFilter = printFilters[i];
                if (printFilter) {
                    printFilter.filter.call(printFilter, me.project);
                }
            }

            me.endUpdates();
        },

        /**
         * Generate unique identifier
         * @memberof DPO.project.Transformer#
         * @param {string} prefix
         * @returns {string}
         */
        generateId: function generateId(prefix) {
            this.idCounter++;
            return prefix + this.idCounter;
        },

        /**
         * Begins a series of method calls that modifies project.
         * @memberof DPO.project.Transformer#
         * @returns {DPO.project.Transformer}
         */
        beginUpdates: function beginUpdates() {
            var me = this;
            me.updateCounter++;
            return me;
        },

        /**
         * Concludes a series of method calls that modifies project.
         * @memberof DPO.project.Transformer#
         * @returns {DPO.project.Transformer}
         */
        endUpdates: function endUpdates() {
            var me = this;
            if (me.updateCounter === 0) {
                throw new Error('Unbalances beginUpdates & endUpdates calls');
            }

            me.updateCounter--;
            if (me.updateCounter === 0) {
                me.createSnapshot();
                me.firePendingEvents();
            }
            return me;
        },

        /**
         * Check if undo operation allowed
         * @memberof DPO.project.Transformer#
         * @returns {boolean}
         */
        canUndo: function canUndo() {
            return this.hasPastResource('project') || this.hasPastResource('fields');
        },

        /**
         * Check if redo operation allowed
         * @memberof DPO.project.Transformer#
         * @returns {boolean}
         */
        canRedo: function canRedo() {
            return this.hasFutureResource('project') || this.hasFutureResource('fields');
        },

        /**
         * Undo last modification
         * @memberof DPO.project.Transformer#
         * @returns {boolean}
         */
        undo: function undo() {
            var me = this,
                ts = me.getTimestamp(-1);
            if (ts) {
                me.timeTravel(ts);
            }

            return !!ts;
        },

        /**
         * Reverses previous undo operation
         * @memberof DPO.project.Transformer#
         * @returns {boolean}
         */
        redo: function redo() {
            var me = this,
                ts = me.getTimestamp(1);
            if (ts) {
                me.timeTravel(ts);
            }

            return !!ts;
        },

        /**
         * Created project snapshot after project modifications
         * @memberof DPO.project.Transformer#
         */
        createSnapshot: function createSnapshot() {
            var me = this,
                hasChanges = false;
            hasChanges = hasChanges || Object.keys(me.pendingAccumulativeEvents).length > 0;
            hasChanges = hasChanges || me.pendingSequentialEvents.length > 0;
            if (!hasChanges) {
                return;
            }

            me.forgetFuture();
            DPO.mixins.TimeMachine.timeTravel.call(me);

            if (me.pendingSequentialEvents.length > 0) {
                me.storeTimeResource('project', me.clone(me.project));
            } else {
                var fields = me.fieldsFromFromAccumulativeEvent();
                me.storeTimeResource('fields', me.clone(fields));
            }

            me.cleanupSequence(me.sequenceCleanup);
            me.limitSnapshots(me.maxSnapshots);
            me.fire('created:snapshot', [me, me.timeMachine.timestamp]);
        },

        /**
         * Clears history and set's up new start point
         * @memberof DPO.project.Transformer#
         * @returns DPO.project.Transformer
         */
        clearHistory: function clearHistory() {
            var me = this,
                clone = me.clone(me.project);
            me.initTimeMachine({
                project: clone
            });
            me.registerTimeResource('project');
            me.registerTimeResource('fields');
            me.storeTimeResource('project', clone);
            return me;
        },

        /**
         * Returns true if project was previously saved
         * @memberof DPO.project.Transformer#
         * @returns {boolean}
         */
        hasChanges: function hasChanges() {
            return this.getSnapshotCount() > 1;
        },

        /**
         * Fires pending events
         * @memberof DPO.project.Transformer#
         * @returns {DPO.project.Transformer}
         */
        firePendingEvents: function firePendingEvents() {
            var me = this,
                pse = me.pendingSequentialEvents,
                pae = me.pendingAccumulativeEvents,
                ppc = me.pendingPropertiesChanges,
                keys = Object.keys(pae),
                i, j;
            me.pendingAccumulativeEvents = {};
            me.pendingSequentialEvents = [];
            me.pendingPropertiesChanges = {};

            for (i = 0; i < pse.length; i++) {
                me.fire(pse[i].name, pse[i].args);
            }

            for (i = 0; i < keys.length; i++) {
                var event = keys[i];
                me.fire(event, pae[event]);
            }

            var scopes = Object.keys(ppc);
            for (i = 0; i < scopes.length; i++) {
                var scopeName = scopes[i],
                    map = ppc[scopeName],
                    properties = Object.keys(map),
                    objects = [];
                for (j = 0; j < properties.length; j++) {
                    var prop = properties[j];
                    objects = objects.concat(map[prop]);
                }

                for (j = objects.length - 1; j >= 0; j--) {
                    var o = objects[i],
                        index = objects.indexOf(o);
                    if (index !== -1 && index !== j) {
                        objects.splice(index, 1);
                    }
                }

                me.fire('property-changed:' + scopeName, [objects, map]);
            }

            return me;
        },

        /**
         * Fires sequential event
         * @memberof DPO.project.Transformer#
         * @param {string} name
         * @param {object[]} args
         * @returns {DPO.project.Transformer}
         */
        fireSequentialEvent: function fireSequentialEvent(name, args) {
            var me = this;
            if (!me.updateCounter) {
                me.fire(name, args);
                return me;
            }

            me.pendingSequentialEvents.push({
                name: name,
                args: args
            });

            return me;
        },

        /**
         * Returns fields from accumulative events
         * @memberof DPO.project.Transformer#
         * @returns {DPO.model.Field[]}
         */
        fieldsFromFromAccumulativeEvent: function fieldsFromFromAccumulativeEvent() {
            var ids = [],
                pae = this.pendingAccumulativeEvents,
                events = Object.keys(pae);
            for (var i = 0; i < events.length; i++) {
                var event = events[i],
                    params = pae[event],
                    args = params[0];

                for (var j = 0; j < args.length; j++) {
                    ids.push(args[j].id);
                }
            }

            return this.selector.selectFields(function (f) {
                return ids.indexOf(f.id) !== -1;
            });
        },

        /**
         * Removes fields from accumulative events
         * @memberof DPO.project.Transformer#
         * @param {object[]} items
         * @returns {DPO.project.Transformer}
         */
        removeFromAccumulativeEvent: function removeFromAccumulativeEvent(items) {
            var pae = this.pendingAccumulativeEvents,
                events = Object.keys(pae);
            for (var i = 0; i < events.length; i++) {
                var event = events[i],
                    params = pae[event],
                    args = params[0];
                for (var j = 0; j < items.length; j++) {
                    var item = items[j],
                        index = args.indexOf(item);
                    if (index !== -1) {
                        args.splice(index, 1);
                    }
                }
            }

            return this;
        },

        /**
         * Fires accumulative event
         * @memberof DPO.project.Transformer#
         * @param {string} name
         * @param {object[]} items
         * @returns {DPO.project.Transformer}
         */
        fireAccumulativeEvent: function fireAccumulativeEvent(name, items) {
            var me = this;
            if (!me.updateCounter) {
                me.fire(name, items);
                return me;
            }

            var params = me.pendingAccumulativeEvents[name] || [
                    []
                ],
                args = params[0];
            for (var i = 0; i < items.length; i++) {
                if (args.indexOf(items[i]) === -1) {
                    args.push(items[i]);
                }
            }

            me.pendingAccumulativeEvents[name] = params;
            return me;
        },

        /**
         * Fires property changed event
         * @memberof DPO.project.Transformer#
         * @param {string} scope
         * @param {string|string[]} prop
         * @param {object|object[]} obj
         * @returns {DPO.project.Transformer}
         */
        firePropertyChanged: function firePropertyChanged(scope, prop, obj) {
            var me = this,
                scopeObj = me.pendingPropertiesChanges[scope] || {},
                props = prop instanceof Array ? prop : [prop],
                objects = obj instanceof Array ? obj : [obj];
            for (var i = 0; i < props.length; i++) {
                var property = props[i],
                    array = scopeObj[property] || [];
                for (var j = 0; j < objects.length; j++) {
                    var o = objects[j];
                    if (array.indexOf(o) === -1) {
                        array.push(o);
                    }
                }
                scopeObj[property] = array;
            }
            me.pendingPropertiesChanges[scope] = scopeObj;
            return me;
        },

        /**
         * Fires geometry changed event
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.project.Transformer}
         */
        fireGeometryChanged: function fireGeometryChanged(fields) {
            return this.fireAccumulativeEvent('changed:field:geometry', fields);
        },

        /**
         * Fires style changed event
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.project.Transformer}
         */
        fireStyleChanged: function fireStyleChanged(fields) {
            return this.fireAccumulativeEvent('changed:field:style', fields);
        },

        /**
         * Fires content changed event
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.project.Transformer}
         */
        fireContentChanged: function fireStyleChanged(fields) {
            return this.fireAccumulativeEvent('changed:field:content', fields);
        },

        /**
         * Synchronize fields' data
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {string} type geometry or content
         * @returns {DPO.project.Transformer}
         */
        synchronizeFields: function synchFieldsGeometry(fields, type) {
            fields = (fields instanceof Array) ? fields : [fields];

            var me = this,
                event, ref;
            switch (type) {
                case 'geometry':
                    ref = 'geometryId';
                    event = me.fireGeometryChanged;
                    break;
                case 'content':
                    ref = 'contentId';
                    event = me.fireContentChanged;
                    break;
                default:
                    return me;
            }

            function synchronize(source) {
                var props = me.selector.getFieldProperties(source, type),
                    fields = me.selector.selectFields(function (f) {
                        var match = f.constructor === source.constructor;
                        match = match && f !== source;
                        match = match && f[ref] === source[ref];
                        match = match && f[ref] != null && source[ref] != null;
                        return match;
                    });
                for (var i = 0; i < fields.length; i++) {
                    DPO.mixin(fields[i], me.clone(props));
                }

                event.call(me, fields);
            }

            for (var i = 0; i < fields.length; i++) {
                synchronize(fields[i]);
            }

            return me;
        },

        /**
         * Centers fields' group in specified box
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field[]} fields
         * @param {boolean} middle
         * @param {boolean} center
         * @param {{x:number,y:number,width:number,height:number}} box All values are specified in twips
         * @returns {DPO.project.Transformer}
         */
        centerFields: function centerFields(fields, middle, center, box) {
            var me = this,
                b = me.selector.getBounds(fields),
                cx = box.width / 2,
                cy = box.height / 2,
                i, f;
            var dx = (center ? box.x + cx - b.cx : 0),
                dy = (middle ? box.y + cy - b.cy : 0);

            for (i = 0; i < fields.length; i++) {
                f = fields[i];
                f.position.x += dx;
                f.position.y += dy;
            }

            return me.synchronizeFields(fields, 'geometry')
                .firePropertyChanged('field', 'position', fields)
                .fireGeometryChanged(fields);
        },

        /**
         * Rotate field(s) around specified point
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {number} deg Rotation angle in degrees
         * @param {{x: number, y: number}} [center] Rotation center in project coordinated
         * @returns {DPO.project.Transformer}
         */
        rotateField: function rotateField(fields, deg, center) {
            fields = (fields instanceof Array) ? fields : [fields];
            center = center || this.selector.getCenter(fields);

            var me = this;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    p = f.position,
                    x = p.x,
                    y = p.y;

                var matrix = new DPO.math.Matrix(),
                    rotate = matrix.rotate(360 - deg, center.x, center.y);
                f.rotation = (360 + f.rotation + deg) % 360;
                p.x = rotate.x(x, y);
                p.y = rotate.y(x, y);
            }

            return me.synchronizeFields(fields, 'geometry')
                .firePropertyChanged('field', ['rotation', 'position'], fields)
                .fireGeometryChanged(fields);
        },

        /**
         * Transforms polypoints
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Polypoints} polypoints
         * @param {DPO.math.Matrix} matrix
         * @returns {DPO.project.Transformer}
         */
        transformPolypoints: function transformPolypoints(polypoints, matrix) {
            for (var i = 0; i < polypoints.items.length; i++) {
                var obj = polypoints.items[i],
                    x = obj.x,
                    y = obj.y;
                obj.x = matrix.x(x, y);
                obj.y = matrix.y(x, y);
                if (obj.x2 !== undefined) {
                    x = obj.x2;
                    y = obj.y2;
                    obj.x2 = matrix.x(x, y);
                    obj.y2 = matrix.y(x, y);
                }

                if (obj.x3 !== undefined) {
                    x = obj.x3;
                    y = obj.y3;
                    obj.x3 = matrix.x(x, y);
                    obj.y3 = matrix.y(x, y);
                }

                if (obj.x4 !== undefined) {
                    x = obj.x4;
                    y = obj.y4;
                    obj.x4 = matrix.x(x, y);
                    obj.y4 = matrix.y(x, y);
                }
            }

            return this;
        },

        /**
         * Scales single field from origin point
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field} field
         * @param {number} sx x axis scale
         * @param {number} sy y axis scale
         * @param {{x: number, y: number}} origin origin point in panel coordinate system
         * @returns {DPO.project.Transformer}
         */
        scaleField: function scaleField(field, sx, sy, origin) {
            var me = this,
                w = field.width,
                h = field.height,
                bp = me.selector.getBoundsPoints(field),
                un = (new DPO.math.Matrix()).rotate(field.rotation, origin.x, origin.y),
                scale = (new DPO.math.Matrix()).scale(sx, sy, origin.x, origin.y);

            // Un-rotate bounds around origin point
            bp.nw = un.point(bp.nw.x, bp.nw.y);
            bp.ne = un.point(bp.ne.x, bp.ne.y);
            bp.se = un.point(bp.se.x, bp.se.y);
            bp.sw = un.point(bp.sw.x, bp.sw.y);

            // Scale bounds
            bp.nw = scale.point(bp.nw.x, bp.nw.y);
            bp.ne = scale.point(bp.ne.x, bp.ne.y);
            bp.se = scale.point(bp.se.x, bp.se.y);
            bp.sw = scale.point(bp.sw.x, bp.sw.y);

            var width = Math.sqrt(Math.pow(bp.nw.x - bp.ne.x, 2) + Math.pow(bp.nw.y - bp.ne.y, 2)),
                height = Math.sqrt(Math.pow(bp.nw.x - bp.sw.x, 2) + Math.pow(bp.nw.y - bp.sw.y, 2)),
                rotate = (new DPO.math.Matrix()).rotate(360 - field.rotation, origin.x, origin.y);

            field.position.x = rotate.x(bp.nw.x, bp.nw.y);
            field.position.y = rotate.y(bp.nw.x, bp.nw.y);
            field.width = width;
            field.height = height;

            var d = /** @type DPO.model.Drawing*/ field;
            if (d.polypoints) {
                // Polypoints coordinates are relative to field
                // That's why we're scaling from (0, 0) point
                var matrix = new DPO.math.Matrix();
                matrix.scale(width / w, height / h, 0, 0);
                me.transformPolypoints(d.polypoints, matrix);
            }

            return me.synchronizeFields(field, 'geometry')
                .firePropertyChanged('field', ['position', 'width', 'height'], field)
                .fireGeometryChanged([field]);
        },

        /**
         * Scales fields from origin point
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {number} sx x axis scale
         * @param {number} sy y axis scale
         * @param {{x: number, y: number}} origin
         * @returns {DPO.project.Transformer}
         */
        scaleFields: function scaleFields(fields, sx, sy, origin) {
            fields = (fields instanceof Array) ? fields : [fields];

            for (var i = 0; i < fields.length; i++) {
                this.scaleField(fields[i], sx, sy, origin);
            }
            return this;
        },

        /**
         * Translate field(s) by dx,dy
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {number} dx
         * @param {number} dy
         * @returns {DPO.project.Transformer}
         */
        translateFields: function translateFields(fields, dx, dy) {
            fields = (fields instanceof Array) ? fields : [fields];
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    p = f.position;
                p.x += dx;
                p.y += dy;
            }

            return this.synchronizeFields(fields, 'geometry')
                .firePropertyChanged('field', 'position', fields)
                .fireGeometryChanged(fields);
        },

        /**
         * Align fields by specified direction
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field[]} fields
         * @param {string} direction
         * @returns {DPO.project.Transformer}
         */
        alignFields: function alignFields(fields, direction) {
            var bounds = this.selector.getBounds(fields),
                fn = alignFunctions[direction] || DPO.emptyFn;

            for (var i = 0; i < fields.length; i++) {
                fn(fields[i], bounds, this.selector.getBounds(fields[i]));
            }

            return this.synchronizeFields(fields, 'geometry')
                .firePropertyChanged('field', 'position', fields)
                .fireGeometryChanged(fields);
        },

        /**
         * Create drawing based on path
         * @memberof DPO.project.Transformer#
         * @param {string} path
         * @param {DPO.math.Rect} [bounds]
         * @returns {DPO.model.Drawing}
         */
        createDrawing: function createDrawing(path, bounds) {
            var me = this,
                draw = me.instantiate('Drawing'),
                polypoints = DPO.model.Polypoints.parsePath(path),
                b = polypoints.bounds(),
                w = b.right - b.left,
                h = b.bottom - b.top,
                s = bounds ? Math.min(bounds.width / w, bounds.height / h) : 50;
            polypoints.scale(s);

            draw.polypoints = polypoints;
            draw.shape = 'polygon';

            b = draw.polypoints.bounds();
            draw.width = b.right - b.left;
            draw.height = b.bottom - b.top;
            return draw;
        },

        /**
         * Creates new text block based on text default object.
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.TextDefaults} textDefaults
         * @returns {DPO.model.TextBlock}
         */
        createTextBlock: function createTextBlock(textDefaults) {
            var me = this,
                textStyle = textDefaults.textStyle,
                textBlock = me.instantiate('TextBlock'),
                textFlow = me.instantiate('TextFlow'),
                paragraph = me.instantiate('Paragraph'),
                span = me.instantiate('Span');

            textBlock.textStyle = me.clone(textDefaults.textStyle);
            textBlock.position = new DPO.model.Position();
            textBlock.position.x = textDefaults.blockPosition.x;
            textBlock.position.y = textDefaults.blockPosition.y;
            textBlock.width = textDefaults.blockWidth;
            textBlock.height = textDefaults.blockHeight;
            textBlock.text = new DPO.model.Text();

            span.value = 'TYPE YOUR TEXT';
            span.fontFamily = textStyle.typeface;
            span.fontSize = textStyle.pointSize;
            span.color = textStyle.textColor;
            paragraph.defaultText = span.value;
            paragraph.textAlign = textStyle.justification;
            paragraph.spans.push(span);
            textFlow.verticalAlign = textStyle.valign;
            textFlow.paragraphs.push(paragraph);
            textBlock.text.textFlow = textFlow;
            return textBlock;
        },

        /**
         * Creates new text block based on text default object.
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.TextDefaults} textDefaults
         * @returns {DPO.model.TextBlock}
         */
        createTextPath: function createTextBlock(textDefaults) {
            var me = this,
                textStyle = textDefaults.textStyle,
                textPath = me.instantiate('TextPath'),
                textFlow = me.instantiate('TextFlow'),
                paragraph = me.instantiate('Paragraph'),
                span = me.instantiate('Span');

            textPath.textStyle = me.clone(textDefaults.textStyle);
            textPath.position = new DPO.model.Position();
            textPath.position.x = textDefaults.blockPosition.x + textStyle.pointSize * 20;
            textPath.position.y = textDefaults.blockPosition.y + textStyle.pointSize * 20;
            textPath.width = textDefaults.blockWidth - textStyle.pointSize * 40;
            textPath.height = textDefaults.blockHeight - textStyle.pointSize * 40;
            textPath.text = new DPO.model.Text();

            span.value = 'TYPE YOUR TEXT';
            span.fontFamily = textStyle.typeface;
            span.fontSize = textStyle.pointSize;
            span.color = textStyle.textColor;

            paragraph.defaultText = span.value;
            paragraph.textAlign = textStyle.justification;
            paragraph.spans.push(span);
            textFlow.verticalAlign = textStyle.valign;
            textFlow.paragraphs.push(paragraph);
            textPath.text.textFlow = textFlow;
            return textPath;
        },

        /**
         * Creates new image field
         * @memberof DPO.project.Transformer#
         * @param {string} source
         * @param {number} width
         * @param {number} height
         * @returns {DPO.model.Image}
         */
        createImage: function createImage(source, width, height) {
            var me = this,
                img = me.instantiate('Image');
            img.source = source;
            img.description = new DPO.model.Description();
            img.description.index = -1;
            img.position = new DPO.model.Position();
            img.position.x = 0;
            img.position.y = 0;
            img.width = width;
            img.height = height;

            return img;
        },

        /**
         * Creates image background
         * @param {string} source
         * @param {number} width
         * @param {number} height
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {boolean} [keepAspect]
         * @returns {{background: *, transformBackgrounds: (*|DPO.model.Image[])}}
         */
        createBackground: function createBackground(source, width, height, panel, keepAspect) {
            var me = this,
                background = me.instantiate('Background'),
                transformed = me.transformBackgroundsToImages(panel);

            me.removeSolidBackgrounds(panel);
            background.source = source;
            background.description = new DPO.model.Description();
            background.description.index = -1;
            background.position = new DPO.model.Position();
            background.position.x = 0;
            background.position.y = 0;
            background.width = width;
            background.height = height;
            me.addFieldToPanel(background, panel);
            me.placeBackground(background, panel, keepAspect ? width / height : null);

            return {
                background: background,
                transformBackgrounds: transformed
            };
        },

        /**
         * Assign/unassign serial number to specified span
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Span|DPO.model.BarcodeProperty} el
         * @param {DPO.model.SerialNumber} [serialNumber]
         */
        setSerialNumber: function setSerialNumber(el, serialNumber) {
            var me = this;
            if (!serialNumber.id) {
                serialNumber.id = me.generateId('SN');
                me.project.serialNumbers.push(serialNumber);
                me.fireSequentialEvent('added:serial-number', [serialNumber]);
            }
            el.serialNumberField = serialNumber.id;
            delete el.mailMergeField;
            delete el.mailMergeId;
            return serialNumber;
        },

        /**
         * Adds serial number to text block or span; otherwise creates new text block.
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Span|DPO.model.TextBlock|null} element
         * @param {DPO.model.SerialNumber} serialNumber
         * @return {DPO.model.TextBlock}
         */
        addSerialNumber: function addSerialNumber(element, serialNumber) {
            var me = this,
                textDefaults,
                paragraphs,
                textBlock = null,
                span = null;

            if (element instanceof DPO.model.Span) {
                span = element;
            } else if (element instanceof DPO.model.TextBlock) {
                textBlock = element;
                paragraphs = textBlock.text.textFlow.paragraphs;
                span = paragraphs[0].spans[0];
                paragraphs.splice(1, paragraphs.length - 1);
                paragraphs[0].spans.splice(1, paragraphs[0].spans.length - 1);
            } else {
                textDefaults = me.project.masterPanels[0].textDefaults[0];
                textBlock = me.createTextBlock(textDefaults);
                span = textBlock.text.textFlow.paragraphs[0].spans[0];
            }

            me.setSerialNumber(span, serialNumber);
            return textBlock;
        },

        /**
         *
         * @param {DPO.model.MasterPanel} panel
         */
        clearFieldsOnPanel: function clearFieldsOnPanel(panel) {
            var me = this,
                panels = me.selector.selectChildPanels(panel);

            panel.images = [];
            panel.barcodes = [];
            panel.drawings = [];
            panel.textBlocks = [];
            panel.textPaths = [];
            panel.textLines = [];
            panel.backgrounds = [];

            for (var i = 0; i < panels.length; i++) {
                panels[i].images = [];
                panels[i].barcodes = [];
                panels[i].drawings = [];
                panels[i].textBlocks = [];
                panels[i].textPaths = [];
                panels[i].textLines = [];
                panels[i].backgrounds = [];
                panels[i].fieldRefs = [];
            }
        },

        /**
         * Adds field to panel
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field} field
         * @param {DPO.model.AbstractPanel} panel
         * @returns {boolean}
         */
        pushFieldToPanel: function pushFieldToPanel(field, panel) {
            switch (field.constructor) {
                case DPO.model.Drawing:
                    panel.drawings.push( /** @type DPO.model.Drawing*/ field);
                    break;
                case DPO.model.TextBlock:
                    panel.textBlocks.push( /** @type DPO.model.TextBlock*/ field);
                    break;
                case DPO.model.TextPath:
                    panel.textPaths.push( /** @type DPO.model.TextPath*/ field);
                    break;
                case DPO.model.Barcode:
                    panel.barcodes.push( /** @type DPO.model.Barcode*/ field);
                    break;
                case DPO.model.Image:
                    panel.images.push( /** @type DPO.model.Image*/ field);
                    break;
                case DPO.model.Background:
                    panel.backgrounds.push( /** @type DPO.model.Background*/ field);
                    break;
                default:
                    return false;
            }

            return true;
        },

        /**
         * Pushes background to back
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Panel[]} panels
         * @param {DPO.model.Field} field
         * @returns {DPO.project.Transformer}
         */
        pushBackgroundToBackAndFieldToFront: function pushBackgroundToBackAndFieldToFront(panels, field) {
            var toFront = field instanceof DPO.model.Background ? [] : [field];
            for (var i = 0; i < panels.length; i++) {
                var panel = panels[i],
                    order = this.selector.getFieldOrder(panel);
                order.sendBackgroundToBack();
                order.bringToFront(toFront);
                this.applyFieldOrderForSingle(order, true);
            }

            return this;
        },

        /**
         * Finds best place for specified field
         * @param {DPO.model.Field} field
         * @param {DPO.model.Panel} panel
         * @param {number} [minDelta]
         * @returns {DPO.model.Position}
         */
        findBestPlace: function findBestPlace(field, panel, minDelta) {
            var order = this.selector.getFieldOrder(panel),
                mp = this.selector.selectMasterPanel(panel),
                x = field.position.x,
                y = field.position.y,
                dx = 0,
                dy = 0,
                c = this.clone(field),
                b1 = this.selector.getBounds(c),
                fields = order.getFields();
            minDelta = minDelta || Math.min(mp.width, mp.height) * 0.05;

            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (f.constructor !== field.constructor || field === f) {
                    continue;
                }

                var b2 = this.selector.getBounds(f),
                    dl = Math.abs(b1.left - b2.left),
                    dt = Math.abs(b1.top - b2.top),
                    dr = Math.abs(b1.right - b2.right),
                    db = Math.abs(b1.bottom - b2.bottom),
                    d = Math.max(dl, dt, dr, db),
                    r1 = new DPO.math.Rect(b1.left, b1.top, b1.right, b1.bottom),
                    r2 = new DPO.math.Rect(b2.left, b2.top, b2.right, b2.bottom);
                if (d < minDelta || r1.containsRect(r2)) {
                    dx += minDelta;
                    dy += minDelta;
                    c.position.x = x + dx;
                    c.position.y = y + dy;
                    b1 = this.selector.getBounds(c);
                    i = 0;
                }
            }

            return new DPO.model.Position(x + dx, y + dy);
        },

        /**
         * Add field to panel and creates field reference
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field} field
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.project.Transformer}
         */
        addFieldToPanel: function addFieldToPanel(field, panel) {
            var me = this,
                refs = [],
                pushed = me.pushFieldToPanel(field, panel),
                pnl, ref, mp, panels;
            if (!pushed) {
                return me;
            }

            field.id = me.generateId('PF');
            field.contentId = field.id;
            field.geometryId = field.id;
            field.zOrder = Number.MAX_VALUE;

            if (panel instanceof DPO.model.MasterPanel) {
                mp = me.selector.selectMasterPanel(panel);
                panels = me.selector.selectChildPanels(mp);
                for (var i = 0; i < panels.length; i++) {
                    pnl = panels[i];
                    ref = new DPO.model.FieldRef();
                    ref.id = me.generateId('FR');
                    ref.contentId = field.id;
                    ref.geometryId = field.id;
                    refs.push(ref);
                    pnl.fieldRefs.push(ref);
                }
            } else {
                panels = [panel];
            }

            me.selector.clearCache();
            me.pushBackgroundToBackAndFieldToFront(panels, field);
            me.fireSequentialEvent('added:field', [field, panels, refs]);

            return me;
        },

        /**
         * Deletes field from panel
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @returns {DPO.project.Transformer}
         */
        deleteFields: function deleteFields(fields) {
            var me = this,
                mps = me.project.masterPanels,
                pns = me.selector.selectPanels(),
                refs = [],
                panel, i, j, k, f, removed;
            fields = (fields instanceof Array) ? fields : [fields];
            for (i = 0; i < mps.length; i++) {
                var mp = mps[i];
                for (j = 0; j < fields.length; j++) {
                    f = fields[j];
                    RemovedElement(mp.images, f);
                    RemovedElement(mp.barcodes, f);
                    RemovedElement(mp.drawings, f);
                    RemovedElement(mp.textBlocks, f);
                    RemovedElement(mp.textPaths, f);
                    RemovedElement(mp.textLines, f);
                    RemovedElement(mp.backgrounds, f);

                    for (k = 0; k < pns.length; k++) {
                        panel = pns[k];
                        removed = RemovedByContentId(panel.fieldRefs, f.id);
                        refs = refs.concat(removed);

                        RemovedElement(panel.images, f);
                        RemovedElement(panel.barcodes, f);
                        RemovedElement(panel.drawings, f);
                        RemovedElement(panel.textBlocks, f);
                        RemovedElement(panel.textPaths, f);
                        RemovedElement(panel.textLines, f);
                        RemovedElement(panel.backgrounds, f);
                    }
                }
            }

            me.selector.clearCache();
            me.removeFromAccumulativeEvent(fields);
            me.fireSequentialEvent('deleted:field', [fields, refs]);
            return me;
        },

        /**
         * Applies new field order
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.FieldOrder} order
         * @param {boolean} [silent]
         * @returns {DPO.project.Transformer}
         */
        applyFieldOrder: function applyFieldOrder(order, silent) {
            return this.applyFieldOrderForSingle(order, silent);
        },

        /**
         * Applies new field order for single panel
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.FieldOrder} order
         * @param {boolean} [silent]
         * @returns {DPO.project.Transformer}
         */
        applyFieldOrderForSingle: function applyFieldOrderForSingle(order, silent) {
            var items = order.items;
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.ref) {
                    item.ref.zOrder = item.zOrder;
                } else {
                    item.field.zOrder = item.zOrder;
                }
            }

            if (!silent) {
                this.fireSequentialEvent('changed:field-order', [order.panel]);
            }
            return this;
        },

        /**
         * Applies new field order for all panels
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.FieldOrder} order
         * @param {boolean} [silent]
         * @returns {DPO.project.Transformer}
         */
        applyFieldOrderForMultiple: function applyFieldOrderForMultiple(order, silent) {
            var mp = this.selector.selectMasterPanel(order.panel),
                panels = this.selector.selectChildPanels(mp),
                fields = order.getFields();
            for (var i = 0; i < panels.length; i++) {
                var panel = panels[i],
                    o = this.selector.getFieldOrder(panel);
                for (var j = 0; j < fields.length; j++) {
                    o.setZOrder(fields[j], j);
                }
                this.applyFieldOrder(o, silent);
            }
            return this;
        },

        /**
         * Pastes fields to specified panel
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {DPO.model.Panel} panel
         * @returns {DPO.model.Field[]}
         */
        pasteFields: function pasteFields(fields, panel) {
            fields = fields instanceof Array ? fields : [fields];
            var me = this,
                array = [];
            for (var i = 0; i < fields.length; i++) {
                var field = me.clone(fields[i]);
                me.addFieldToPanel(field, panel);
                array.push(field);
            }
            return array;
        },

        /**
         * Changes fields properties
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {object} properties
         * @returns {DPO.project.Transformer}
         */
        setProperties: function setProperties(fields, properties) {
            fields = fields instanceof Array ? fields : [fields];

            var me = this;
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i],
                    mode = me.selector.getFieldPropertiesMode(properties);
                DPO.mixin(fields[i], this.clone(properties));
                switch (mode) {
                    case 1:
                        me.synchronizeFields(field, 'geometry')
                            .fireGeometryChanged(fields);
                        break;
                    case 2:
                        me.synchronizeFields(field, 'content')
                            .fireContentChanged(fields);
                        break;
                    case 3:
                        me.synchronizeFields(field, 'geometry')
                            .synchronizeFields(field, 'content')
                            .fireGeometryChanged(fields)
                            .fireContentChanged(fields);
                        break;
                }
            }
            return me;
        },

        /**
         * Sets opacity value to fill & stroke color
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {number} opacity
         * @returns {DPO.project.Transformer}
         */
        setOpacity: function setOpacity(fields, opacity) {
            fields = fields instanceof Array ? fields : [fields];
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (f.opacity !== 0) {
                    f.opacity = opacity;
                }
                if (f.outline) {
                    f.outline.opacity = opacity;
                }
            }

            return this.synchronizeFields(fields, 'content').fireStyleChanged(fields);
        },

        /**
         * Sets fill color & opacity
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {DPO.model.Color} color
         * @returns {DPO.project.Transformer}
         */
        setFillColor: function setFillColor(fields, color) {
            fields = fields instanceof Array ? fields : [fields];

            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                f.color = color.model;
                f.spotColor = color.spot;
                f.opacity = color.a;
            }

            return this.synchronizeFields(fields, 'content').fireStyleChanged(fields);
        },

        /**
         * Sets outline width
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {number} width
         * @returns {DPO.project.Transformer}
         */
        setOutlineWidth: function setOutlineWidth(fields, width) {
            fields = fields instanceof Array ? fields : [fields];
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                f.outline.width = width;
            }

            return this.synchronizeFields(fields, 'content').fireStyleChanged(fields);
        },

        /**
         * Sets outline color & opacity
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {DPO.model.Color} color
         * @returns {DPO.project.Transformer}
         */
        setOutlineColor: function setOutlineColor(fields, color) {
            fields = fields instanceof Array ? fields : [fields];

            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                f.outline.color = color.model;
                f.outline.spotColor = color.spot;
                f.outline.opacity = color.a;
            }

            return this.synchronizeFields(fields, 'content').fireStyleChanged(fields);
        },

        /**
         * Sets text angle
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.TextPath|DPO.model.TextPath[]} fields
         * @param {number} angle Text angle in degrees
         * @returns {DPO.project.Transformer}
         */
        setTextAngle: function setTextAngle(fields, angle) {
            fields = fields instanceof Array ? fields : [fields];
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                f.textAngle = angle;
            }

            return this.synchronizeFields(fields, 'content')
                .firePropertyChanged('field', 'textAngle', fields)
                .fireGeometryChanged(fields);
        },

        duplicateSheet: function duplicateSheet() {
            var me = this,
                newSheet,
                frontPage = me.project.pages[0],
                backPage = frontPage.doubleSided ? me.project.pages[1] : null;

            function clonePage(page) {
                var newPage = me.clone(frontPage);
                newPage.panels = [];
                for (var i = 0; i < page.panels.length; i++) {
                    var panel = me.clone(page.panels[i]);
                    newPage.panels.push(panel);
                }
                return newPage;
            }

            newSheet = {
                front: clonePage(frontPage),
                back: null
            };
            me.project.pages.push(newSheet.front);

            if (backPage) {
                newSheet.back = clonePage(backPage);
                me.project.pages.push(newSheet.back);
            }

            me.fireAccumulativeEvent('added:sheet', [newSheet]);
            me.selector.clearCache();

            return [newSheet];
        },

        /**
         * Creates new sheet(s)
         * @memberof DPO.project.Transformer#
         * @param {number} [count]
         * @returns {object[]}
         */
        addSheets: function addSheets(count) {
            var me = this,
                masterFields = {};

            function sorter(a, b) {
                return a.zOrder - b.zOrder;
            }

            function initPage(page) {
                var i, j;
                for (i = 0; i < page.panels.length; i++) {
                    var panel = page.panels[i],
                        mp = me.selector.selectMasterPanel(panel),
                        fields = masterFields[mp.id];
                    if (!fields) {
                        fields = [].concat(
                            mp.images,
                            mp.barcodes,
                            mp.drawings,
                            mp.backgrounds,
                            mp.textBlocks,
                            mp.textPaths,
                            mp.textLines).sort(sorter);
                        masterFields[mp.id] = fields;
                    }

                    var backgrounds = [];
                    for (j = 0; j < panel.backgrounds.length; j++) {
                        var bg = panel.backgrounds[j];
                        if (!bg.source) {
                            bg.id = me.generateId('PF');
                            bg.contentId = bg.id;
                            bg.geometryId = bg.id;
                            backgrounds.push(bg);
                        }
                    }

                    me.initCollection(panel);
                    panel.backgrounds = backgrounds;

                    for (j = 0; j < fields.length; j++) {
                        var field = fields[j],
                            ref = new DPO.model.FieldRef();
                        me.pushBackgroundToBackAndFieldToFront(page.panels, field);
                        ref.id = me.generateId('FR');
                        ref.contentId = field.id;
                        ref.geometryId = field.id;
                        ref.zOrder = j;
                        panel.fieldRefs.push(ref);
                    }
                }

                return page;
            }

            count = count || 1;

            var frontPage = me.project.pages[0],
                backPage = frontPage.doubleSided ? me.project.pages[1] : null,
                sheets = [];
            for (var i = 0; i < count; i++) {
                var sheet = {
                    front: initPage(me.clone(frontPage)),
                    back: null
                };
                me.project.pages.push(sheet.front);

                if (backPage) {
                    sheet.back = initPage(me.clone(backPage));
                    me.project.pages.push(sheet.back);
                }

                sheets.push(sheet);
            }

            me.fireSequentialEvent('added:sheet', sheets);
            me.selector.clearCache();

            return sheets;
        },

        /**
         * Remove sheet of specified page
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Page} page
         * @returns {{front: DPO.model.Page, back: DPO.model.Page}}
         */
        removeSheet: function removeSheet(page) {
            var me = this,
                pages = me.project.pages,
                sheets = me.selector.selectSheets(),
                sheet = me.selector.getSheet(page),
                index;
            if (sheets.length === 1 || sheet == null) {
                //noinspection JSValidateTypes
                return null;
            }

            index = pages.indexOf(sheet.front);
            var removedPages = pages.splice(index, sheet.back ? 2 : 1),
                removedPanels = [],
                removedPanelIndexes = [];
            for (var i = 0; i < removedPages.length; i++) {
                var pg = removedPages[i];
                for (var j = 0; j < pg.panels.length; j++) {
                    var panel = pg.panels[j];
                    removedPanels.push(panel);
                    removedPanelIndexes.push(me.selector.panelIndex(panel));
                }
            }

            me.fireSequentialEvent('removed:panels', [removedPanels, removedPanelIndexes]);
            me.fireSequentialEvent('removed:sheet', [sheet]);
            me.selector.clearCache();

            return sheet;
        },

        /**
         * Adjust sheet count to fit data binding
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {number} count
         */
        adjustSheetForDataBinding: function adjustPanelCount(panel, count) {
            var me = this,
                selector = this.selector,
                mp = selector.selectMasterPanel(panel),
                sheets = selector.selectSheets(),
                panelCount = selector.amountPanelsInSheet(mp, sheets[0]),
                sheetCount = Math.ceil((count / panelCount)),
                diff = sheetCount - sheets.length;
            if (diff > 0) {
                me.addSheets(Math.max(0, diff));
            }
        },

        /**
         * Breaks reference between panel & master panel fort specified field
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Field[]} fields
         * @param {DPO.model.Panel} panel
         * @param {number} [mode=3] 0 - none; 1 - geometry; 2 - content
         * @returns {object[]}
         */
        breakFieldRefs: function breakFieldRefs(fields, panel, mode) {
            var me = this,
                originalOrder = me.selector.getFieldOrder(panel),
                refs = panel.fieldRefs,
                array = [],
                map = {},
                i, j, field, ref, clone, order;
            mode = mode == null ? 3 : mode;
            mode = Math.min(mode, 3);
            mode = Math.max(mode, 0);

            for (i = 0; i < fields.length; i++) {
                field = fields[i];
                clone = field;
                for (j = refs.length - 1; j >= 0; j--) {
                    ref = refs[j];
                    if (ref.contentId === field.id) {
                        clone = me.clone(field);
                        clone.id = me.generateId('PF');

                        map[ref.contentId] = clone;
                        refs.splice(j, 1);

                        array.push({
                            masterField: field,
                            brokenRef: ref,
                            panelField: clone
                        });
                        me.pushFieldToPanel(clone, panel);
                    }
                }

                //noinspection JSBitwiseOperatorUsage
                if ((mode & 1) !== 0) {
                    clone.geometryId = clone.id;
                }

                //noinspection JSBitwiseOperatorUsage
                if ((mode & 2) !== 0) {
                    clone.contentId = clone.id;
                }
            }

            if (array.length) {
                me.selector.clearCache();
                order = me.selector.getFieldOrder(panel);

                for (i = 0; i < originalOrder.items.length; i++) {
                    field = originalOrder.items[i].field;
                    field = map[field.id] || field;
                    order.setZOrder(field, i);
                }

                me.applyFieldOrder(order, true);
                me.fireSequentialEvent('internal:broke:reference', [panel, array]);
                me.fire('broke:reference', [panel, array]);
            }
            return array;
        },

        /**
         * Translates panels by specified dx & dy
         * @memberof DPO.project.Transformer#
         * @param {number} dx in twips
         * @param {number} dy in twips
         */
        translatePanels: function translatePanels(dx, dy) {
            var me = this,
                project = me.project,
                panels;

            for (var i = 0; i < project.pages.length; i++) {
                panels = project.pages[i].panels;
                for (var j = 0; j < panels.length; j++) {
                    panels[j].position.x += dx;
                    panels[j].position.y += dy;
                }
            }
            me.selector.clearCache();
        },

        /**
         * Reorder panels on pages from Top to  Bottom
         * @memberof DPO.project.Transformer#
         */
        reorderPanelsFromTopToBottom: function reorderPanelsFromTopToBottom() {
            var me = this,
                introspector = new DPO.model.Introspector(),
                cloneProject = introspector.clone(me.project),
                panels;

            for (var i = 0; i < me.project.pages.length; i++) {
                var page = me.project.pages[i],
                    layout = page.gridLayouts[0];
                if (layout && layout.numberAcross > 1) {
                    panels = page.panels;
                    panels = me.sortPanelsByPositionCoordinate(panels, 'y', 'x');
                    panels = me.sortPanelsByPositionCoordinate(panels, 'x', 'y');

                    for (var j = 0; j < panels.length; j++) {
                        this.copyPanel(panels[j], cloneProject.pages[i].panels[j]);
                    }
                }
            }
            me.selector.clearCache();
        },

        /**
         * Reorder panels on pages from Left to Right
         * @memberof DPO.project.Transformer#
         */
        reorderPanelsFromLeftToRight: function reorderPanelsFromLeftToRight() {
            var me = this,
                introspector = new DPO.model.Introspector(),
                cloneProject = introspector.clone(me.project),
                panels;

            for (var i = 0; i < me.project.pages.length; i++) {
                var page = me.project.pages[i],
                    layout = page.gridLayouts[0];
                if (layout && layout.numberAcross > 1) {
                    panels = page.panels;
                    panels = me.sortPanelsByPositionCoordinate(panels, 'x', 'y');
                    panels = me.sortPanelsByPositionCoordinate(panels, 'y', 'x');

                    for (var j = 0; j < panels.length; j++) {
                        this.copyPanel(panels[j], cloneProject.pages[i].panels[j]);
                    }
                }
            }
            me.selector.clearCache();
        },

        /***
         * Clone the clonePanel fields to panel but save original position
         * @memberof DPO.project.Transformer#
         * @param panel
         * @param clonePanel
         */
        copyPanel: function copyPanel(panel, clonePanel) {
            var introspector = new DPO.model.Introspector(),
                position = {
                    x: panel.position.x,
                    y: panel.position.y
                };
            panel.textBlocks = introspector.clone(clonePanel.textBlocks);
            panel.barcodes = introspector.clone(clonePanel.barcodes);
            panel.images = introspector.clone(clonePanel.images);
            panel.backgrounds = introspector.clone(clonePanel.backgrounds);
            panel.drawings = introspector.clone(clonePanel.drawings);
            panel.textLines = introspector.clone(clonePanel.textLines);
            panel.textPaths = introspector.clone(clonePanel.textPaths);
            panel.fieldRefs = introspector.clone(clonePanel.fieldRefs);
            panel.altSortOrder = introspector.clone(clonePanel.altSortOrder);
            panel.description = introspector.clone(clonePanel.description);
            panel.hints = introspector.clone(clonePanel.hints);
            panel.ignoreZ = clonePanel.ignoreZ;
            panel.master = clonePanel.master;
            panel.rotation = clonePanel.rotation;
            panel.position.x = position.x;
            panel.position.y = position.y;
        },

        /**
         * Procedure of sorting  panels by priority of position
         * @memberof DPO.project.Transformer#
         * @param array - of panels
         * @param highPriority - can be 'x' or 'y'
         * @param lowPriority - can be 'x' or 'y'
         * @returns {*}
         */
        sortPanelsByPositionCoordinate: function sortPanelsByPositionCoordinate(array, highPriority, lowPriority) {
            array.sort(function sortY(a, b) {
                var expr = a.position[highPriority] - b.position[highPriority];
                if (expr === 0) {
                    expr = a.position[lowPriority] - b.position[lowPriority];
                }
                return expr;
            });
            return array;
        },

        /**
         * Removes solid backgrounds from all child panels
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         */
        removeSolidBackgrounds: function removeSolidBackgrounds(panel) {
            var me = this,
                mp = me.selector.selectMasterPanel(panel),
                panels = me.selector.selectChildPanels(mp),
                i, j, bg;

            for (i = 0; i < panels.length; i++) {
                var backgrounds = panels[i].backgrounds;
                for (j = 0; j < backgrounds.length; j++) {
                    bg = backgrounds[j];
                    if (!bg.source) {
                        me.deleteFields(bg);
                    }
                }
            }
            for (i = 0; i < mp.backgrounds.length; i++) {
                bg = mp.backgrounds[i];
                if (!bg.source) {
                    me.deleteFields(bg);
                }
            }
        },

        /**
         * Transforms all backgrounds to image field
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.model.Image[]}
         */
        transformBackgroundsToImages: function transformBackgroundsToImages(panel) {
            var me = this,
                mp = me.selector.selectMasterPanel(panel),
                panels = [panel],
                transformed = [],
                p, i;

            if (panel instanceof DPO.model.MasterPanel) {
                panels = me.selector.selectChildPanels(mp);
                transformed = transformed.concat(me.transformPanelBackgroundsToImages(mp));
            }

            for (i = 0; i < panels.length; i++) {
                p = panels[i];
                transformed = transformed.concat(me.transformPanelBackgroundsToImages(p));
            }

            return transformed;
        },

        /**
         * Transforms related backgrounds to image field
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {DPO.model.Image} image
         * @returns {DPO.model.Image[]}
         */
        transformRelatedBackgroundsToImages: function transformRelatedBackgroundsToImages(panel, image) {
            var me = this,
                transformed = [],
                i;

            function transformIfRelated(refs, field, panel) {
                for (var i = 0; i < refs.length; i++) {
                    var ref = refs[i];

                    if (ref.geometryId === field.id) {
                        return me.transformPanelBackgroundsToImages(panel);
                    }
                }

                return [];
            }

            if (panel instanceof DPO.model.MasterPanel) {
                var panels = me.selector.selectChildPanels(panel);

                for (i = 0; i < panels.length; i++) {
                    var pnl = panels[i];
                    transformed = transformed.concat(transformIfRelated(pnl.fieldRefs, image, pnl));
                }
            } else {
                var mp = me.selector.selectMasterPanel(panel);

                for (i = 0; i < mp.backgrounds.length; i++) {
                    var bg = mp.backgrounds[i];
                    transformed = transformed.concat(transformIfRelated(panel.fieldRefs, bg, mp));
                }
            }

            return transformed;
        },

        /**
         * Transforms panel backgrounds to image field
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.model.Image[]}
         */
        transformPanelBackgroundsToImages: function transformPanelBackgroundsToImages(panel) {
            var me = this,
                transformed = [];

            for (var i = 0; i < panel.backgrounds.length; i++) {
                var bg = panel.backgrounds[i];
                if (bg.source) {
                    transformed.push(me.transformBackgroundToImage(bg, panel));
                }
            }

            return transformed;
        },

        /**
         * Transforms background field to image field
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Background} background
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.model.Image}
         */
        transformBackgroundToImage: function transformBackgroundToImage(background, panel) {
            var me = this,
                image = me.instantiate('Image'),
                master = me.selector.selectMasterPanel(panel);

            image.id = me.generateId('PF');
            image.contentId = image.id;
            image.geometryId = image.id;
            image.zOrder = Number.MAX_VALUE;
            image.width = master.width;
            image.height = master.height;
            image.position = me.clone(background.position);
            image.source = background.source;
            me.replaceField(panel, background, image);

            return image;
        },

        /**
         * Transforms image field to background field
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Image} image
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {{background: DPO.model.Background, transformBackgrounds: DPO.model.Image[]}}
         */
        transformImageToBackground: function transformImageToBackground(image, panel) {
            var me = this,
                background = me.instantiate('Background'),
                order = me.selector.getFieldOrder(panel),
                transformed = me.transformPanelBackgroundsToImages(panel),
                panels;

            transformed = transformed.concat(me.transformRelatedBackgroundsToImages(panel, image));

            background.id = me.generateId('PF');
            background.contentId = background.id;
            background.geometryId = background.id;
            background.zOrder = Number.MAX_VALUE;
            background.description = new DPO.model.Description();
            background.description.index = -1;
            background.position = me.clone(image.position);
            background.width = image.width;
            background.height = image.height;
            background.source = image.source;

            me.removeSolidBackgrounds(panel);
            me.replaceField(panel, image, background);

            if (panel instanceof DPO.model.MasterPanel) {
                panels = me.selector.selectChildPanels(panel);
                for (var i = 0; i < panels.length; i++) {
                    order = me.selector.getFieldOrder(panels[i]);
                    order.sendToBack([background]);
                    me.applyFieldOrder(order);
                }
            } else {
                order = me.selector.getFieldOrder(panel);
                order.sendToBack([background]);
                me.applyFieldOrder(order);
            }

            return {
                background: background,
                transformBackgrounds: transformed
            };
        },

        /**
         * Replace existing panel field with another field
         * @param panel
         * @param oldField - current field
         * @param newField - new field
         */
        replaceField: function replaceField(panel, oldField, newField) {
            var me = this,
                panels;

            if (panel instanceof DPO.model.MasterPanel) {
                panels = me.selector.selectChildPanels(panel);

                for (var i = 0; i < panels.length; i++) {
                    var pnl = panels[i];

                    for (var j = 0; j < pnl.fieldRefs.length; j++) {
                        var ref = pnl.fieldRefs[j];

                        if (ref.geometryId === oldField.id) {
                            ref.contentId = newField.id;
                            ref.geometryId = newField.id;
                            break;
                        }
                    }
                }
            } else {
                panels = [panel];
            }

            me.deleteFields(oldField);
            me.pushFieldToPanel(newField, panel);
            me.pushBackgroundToBackAndFieldToFront(panels, newField);
            me.fireSequentialEvent('added:field', [newField, panels]);
        },

        /**
         * Places background to bleed, safe or original area
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Background} background
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {number} [aspect]
         */
        placeBackground: function placeBackground(background, panel, aspect) {
            var me = this,
                master = me.selector.selectMasterPanel(panel),
                inflation = master.bleed ? 90 : -90,
                aw = master.width + 2 * inflation,
                ah = master.height + 2 * inflation,
                w = aw,
                h = ah;

            if (aspect != null) {
                w = aw;
                h = aw / aspect;
                if (w < aw || h < ah) {
                    w = ah * aspect;
                    h = ah;
                }
            }

            background.position.x = (master.width - w) / 2;
            background.position.y = (master.height - h) / 2;
            background.width = w;
            background.height = h;

            this.firePropertyChanged('field', ['position', 'width', 'height'], background);
            this.fireGeometryChanged([background]);
        },

        /**
         * Places image to bleed, safe or original area
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Image} image
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {number} [aspect]
         */
        placeImage: function placeImage(image, panel, aspect) {
            var me = this,
                master = me.selector.selectMasterPanel(panel),
                inflation = master.bleed ? 90 : -90,
                aw = master.width + 2 * inflation,
                ah = master.height + 2 * inflation,
                w = aw,
                h = ah;
            if (aspect != null) {
                w = aw;
                h = aw / aspect;
                if (w < aw || h < ah) {
                    w = ah * aspect;
                    h = ah;
                }
            }

            image.position.x = (master.width - w) / 2;
            image.position.y = (master.height - h) / 2;
            image.width = w;
            image.height = h;

            this.firePropertyChanged('field', ['position', 'width', 'height'], image);
            this.fireGeometryChanged([image]);
        },

        fitImageToSide: function fitImageToSide(image, panel, sideSize) {
            var me = this,
                master = me.selector.selectMasterPanel(panel),
                inflation = master.bleed ? 90 : -90,
                panelSides = [master.width, master.height],
                imageSides = [image.width, image.height],
                aw = master.width,
                ah = master.height,
                sideIndex,
                scaleFactor,
                w,
                h;

            sideIndex = panelSides.indexOf(sideSize);

            scaleFactor = imageSides[sideIndex] / (panelSides[sideIndex] + 2 * inflation);

            w = image.width / scaleFactor;
            h = image.height / scaleFactor;

            image.position.x = (aw - (w)) / 2;
            image.position.y = (ah - (h)) / 2;
            image.width = w;
            image.height = h;

            this.firePropertyChanged('field', ['position', 'width', 'height'], image);
            this.fireGeometryChanged([image]);
        },

        /**
         * Sets or remove solid background for specified page & master panel
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.Page} page
         * @param {DPO.model.MasterPanel} master
         * @param {DPO.model.Color} [color]
         * @returns {object[]}
         */
        setPageBackground: function setPageBackground(page, master, color) {
            var me = this,
                result = [],
                backgrounds = [],
                bleedValue = 90,
                bounds = me.selector.selectPanelsRectangles(page),
                panels = page.panels,
                panel, mp, background, i, j, rect, diff, d;

            for (i = 0; i < bounds.length; i++) {
                bounds[i].inflate(bleedValue, bleedValue);
            }

            for (i = 0; i < panels.length; i++) {
                panel = panels[i];
                mp = me.selector.selectMasterPanel(panels[i]);
                if (mp !== master) {
                    continue;
                }

                result = result.concat(me.transformBackgroundsToImages(panel));
                rect = bounds[i].clone();
                for (j = 0; j < bounds.length; j++) {
                    if (j === i) {
                        continue;
                    }

                    diff = rect.intersection(bounds[j]);
                    if (!diff) {
                        continue;
                    }

                    if (rect.x1 === diff.x1 && rect.x2 === diff.x2) {
                        d = diff.height / 2;
                        if (rect.y1 === diff.y1) {
                            rect.y1 += d;
                        }

                        if (rect.y2 === diff.y2) {
                            rect.y2 -= d;
                        }
                    }

                    if (rect.y1 === diff.y1 && rect.y2 === diff.y2) {
                        d = diff.width / 2;
                        if (rect.x2 === diff.x2) {
                            rect.x2 -= d;
                        }

                        if (rect.x1 === diff.x1) {
                            rect.x1 += d;
                        }
                    }
                }

                if (color && !color.transparent) {
                    var x1 = panel.position.x,
                        y1 = panel.position.y,
                        m = (new DPO.math.Matrix()).rotate(panel.rotation, x1, y1),
                        xs = [m.x(rect.x1, rect.y1), m.x(rect.x2, rect.y1), m.x(rect.x2, rect.y2), m.x(rect.x1, rect.y2)],
                        ys = [m.y(rect.x1, rect.y1), m.y(rect.x2, rect.y1), m.y(rect.x2, rect.y2), m.y(rect.x1, rect.y2)],
                        x2, y2;
                    x1 = Math.min.apply(Math, xs);
                    y1 = Math.min.apply(Math, ys);
                    x2 = Math.max.apply(Math, xs);
                    y2 = Math.max.apply(Math, ys);

                    background = me.instantiate('Background');
                    background.description = new DPO.model.Description();
                    background.description.index = -1;
                    background.position = me.instantiate('Position');
                    background.position.x = x1 - panel.position.x;
                    background.position.y = y1 - panel.position.y;
                    background.width = x2 - x1;
                    background.height = y2 - y1;
                    background.color = color.model;
                    background.spotColor = color.spot;
                    backgrounds.push(background);

                    me.addFieldToPanel(background, panel);

                    var order = me.selector.getFieldOrder(panel);
                    order.sendToBack([background]);
                    me.applyFieldOrder(order);
                }
            }

            if (backgrounds.length) {
                background = me.clone(backgrounds[0]);
                background.id = me.generateId('PF');
                background.contentId = background.id;
                background.geometryId = background.id;
                master.backgrounds.push(background);

                for (i = 0; i < backgrounds.length; i++) {
                    backgrounds[i].contentId = background.id;
                }

                me.selector.clearCache();
            }

            return result;
        },

        /**
         * Sets or remove solid background for master panel
         * @memberof DPO.project.Transformer#
         * @param {DPO.model.MasterPanel} master
         * @param {DPO.model.Color} [color]
         * @returns {object[]}
         */
        setBackgroundColor: function setBackgroundColor(master, color) {
            var me = this,
                result = me.transformBackgroundsToImages(master),
                pages = me.project.pages,
                i;
            me.removeSolidBackgrounds(master);

            for (i = 0; i < pages.length; i++) {
                var changes = me.setPageBackground(pages[i], master, color);
                result = result.concat(changes);
            }

            me.fireSequentialEvent('changed:editOne', [false]);

            return result;
        }
    });

    return Transformer;
});
DPO.def('project.Editor', function () {
    /**
     * @class DPO.project.Editor
     * @extends DPO.project.Transformer
     * @memberof DPO.project
     * @property {DPO.project.Transformer} pt
     * @property {DPO.model.Panel} panel
     * @property {boolean} editOne
     * @param {DPO.project.Transformer} projectTransformer
     * @param {DPO.model.Panel} panel
     * @param {boolean} [editOne]
     * @constructor
     */
    function Editor(projectTransformer, panel, editOne) {
        this.pt = projectTransformer;
        this.selector = projectTransformer.selector;
        this.panel = panel;
        this.editOne = !!editOne;
    }

    var aopBreakAdvice = {
        'centerFields': 1,
        'rotateField': 1,
        'scaleField': 1,
        'scaleFields': 1,
        'translateFields': 1,
        'alignFields': 1,
        'setOpacity': 2,
        'setFillColor': 2,
        'setOutlineColor': 2,
        'setOutlineWidth': 2,
        'setTextAngle': 2,
        'deleteFields': 0,
        'setProperties': 0
    };

    function wrapBreakingMethod(name, mode) {
        var str = 'function ' + name + '() {\n';
        str += '    var args =  Array.prototype.slice.call(arguments);\n';
        str += '    var f = args[0];\n';
        str += '    var c = this.breakRefsIfNeeded(f, ' + mode + ');\n';
        str += '    args[0] = f instanceof DPO.model.Field ? c[0] : c;\n';
        str += '    return this.pt.' + name + '.apply(this.pt, args);\n';
        str += '}\n';
        str += name + ';\n';
        /*jshint -W061 */
        return eval(str);
        /*jshint +W061 */
    }

    function wrapMethod(name) {
        var str = 'function ' + name + '() {\n';
        str += '    return this.pt.' + name + '.apply(this.pt, arguments);\n';
        str += '}\n';
        str += name + ';\n';
        /*jshint -W061 */
        return eval(str);
        /*jshint +W061 */
    }

    function createAspects(from, to) {
        var prototype = from;
        for (; prototype !== null; prototype = Object.getPrototypeOf(prototype)) {
            var keys = Object.keys(prototype);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i],
                    fn = prototype[key];
                if (typeof fn !== 'function') {
                    continue;
                }

                var mode = aopBreakAdvice[key];
                if (typeof mode === 'number') {
                    to[key] = wrapBreakingMethod(key, mode);
                } else {
                    to[key] = wrapMethod(key);
                }
            }
        }
    }

    createAspects(DPO.project.Transformer.prototype, Editor.prototype);

    DPO.mixin(Editor.prototype, {
        /**
         * Breaks field reverences if needed
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {number} mode
         */
        breakRefsIfNeeded: function breakRefsIfNeeded(fields, mode) {
            var changes = [];
            fields = fields instanceof DPO.model.Field ? [fields] : fields;
            if (this.editOne) {
                changes = this.pt.breakFieldRefs(fields, this.panel, mode);
            }

            return this.applyBreakChanges(fields, changes);
        },

        /**
         * Applies breaks changes
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Field[]} fields
         * @param {object[]} changes
         * @returns {DPO.model.Field[]}
         */
        applyBreakChanges: function applyBreakChanges(fields, changes) {
            var res = [].concat(fields);
            for (var i = 0; i < changes.length; i++) {
                var obj = changes[i];
                for (var j = 0; j < res.length; j++) {
                    res[j] = res[j] === obj.masterField ? obj.panelField : res[j];
                }
            }

            return res;
        },

        /**
         * Changes fields properties
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {object} properties
         * @returns {DPO.project.Transformer}
         */
        setProperties: function setProperties(fields, properties) {
            fields = fields instanceof Array ? fields : [fields];

            var mode = 0,
                keys = Object.keys(properties);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                switch (key) {
                    case 'position':
                    case 'rotation':
                    case 'width':
                    case 'height':
                        mode = mode | 1;
                        break;
                    default:
                        mode = mode | 2;
                        break;
                }
            }
            fields = this.breakRefsIfNeeded(fields, mode);
            return this.pt.setProperties(fields, properties);
        },

        /**
         * Add field to panel and creates field reference
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Field} field
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.project.Transformer}
         */
        addFieldToPanel: function addFieldToPanel(field, panel) {
            var me = this;
            return me.pt.addFieldToPanel(field, me.editOne ? panel : me.selector.selectMasterPanel(panel));
        },

        /**
         * Pastes fields to specified panel
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {DPO.model.Panel} panel
         * @returns {DPO.model.Field[]}
         */
        pasteFields: function pasteFields(fields, panel) {
            var me = this;
            panel = me.editOne ? panel : me.selector.selectMasterPanel(panel);
            return me.pt.pasteFields(fields, panel);
        },

        /**
         * Transforms background field to image field
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Background} background
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {DPO.model.Image}
         */
        transformBackgroundToImage: function transformBackgroundToImage(background, panel) {
            var me = this,
                c = me.breakRefsIfNeeded(background, 3);

            if (!me.editOne) {
                var mp = me.selector.selectMasterPanel(panel),
                    result = me.selector.belongToMasterPanel([background], mp);

                if (result.length > 0) {
                    panel = mp;
                }
            }

            return me.pt.transformBackgroundToImage(c[0], panel);
        },

        /**
         * Transforms image field to background field
         * @memberof DPO.project.Editor#
         * @param {DPO.model.Image} image
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @returns {{background: DPO.model.Background, transformBackgrounds: DPO.model.Image[]}}
         */
        transformImageToBackground: function transformImageToBackground(image, panel) {
            var me = this;

            if (me.editOne) {
                var c = me.breakRefsIfNeeded(image, 3),
                    order = me.selector.getFieldOrder(panel),
                    backgrounds = [];
                for (var i = 0; i < order.items.length; i++) {
                    var item = order.items[i];
                    if (item.field instanceof DPO.model.Background) {
                        backgrounds.push(item.field);
                    }
                }

                me.breakRefsIfNeeded(backgrounds, 3);
                return me.pt.transformImageToBackground(c[0], panel);
            } else {
                var mp = me.selector.selectMasterPanel(panel),
                    result = me.selector.belongToMasterPanel([image], mp);

                return me.pt.transformImageToBackground(image, result.length > 0 ? mp : panel);
            }
        },

        /**
         * Set solid background for master panel
         * @memberof DPO.project.Editor#
         * @param {DPO.model.MasterPanel} mp
         * @param {DPO.model.Color} [color]
         * @returns {object[]}
         */
        setBackgroundColor: function setBackgroundColor(mp, color) {
            var me = this;

            if (me.editOne) {
                var order = me.selector.getFieldOrder(mp),
                    backgrounds = [];
                for (var i = 0; i < order.items.length; i++) {
                    var item = order.items[i];
                    if (item.field instanceof DPO.model.Background) {
                        backgrounds.push(item.field);
                    }
                }

                me.breakRefsIfNeeded(backgrounds, 3);
            }

            return me.pt.setBackgroundColor(mp, color);
        },

        /**
         * Creates image background
         * @memberof DPO.project.Editor#
         * @param {string} source
         * @param {number} width
         * @param {number} height
         * @param {DPO.model.Panel|DPO.model.MasterPanel} panel
         * @param {boolean} [keepAspect]
         * @returns {{background: *, transformBackgrounds: (*|DPO.model.Image[])}}
         */
        createBackground: function createBackground(source, width, height, panel, keepAspect) {
            var me = this;
            panel = me.editOne ? panel : me.selector.selectMasterPanel(panel);
            return me.pt.createBackground(source, width, height, panel, keepAspect);
        },

        /**
         * Applies new field order
         * @memberof DPO.project.Editor#
         * @param {DPO.model.FieldOrder} order
         * @param {boolean} [silent]
         * @returns {DPO.project.Transformer}
         */
        applyFieldOrder: function applyFieldOrder(order, silent) {
            if (this.editOne) {
                return this.applyFieldOrderForSingle(order, silent);
            } else {
                return this.applyFieldOrderForMultiple(order, silent);
            }
        }
    });

    return Editor;
});

DPO.def('project.Validator', function () {
    /**
     * Validation Info Object
     * @typedef {Object} DPO.project.ValidationInfo
     * @memberof DPO.project
     * @property {DPO.model.Field} field
     * @property {DPO.model.Panel} panel
     * @property {DPO.model.Page} page
     * @property {string} messageCode
     * @property {string} type
     */

    /**
     * @class DPO.project.Validator
     * @extends DPO.model.Selector
     * @memberof DPO.project
     * @param {DPO.model.Project} project
     * @param {DPO.project.Binder} binder
     * @param {DPO.text.LayoutManager} layoutManager
     * @param {DPO.model.Selector} selector
     * @param {object} [cfg]
     * @constructor
     */
    function Validator(project, binder, layoutManager, selector, cfg) {
        var me = this;
        me.binder = binder;
        me.layoutManager = layoutManager;
        me.selector = selector;
        me.safeAreas = {};
        me.validationCounter = 0;
        me.validationCache = {};
        DPO.model.Selector.call(me, project);
        DPO.mixin(me, cfg || {});
    }

    var expressions = {
        url: /^(?:(?:https?|ftp):\/\/|www\.)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/im, // jshint ignore:line
        digits: /^\d+$/m, ///////just digits
        email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/m,
        partOfName: /([A-Z][a-z]*)([\\s'\-][A-Z][a-z]*)*/m,
        ecc: /^[LlMmQqHh]$/m,
        Codabar: /^[A-D\n\s][0-9\+$:\-/.\n\s]*[A-D\n\s]$/m,
        CodabarValue: /^[0-9\+$:\-/.\n\s]+$/m,
        Code39: /^[0-9A-Z\-.$/\+%\*\s]+$/m,
        Code128: /^[\000-\177]+$/m,
        MaxiCode: /^[\011\012\015\040-\177]+$/m,
        PDF417: /^[\011\012\015\040-\177]+$/m,
        Code39X: /^[0-9\w\-.$/\+%\*\s]+$/m,
        Postnet: /(^[\d]{5}$)|(^[\d]{9}$)|(^[\d]{11}$)/m,
        RM4SCC: /^([\dA-Z]+)$/m,
        DataMatrix: /./m
    };

    // Static methods
    DPO.mixin(Validator, {
        /**
         * Validates URL format
         * @memberof DPO.project.Validator
         * @param {string} data
         * @returns {number}
         */
        url: function url(data) {
            return expressions.url.test(data) ? null : 14;
        },

        digits: function digits(data) {
            return expressions.digits.test(data) ? null : 1;
        },

        email: function email(data) {
            return expressions.email.test(data) && data !== '' ? null : 13;
        },

        ecc: function ecc(data) {
            return expressions.ecc.test(data) ? null : 15;
        },

        codabar: function codabar(data) {
            return expressions.Codabar.test(data) ? null : 1;
        },

        codabarValue: function codabar(data) {
            return expressions.CodabarValue.test(data) ? null : 1;
        },

        dataMatrixValue: function dataMatrixValue(data) {
            return expressions.DataMatrix.test(data) ? null : 1;
        },

        code39: function code39(data) {
            return expressions.Code39.test(data) ? null : 1;
        },

        code128: function code128(data) {
            return expressions.Code128.test(data) ? null : 1;
        },

        maxicode: function maxicode(data) {
            return expressions.MaxiCode.test(data);
        },

        pdf417: function pdf417(data) {
            return expressions.PDF417.test(data) ? null : 1;
        },

        code39x: function code39x(data) {
            return expressions.Code39X.test(data) ? null : 1;
        },

        postnet: function postnet(data) {
            var error = null;
            if (!expressions.Postnet.test(data)) {
                error = 1;
            }
            if (data.length !== 5 && data.length !== 9 && data.length !== 11) {
                error = 23;
            }
            return error;
        },

        rm4scc: function rm4scc(data) {
            return expressions.RM4SCC.test(data);
        },

        ean13: function ean13(data) {
            var error = null;
            if (!expressions.digits.test(data)) {
                error = 1;
            }
            if (data.length !== 12 && data.length !== 13) {
                error = 20;
            }
            return error;
        },

        ean8: function ean8(data) {
            var error = null;
            if (!expressions.digits.test(data)) {
                error = 1;
            }
            if (data.length !== 7 && data.length !== 8) {
                error = 21;
            }
            return error;
        },

        intelligentMail: function intelligentMail(data) {
            var error = null;
            if (!expressions.digits.test(data)) {
                error = 1;
            }
            if ((data.length !== 25) && (data.length !== 20) && (data.length !== 29) && (data.length !== 31)) {
                error = 22;
            }
            return error;
        },

        upca: function upca(data) {
            var error = null;
            if (!expressions.digits.test(data)) {
                error = 1;
            }
            if ((data.length !== 12) && (data.length !== 11)) {
                error = 24;
            }
            return error;
        },

        website: function website(data) {
            return expressions.url.test(data) && data !== '' ? null : 18;
        },

        //Customer number (2 numeric digits)
        only2digits: function only2digits(data) {
            var error = null;
            if (!expressions.digits.test(data) || (('' + data).length !== 2)) {
                error = 30;
            }
            return error;
        },

        //Mailing number (6 numeric digits)
        only6digits: function only6digits(data) {
            var error = null;
            if (!expressions.digits.test(data) || (('' + data).length !== 6)) {
                error = 32;
            }
            return error;
        },

        //Postal zone (5 numeric digits)
        only5digits: function only5digits(data) {
            var error = null;

            if (!expressions.digits.test(data) || (('' + data).length !== 5)) {
                error = 31;
            }
            return error;
        },

        //Street number (3 numeric digits)
        //House number (3 numeric digits)
        only3digits: function only3digits(data) {
            var error = null;
            if (!expressions.digits.test(data) || (('' + data).length !== 3)) {
                error = 34;
            }
            return error;
        }
    });

    DPO.mixin(Validator.prototype, {
        panelSafelineRenderLimit: 450,
        minimumReadableCharacterHeight: 3,
        accuracy: 0.5,
        safeAreaOffset: 90,
        bleedAreaOffset: 90,

        /**
         * @memberof DPO.project.Validator#
         */
        beginValidation: function beginValidation() {
            this.validationCounter++;
        },

        /**
         * @memberof DPO.project.Validator#
         */
        endValidation: function endValidation() {
            this.validationCounter--;
            if (this.validationCounter === 0) {
                this.validationCache = {};
            }
        },

        /**
         * Validates text block font size
         * @memberof DPO.project.Validator#
         * @param {DPO.model.TextBlock} field
         * @returns {DPO.project.ValidationInfo}
         */
        validateTextSize: function validateTextSize(field) {
            var me = this,
                spans = me.getFieldSpans(field),
                smallText = me.hasSmallText(spans);
            return smallText ? {
                field: field,
                messageCode: 'text-size',
                type: 'caution'
            } : null;
        },

        /**
         * Validates text block color
         * @memberof DPO.project.Validator#
         * @param {DPO.model.TextBlock} field
         * @returns {DPO.project.ValidationInfo}
         */
        validateTextColor: function validateTextColor(field) {
            var me = this,
                spans = me.getFieldSpans(field);

            function checkIfWhite(color) {
                var regexp = /(f[0-9,a-f]){3}/gmi,
                    matches = regexp.test(color);
                return (matches);
            }

            for (var i = 0; i < spans.length; i++) {
                if (checkIfWhite(spans[i].color.toLowerCase())) {
                    return {
                        field: field,
                        panel: null,
                        page: null,
                        messageCode: 'text-color-white',
                        type: 'did-you-know'
                    };
                }
            }
            //noinspection JSValidateTypes
            return null;
        },

        /**
         * Validates text block color
         * @memberof DPO.project.Validator#
         * @param {DPO.model.TextBlock} field
         * @returns {DPO.project.ValidationInfo}
         */
        validateTextExtraSpaces: function validateTextExtraSpaces(field) {
            var me = this,
                spans = me.getFieldSpans(field),
                exp = /\s{4}/gi;
            for (var i = 0; i < spans.length; i++) {
                var text = spans[0].value;
                if (text.match(exp)) {
                    return {
                        field: field,
                        panel: null,
                        page: null,
                        messageCode: 'caution-extra-spaces',
                        type: 'caution'
                    };
                }
            }
            //noinspection JSValidateTypes
            return null;
        },

        /**
         * Get all spans from field
         * @memberof DPO.project.Validator#
         * @param {Object} field
         * @returns {Array}
         */
        getFieldSpans: function getFieldSpans(field) {
            var paragraphs = field.text.textFlow.paragraphs,
                spans = [];
            for (var i = 0; i < paragraphs.length; i++) {
                spans = spans.concat(paragraphs[i].spans);
            }
            return spans;
        },

        /**
         * Checking for small text size
         * @memberof DPO.project.Validator#
         * @param {Array} spans
         * @returns {Boolean}
         */
        hasSmallText: function hasSmallText(spans) {
            for (var i = 0; i < spans.length; i++) {
                var span = spans[i],
                    metrics = DPO.text.DefaultMetrics,
                    fontSize = span.fontSize,
                    fontMetrics = metrics.getMetrics(
                        span.fontFamily,
                        span.fontWeight === 'bold',
                        span.fontStyle === 'italic'
                    );
                if (this.getSmallestCharHeight(fontMetrics, fontSize) < this.minimumReadableCharacterHeight) {
                    return true;
                }
            }

            return false;
        },

        /**
         * Get height of 'x'(smallest) char
         * @memberof DPO.project.Validator#
         * @param {Array} metrics
         * @param {Number} fontSize
         * @returns {Number} height of 'x' in pt
         */
        getSmallestCharHeight: function getSmallestCharHeight(metrics, fontSize) {
            var xHeight = metrics[5],
                unitsPerEm = metrics[1];

            return xHeight / unitsPerEm * fontSize;
        },

        /**
         * Returns drawing bounds
         * @memberof DPO.project.Validator#
         * @param {DPO.model.Field} drawing
         * @returns {DPO.math.Polygon[]}
         */
        getDrawingBoundsComponents: function getDrawingBoundsComponents(drawing) {
            var x = drawing.position.x,
                y = drawing.position.y,
                width = drawing.width,
                height = drawing.height,
                m = new DPO.math.Matrix(),
                m1 = new DPO.math.Matrix(),
                polygons = [],
                polygon;
            m.rotate(360 - drawing.rotation, x, y);
            m1.translate(x, y);
            switch (drawing.shape) {
                case 'ellipse':
                    var c = new DPO.math.Point(x + width / 2, y + height / 2),
                        e = new DPO.math.Ellipse(c, width / 2, height / 2);
                    polygon = e.polygonize(0, 360, 32);
                    break;
                case 'polygon':
                    polygon = drawing.polypoints.polygonize();
                    polygon.transform(m1);
                    break;
                default:
                    polygon = new DPO.math.Polygon([x, y, x + width, y, x + width, y + height, x, y + height]);
                    break;
            }
            polygons.push(polygon.transform(m));
            return polygons;
        },

        /**
         * Returns TextBlock bounds
         * @memberof DPO.project.Validator#
         * @param {DPO.model.TextBlock} field
         * @returns {DPO.math.Polygon[]}
         */
        getTextBlockBoundsComponents: function getTextBlockBoundsComponents(field) {
            var me = this,
                x = field.position.x,
                y = field.position.y,
                m = new DPO.math.Matrix(),
                polygons = [],
                containers = me.layoutManager.layoutTextBlock(/** @type DPO.model.TextBlock*/field),
                container, lines, line, polygon;
            m.rotate(360 - field.rotation, x, y);
            for (var i = 0; i < containers.length; i++) {
                container = containers[i];
                lines = container.lines;
                for (var j = 0; j < lines.length; j++) {
                    line = lines[j];

                    var x1 = x + line.offsetX * 20,
                        y1 = y + (container.offset + line.offsetY - line.ascender) * 20,
                        x2 = x1 + line.visibleWidth * 20,
                        y2 = y1 + line.height * 20;
                    polygon = new DPO.math.Polygon([x1, y1, x2, y1, x2, y2, x1, y2]);
                    polygons.push(polygon.transform(m));
                }
            }

            return polygons;
        },

        /**
         * Returns TextPath bounds
         * @memberof DPO.project.Validator#
         * @param {DPO.model.TextPath} field
         * @returns {DPO.math.Polygon[]}
         */
        getTextPathBoundsComponents: function getTextPathBoundsComponents(field) {
            var me = this,
                x = field.position.x,
                y = field.position.y,
                width = field.width,
                height = field.height,
                m = new DPO.math.Matrix(),
                polygons = [],
                containers = me.layoutManager.layoutTextBlock(/** @type DPO.model.TextBlock*/field),
                container = containers[0],
                line = container.lines[0],
                polygon;
            m.rotate(360 - field.rotation, x, y);

            var halfLine = line.width * 10;
            if (halfLine) {
                var span = line.getLargestSpan(),
                    middleDeg = (720 - field.textAngle) % 360,
                    fm = me.layoutManager.fontMetrics,
                    metrics = fm.getMetricsForSpan(span),
                    ascender = fm.getAscender(metrics, span.fontSize),
                    center = new DPO.math.Point(x + width / 2, y + height / 2),
                    ellipse = new DPO.math.Ellipse(center, width / 2, height / 2),
                    middleRad = DPO.math.rad(middleDeg),
                    deltaRad = ellipse.endOfCircumference(middleRad, halfLine, 20) - middleRad,
                    deltaDeg = Math.min(DPO.math.deg(deltaRad), 180),
                    p1 = ellipse.polygonize(middleDeg - deltaDeg, middleDeg + deltaDeg, 32).transform(m);
                ellipse = new DPO.math.Ellipse(center, width / 2 + ascender * 20, height / 2 + ascender * 20);
                polygon = ellipse.polygonize(middleDeg - deltaDeg, middleDeg + deltaDeg, 32);
                polygon.transform(m).reverse();
                polygons.push(p1.concat(polygon));
            }

            return polygons;
        },

        /**
         * Returns field bounds
         * @memberof DPO.project.Validator#
         * @param {DPO.model.Field} field
         * @returns {DPO.math.Polygon[]}
         */
        getFieldBoundsComponents: function getFieldBounds(field) {
            var me = this,
                polygons = [],
                polygon;

            switch (field.constructor) {
                case DPO.model.TextBlock:
                    polygons = me.getTextBlockBoundsComponents(/** @type DPO.model.TextBlock*/field);
                    break;
                case DPO.model.TextPath:
                    polygons = me.getTextPathBoundsComponents(/** @type DPO.model.TextPath*/field);
                    break;
                case DPO.model.Drawing:
                    polygons = me.getDrawingBoundsComponents(/** @type DPO.model.Drawing*/field);
                    break;
                default:
                    var x = field.position.x,
                        y = field.position.y,
                        width = field.width,
                        height = field.height,
                        m = new DPO.math.Matrix();
                    m.rotate(360 - field.rotation, x, y);
                    polygon = new DPO.math.Polygon([x, y, x + width, y, x + width, y + height, x, y + height]);
                    polygons.push(polygon.transform(m));
                    break;
            }

            return polygons;
        },

        /**
         * Tests components
         * @memberof DPO.project.Validator#
         * @param {DPO.math.Polygon[]} components
         * @param {DPO.math.Polygon} polygon
         * @returns {{outside: boolean, intersects: boolean}}
         */
        testComponents: function testComponents(components, polygon) {
            var outside = components.length > 0,
                intersects = false;
            for (var i = 0; i < components.length; i++) {
                var p = components[i],
                    res = polygon.intersectsWithPolygon(p);
                outside = outside && res.outside;
                intersects = intersects || res.intersection;
            }

            return {
                outside: outside,
                intersects: intersects
            };
        },

        /**
         * Returns cutouts areas for specified master panel
         * @memberof DPO.project.Validator#
         * @param {DPO.model.MasterPanel} mp
         * @returns {DPO.math.Polygon[]}
         */
        getCutoutsAreas: function getCutoutsAreas(mp) {
            var cutouts = mp.cutouts,
                polygons = [],
                center, ellipse, polygon, m;

            for (var i = 0; i < cutouts.length; i++) {
                var cutout = cutouts[i],
                    position = cutout.position;

                switch (cutout.shape) {
                    case 'ellipse':
                        center = new DPO.math.Point(position.x + cutout.width / 2, position.y + cutout.height / 2);
                        ellipse = new DPO.math.Ellipse(center, cutout.width / 2, cutout.height / 2);
                        polygon = ellipse.polygonize(0, 360, 90);
                        break;
                    case 'polygon':
                        m = new DPO.math.Matrix();
                        m.translate(position.x, position.y);
                        polygon = cutout.polypoints.polygonize();
                        polygon.transform(m);
                        break;
                    default:
                        var x = position.x,
                            y = position.y,
                            rect = new DPO.math.Rect(x, y, x + cutout.width, y + cutout.height);
                        polygon = rect.polygonize();
                        break;
                }
                polygons.push(polygon);
            }

            return polygons;
        },

        /**
         * Return offset value for safe line
         * @memberof DPO.project.Validator#
         * @param {Snap} box
         * @return {number} offset
         */
        getSafeLineOffset: function getSafeLineOffset(box) {
            var me = this,
                boxMinSide = Math.min(box.width, box.height),
                offset = -me.safeAreaOffset;

            if (boxMinSide <= me.panelSafelineRenderLimit) {
                offset = 0;
            }

            return offset;
        },

        /**
         * Returns safe & bleed areas for specified master panel
         * @memberof DPO.project.Validator#
         * @param {DPO.model.MasterPanel} mp
         * @returns {DPO.math.Rect|DPO.math.Polygon}
         */
        getAreas: function getAreas(mp) {
            var me = this,
                areas = me.safeAreas[mp.id],
                offset = me.getSafeLineOffset(mp),
                ellipse, trimArea, safeArea, bleedArea, matrix, sx, sy, center;
            if (!areas) {
                center = new DPO.math.Point(mp.width / 2, mp.height / 2);
                areas = {center: center};

                trimArea = new DPO.math.Rect(0, 0, mp.width, mp.height);
                bleedArea = new DPO.math.Rect(0, 0, mp.width, mp.height);
                safeArea = new DPO.math.Rect(0, 0, mp.width, mp.height);
                safeArea.inflate(offset + me.accuracy, offset + me.accuracy);
                if (mp.bleed) {
                    bleedArea.inflate(me.bleedAreaOffset - me.accuracy, me.bleedAreaOffset - me.accuracy);
                }

                switch (mp.shape) {
                    case 'ellipse':
                        ellipse = new DPO.math.Ellipse(center, trimArea.width / 2, trimArea.height / 2);
                        areas.trim = ellipse.polygonize(0, 360, 90);

                        ellipse = new DPO.math.Ellipse(center, safeArea.width / 2, safeArea.height / 2);
                        areas.safe = ellipse.polygonize(0, 360, 90);

                        ellipse = new DPO.math.Ellipse(center, bleedArea.width / 2, bleedArea.height / 2);
                        areas.bleed = ellipse.polygonize(0, 360, 90);
                        break;
                    case 'polygon':
                        areas.trim = mp.polypoints.polygonize();

                        areas.safe = mp.polypoints.polygonize();
                        matrix = new DPO.math.Matrix();
                        sx = safeArea.width / mp.width;
                        sy = safeArea.height / mp.height;
                        matrix.scale(sx, sy, center.x, center.y);
                        areas.safe.transform(matrix);

                        areas.bleed = mp.polypoints.polygonize();
                        matrix = new DPO.math.Matrix();
                        sx = bleedArea.width / mp.width;
                        sy = bleedArea.height / mp.height;
                        matrix.scale(sx, sy, center.x, center.y);
                        areas.bleed.transform(matrix);
                        break;
                    default:
                        areas.trim = trimArea.polygonize();
                        areas.safe = safeArea.polygonize();
                        areas.bleed = bleedArea.polygonize();
                        break;
                }

                me.safeAreas[mp.id] = areas;
            }
            return areas;
        },

        /**
         * Validates image position
         * @memberof DPO.project.Validator#
         * @param {DPO.math.Polygon[]} components
         * @param {object} areas
         * @returns {object[]}
         */
        validateImagePosition: function validateImagePosition(components, areas) {
            var polygon = components[0],
                result = [],
                map = {},
                segments = polygon.cutToSegments(),
                i, segment, points, b, t, s, weight;
            for (i = 0; i < segments.length; i++) {
                segment = segments[i];

                points = areas.bleed.intersectionsWithLineSegment(segment);
                b = points.length;

                points = areas.trim.intersectionsWithLineSegment(segment);
                t = points.length;

                points = areas.safe.intersectionsWithLineSegment(segment);
                s = points.length;

                weight = Math.abs(b - t) - Math.abs(t - s);
                if (weight < 0) {
                    map['image-outside-safe-area'] = 1;
                }

                if (weight > 0) {
                    map['image-inside-bleed-area'] = 1;
                }
            }

            var keys = Object.keys(map);
            for (i = 0; i < keys.length; i++) {
                result.push({
                    messageCode: 'image-outside-safe-area',
                    type: 'warning',
                    validation: keys[i]
                });
            }

            return result;
        },

        /**
         * Validates specified field
         * @memberof DPO.project.Validator#
         * @param {DPO.model.Field} field
         * @param {DPO.model.Panel} panel
         * @param {DPO.model.Page} page
         * @returns {DPO.project.ValidationInfo[]}
         */
        validateField: function validateField(field, panel, page) {
            var me = this,
                result = me.validationCache[field.id];
            if (result) {
                return result;
            }

            var mp = me.selector.selectMasterPanel(panel),
                areas = me.getAreas(mp),
                index = me.selector.panelIndex(panel),
                f = me.binder.bindDataToField(field, index),
                components = me.getFieldBoundsComponents(f),
                cutouts = me.getCutoutsAreas(mp);

            result = [];

            function validateTextBlock(field) {
                var errors = [];
                var res = me.validateTextSize(/** @type DPO.model.TextBlock */field);
                if (res) {
                    errors.push(res);
                }
                var res2 = me.validateTextColor(/** @type DPO.model.TextBlock */field);
                if (res2) {
                    errors.push(res2);
                }
                var res3 = me.validateTextExtraSpaces(/** @type DPO.model.TextBlock */field);
                if (res3) {
                    errors.push(res3);
                }
                return errors;
            }

            function pushIf(condition, code, type, validationError) {
                if (condition) {
                    result.push({
                        messageCode: code,
                        type: type,
                        validation: validationError
                    });
                }
            }

            var safeAreaTest = me.testComponents(components, areas.safe),
                insideSafeArea = !safeAreaTest.intersects && !safeAreaTest.outside,
                trimAreaTest = me.testComponents(components, areas.trim),
                insideTrimArea = !trimAreaTest.intersects && !trimAreaTest.outside,
                bleedAreaTest = me.testComponents(components, areas.bleed),
                insideBleedArea = !bleedAreaTest.intersects && !bleedAreaTest.outside,
                msg, type, validationErr, res;

            var cutoutsTest = [];
            for (var j = 0; j < cutouts.length; j++) {
                var cutoutTest = me.testComponents(components, cutouts[j]);
                cutoutsTest.push(cutoutTest);
            }

            switch (field.constructor) {
                case DPO.model.Drawing:
                    if (!insideSafeArea) {
                        msg = 'shape-outside-safe-area';
                        type = 'caution';
                        validationErr = 'shape-outside-safe-area';
                        if (!insideTrimArea) {
                            validationErr = 'shape-inside-bleed-area';
                        }
                    }

                    pushIf(!insideSafeArea && insideBleedArea, msg, type, validationErr);
                    break;
                case DPO.model.Image:
                    res = me.validateImagePosition(components, areas);
                    result = result.concat(res);
                    if (result.length === 0) {
                        bleedAreaTest = me.testComponents(components, areas.bleed);
                        insideBleedArea = !bleedAreaTest.intersects && !bleedAreaTest.outside;
                        pushIf(!insideSafeArea && insideTrimArea && insideBleedArea, 'image-outside-safe-area', 'warning', 'image-outside-safe-area');
                        pushIf(!insideSafeArea && !insideTrimArea && insideBleedArea, 'image-outside-safe-area', 'warning', 'image-inside-bleed-area');
                    }
                    break;
                case DPO.model.TextPath:
                case DPO.model.TextBlock:
                    res = validateTextBlock(/** @type DPO.model.TextBlock */field);
                    result = result.concat(res);

                    pushIf(!insideSafeArea, 'text-outside-safe-area', 'warning', 'text-outside-safe-area');
                    for (var k = 0; k < cutoutsTest.length; k++) {
                        pushIf(cutoutsTest[k].intersects, 'text-intersect-cutout', 'warning', 'text-outside-safe-area');
                    }
                    break;
                case DPO.model.Barcode:
                    validationErr = 'barcode-outside-safe-area';

                    pushIf(!insideSafeArea, 'barcode-outside-safe-area', 'warning', 'barcode-outside-safe-area');
                    for (var l = 0; l < cutoutsTest.length; l++) {
                        pushIf(cutoutsTest[l].intersects, 'barcode-intersect-cutout', 'warning', 'barcode-outside-safe-area');
                    }
                    break;
                default:
                    break;
            }

            for (var i = 0; i < result.length; i++) {
                var r = result[i];
                r.merged = field !== f;
                r.field = field;
                r.panel = panel;
                r.page = page;
                r.components = components;
                r.areas = areas;
                r.cutouts = cutouts;
            }

            if (f === field) {
                me.validationCache[field.id] = result;
            }

            return result;
        },

        /**
         * Validates specified panel
         * @memberof DPO.project.Validator#
         * @param {DPO.model.Panel} panel
         * @param {DPO.model.Page} page
         * @returns {DPO.project.ValidationInfo[]}
         */
        validatePanel: function validatePanel(panel, page) {
            var me = this,
                order = me.selector.getFieldOrder(panel),
                fields = order.getFields(),
                result = [];
            me.beginValidation();
            for (var i = 0; i < fields.length; i++) {
                result = result.concat(me.validateField(fields[i], panel, page));
            }
            me.endValidation();
            return result;
        },

        /**
         * Validates specified page
         * @memberof DPO.project.Validator#
         * @param {DPO.model.Page} page
         * @returns {DPO.project.ValidationInfo[]}
         */
        validatePage: function validatePage(page) {
            var me = this,
                panels = page.panels,
                result = [];
            me.beginValidation();
            for (var i = 0; i < panels.length; i++) {
                result = result.concat(me.validatePanel(panels[i], page));
            }
            me.endValidation();
            return result;
        },

        /**
         * Validates whole project
         * @memberof DPO.project.Validator#
         * @returns {DPO.project.ValidationInfo[]}
         */
        validateProject: function validateProject() {
            var me = this,
                pages = me.project.pages,
                result = [];
            me.beginValidation();
            for (var i = 0; i < pages.length; i++) {
                result = result.concat(me.validatePage(pages[i]));
            }
            me.endValidation();
            return me.filterValidation(result);
        },

        /**
         * Filters validation information
         * @memberof DPO.project.Validator#
         * @param {DPO.project.ValidationInfo[]} validations
         * @returns {DPO.project.ValidationInfo[]}
         */
        filterValidation: function filterValidation(validations) {
            var result = [].concat(validations),
                i, j, v1, v2;
            for (i = 0; i < result.length; i++) {
                v1 = result[i];
                for (j = result.length - 1; j > i; j--) {
                    v2 = result[j];
                    if (!v2.merged && v1.field === v2.field && v1.messageCode === v2.messageCode) {
                        result.splice(j, 1);
                    }
                }
            }

            return result;
        }
    });

    return Validator;
});
DPO.def('project.BarcodeGenerator', function () {
    /**
     * Creates new Barcode Generator <br/>
     * see {@link http://www.neodynamic.com/Products/Help/BarcodeWinControl2.5/working_barcode_symbologies.htm|RegEx for input data validation }
     * @class DPO.project.BarcodeGenerator
     * @param {number} [scale=1]
     * @constructor
     */
    function BarcodeGenerator(scale) {
        var me = this;
        me.scale = scale || 4;
        me.validator = DPO.project.Validator;
    }

    function convertMilsToPoints(mils) {
        return mils * 0.005;
    }

    DPO.mixin(BarcodeGenerator.prototype, {
        /**
         * Returns checksum of data, used for creating UPC-A, EAN 13, EAN 8
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data
         * @param {boolean} isOddFirst - need to multiply 3 and sum of elements in odd/even positions
         * @returns {*} data and checksum in the end
         */
        getCheckSum: function getCheckSum(data, isOddFirst) {
            var sumOdd = 0,
                sumEven = 0;

            data = data || '';
            for (var i = data.length - 1; i >= 0; i--) {
                if ((i + 1) % 2 !== 0) {
                    sumOdd += data[i] - 0;
                } else {
                    sumEven += data[i] - 0;
                }
            }
            var res = (isOddFirst) ? (sumOdd * 3 + sumEven) % 10 : (sumOdd + sumEven * 3) % 10;
            data += ((res === 0) ? 0 : (10 - res));

            return data;
        },

        /**
         * Creates Codabar
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Numeric digits, including -, ., $, :, /, +.
         * The first and the last characters can be only next letters: A , b,C,D
         * @param {number} [xunit=0.72] - Measured in points. Minimum value is 0.72 - The size of the X-Dimension
         * @param {boolean} [showText=true] - Display text below the code
         */
        Codabar: function Codabar(data, xunit, showText) {
            var me = this,
                query = 'Codabar',
                params = null,
                error;

            data = data || '';
            xunit = xunit || 0.72;
            showText = (showText === undefined) ? true : showText;

            error = me.validator.codabar(data);
            if (error === null) {
                params = {
                    data: data,
                    xunit: xunit,
                    scale: me.scale,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, // 'Codabar?data=A1$C&xunit=0.72&scale=4&showText=true'
                params: params
            };
        },

        /**
         * Creates Code39
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Uppercase letters, including digits -, ., $, /, +, % and space
         * @param {boolean} checksum - Use check digit
         * @param {boolean} [showText=true] - Display text below the code
         * @param {number} [xunit=0.72] - Measured in points. Minimum value is 0.72 - The size of the X-Dimension
         */
        Code39: function Code39(data, checksum, showText, xunit) {
            var me = this,
                query = 'Code 39',
                error = null,
                params = null;

            data = data || '';
            xunit = xunit || 0.72;
            showText = (showText === undefined) ? true : showText;
            if (me.validator.code39(data) === 1) {
                error = 1;
            } else {
                params = {
                    data: data,
                    xunit: xunit,
                    scale: me.scale,
                    checksum: checksum,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, //'Code 39?data=DF3 2D-S%D&xunit=0.72&scale=4&checksum=true&showText=true'
                params: params
            };
        },

        /**
         * Creates Code128
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Numeric digits or characters
         * @param {boolean} [showText=true]
         * @param {number} [xunit=0.72] - Measured in points. Minimum value is 0.72
         */
        Code128: function Code128(data, showText, xunit) {
            var me = this,
                minXunit = convertMilsToPoints(7.5),//xunit for Code128 is 0.75 mil
                query = 'Code 128',
                error = null,
                params = null;

            data = data || '';
            xunit = xunit && xunit > minXunit ? xunit : minXunit;
            showText = (showText === undefined) ? true : showText;

            if (me.validator.code128(data) === 1) {
                error = 1;
            } else {
                params = {
                    data: data,
                    xunit: xunit,
                    scale: me.scale,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, //'Code 128?data=s3 *&xunit=0.72&scale=4&showText=true'
                params: params
            };
        },

        /**
         * Creates 25 Interleaved
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Only numeric digits
         * @param {boolean} checksum - Use check digit
         * @param {boolean} [showText=true]
         * @param {number} [xunit=0.72] - Measured in points. Minimum value is 0.72
         */
        Interleaved25: function Interleaved25(data, checksum, showText, xunit) {
            var me = this,
                query = '25 Interleaved',
                params = null,
                error;

            data = data || '';
            xunit = xunit || 0.72;
            showText = (showText === undefined) ? true : showText;
            error = me.validator.digits(data);

            if (error === null) {
                params = {
                    data: data,
                    xunit: xunit,
                    scale: me.scale,
                    checksum: checksum,
                    showText: showText
                };

            }
            return {
                error: error, // number
                query: query, //'25 Interleaved?data=1234567890&xunit=0.72&scale=4&checksum=true&showText=true'
                params: params
            };
        },

        /**
         * Creates UPC-A
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - 12 numeric digits. The last digit of data is check. For more info see REST
         * @param {boolean} [showText=true]
         */
        UPCA: function UPCA(data, showText) {
            var me = this,
                query = 'UPC-A',
                params = null,
                error;

            data = data || '';
            showText = (showText === undefined) ? true : showText;
            error = me.validator.upca(data);

            if (data.length === 11 && error === null) {
                data = this.getCheckSum(data, true);
            } else if (data.length === 12 && error === null) {
                var calcChecksum = this.getCheckSum(data.substr(0, data.length - 1), true);
                if (calcChecksum[calcChecksum.length - 1] !== data[data.length - 1]) {
                    error = 12;
                }
            }

            if (error == null) {
                params = {
                    data: data,
                    scale: me.scale,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, //'UPC-A?data=123456789012&scale=4&showText=true'
                params: params
            };
        },

        /**
         * Creates DeutschePostLeitCode
         * @memberof DPO.project.BarcodeGenerator#
         * @param {number} postalCode - Postal zone - 5 numeric digits
         * @param {number} streetNumber - Street number - 3 numeric digits
         * @param {number} houseNumber - House number - 3 numeric digits
         * @param {number} productCode - Product number - 2 numeric digits
         * @param {boolean} [showText=true]
         */
        DeutschePostLeitCode: function DeutschePostLeitCode(postalCode, streetNumber, houseNumber, productCode, showText) {
            var me = this,
                query = 'DeutschePostLeitCode',
                error = me.validator.only5digits(postalCode),
                params = null;

            showText = (showText === undefined) ? true : showText;

            if (error === null) {
                error = me.validator.only3digits(streetNumber);
            }
            if (error === null) {
                error = me.validator.only3digits(houseNumber);
            }
            if (error === null) {
                error = me.validator.only2digits(productCode);
            }

            if (error === null) {
                params = {
                    streetNumber: streetNumber,
                    scale: me.scale,
                    houseNumber: houseNumber,
                    productCode: productCode,
                    showText: showText,
                    postalCode: postalCode
                };
            }
            return {
                error: error, // number
                query: query, //'DeutschePostLeitCode?streetNumber=222&scale=4&houseNumber=333&productCode=44&showText=true&postalCode=11111'
                params: params
            };
        },

        /**
         * Creates DeutschePostIdentCode
         * @memberof DPO.project.BarcodeGenerator#
         * @param {number} distribution - Distribution center code - 2 numeric digits
         * @param {number} customer - Customer number - 3 numeric digits
         * @param {number} mailing - Mailing number - 6 numeric digits
         * @param {boolean} [showText=true]
         */
        DeutschePostIdentCode: function DeutschePostIdentCode(distribution, customer, mailing, showText) {
            var me = this,
                query = 'DeutschePostIdentCode',
                error = me.validator.only2digits(distribution),
                params = null;

            showText = (showText === undefined) ? true : showText;
            if (error === null) {
                error = me.validator.only3digits(customer);
            }
            if (error === null) {
                error = me.validator.only6digits(mailing);
            }

            if (error === null) {
                params = {
                    scale: me.scale,
                    distribution: distribution,
                    customer: customer,
                    mailing: mailing,
                    showText: showText
                };

            }
            return {
                error: error, // number
                query: query, //'DeutschePostIdentCode?scale=4&distribution=11&customer=222 &mailing=333333&showText=true'
                params: params
            };
        },

        /**
         * Creates 25 InterleavedDeutschenpost
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Only numeric digits
         * @param {boolean} [showText=true]
         */
        InterleavedDeutschenpost25: function InterleavedDeutschenpost25(data, showText) {
            var me = this,
                expr = /^\d+$/gm,
                query = '25 Interleaved Deutschenpost',
                error = null,
                params = null;

            data = data || '';
            showText = (showText === undefined) ? true : showText;

            if (!expr.test(data)) {
                error = 1;
            } else {
                params = {
                    data: data,
                    scale: me.scale,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, //'25 Interleaved Deutschenpost?data=123456789&scale=4&showText=true'
                params: params
            };
        },

        /**
         * Creates MaxiCode
         * fixed sized : 1.11 x 1.054
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Barcode text
         * @param {boolean} [ecc=true] - Whether to use Extended Error Correction
         */
        MaxiCode: function MaxiCode(data, ecc) {
            var me = this,
                query = 'MaxiCode',
                error = null,
                params = null;

            data = data || '';
            ecc = (ecc === undefined) ? true : ecc;

            if (!me.validator.maxicode(data)) {
                error = 1;
            } else {
                params = {
                    data: data,
                    scale: me.scale,
                    ecc: ecc
                };
            }
            return {
                error: error, // number
                query: query, //'MaxiCode?data=sfsdf23E53223 04%SD&scale=4&ecc=false'
                params: params
            };
        },

        /**
         * Creates PDF417
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Barcode text
         * @param {number} securitylevel - How much error correction to apply:
         * to choose an appropriate level or a value from 0 (none) to 8 (512 bytes of error correction)
         * @param {number} columns - The number of data codeword columns in the code
         * @param {number} [xunit=0.72] - Measured in points. Minimum value is 0.72
         */
        PDF417: function PDF417(data, securitylevel, columns, xunit) {
            var me = this,
                query = 'PDF417',
                error = null,
                params = null;

            data = data || '';
            xunit = xunit || 0.72;

            if ((securitylevel < 0) || (securitylevel > 8)) {
                error = 11;
            }

            if (me.validator.pdf417(data) === 1) {
                error = 1;
            }
            if (error === null) {
                params = {
                    data: data,
                    xunit: xunit,
                    scale: me.scale,
                    securityLevel: securitylevel,
                    columns: columns
                };
            }
            return {
                error: error, // number
                query: query, //'PDF417?data=sDCf%ds1*2&xunit=0.72&scale=4&securityLevel=2&columns=1'
                params: params
            };
        },

        /**
         * Creates Code39X
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Alphanumeric characters, including digits -, ., $, /, +, % and space
         * @param {boolean} checksum - Use check digit
         * @param {boolean} [showText=true] - Display text below the code
         * @param {number} [xunit] - The size of the X-Dimension
         */
        Code39X: function Code39X(data, checksum, showText, xunit) {
            var me = this,
                query = 'Code 39X',
                error = null,
                params = null;

            data = data || '';
            xunit = xunit || 0.72;
            showText = (showText === undefined) ? true : showText;

            if (me.validator.code39x(data) === 1) {
                error = 1;
            } else {
                params = {
                    data: data,
                    xunit: xunit,
                    scale: me.scale,
                    checksum: checksum,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, //'Code 39X?data=34234fsdf$sdfDsdf&xunit=0.72&scale=4&checksum=true&showText=true'
                params: params
            };
        },

        /**
         * Creates Postnet
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - 5, 9 or 11 numeric digits
         */
        Postnet: function Postnet(data) {
            var me = this,
                query = 'Postnet',
                params = null,
                error;

            data = data || '';
            error = me.validator.postnet(data);

            if (error === null) {
                params = {
                    data: data,
                    scale: me.scale
                };
            }
            return {
                error: error, // number
                query: query, ////'Postnet?data=12345&scale=4'
                params: params
            };
        },

        /**
         * Creates EAN13
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - 12 or 13 digits - for more info see REST
         * @param {boolean} [showText=true] - Display text below the code
         */

        EAN13: function EAN13(data, showText) {
            var me = this,
                query = 'EAN 13',
                params = null,
                error;

            data = data || '';
            showText = (showText === undefined) ? true : showText;
            error = me.validator.ean13(data);

            if (data.length === 12 && error === null) {
                data = this.getCheckSum(data, false);
            } else if (data.length === 13 && error === null) {
                var calcChecksum = this.getCheckSum(data.substr(0, data.length - 1), false);
                if (calcChecksum[calcChecksum.length - 1] !== data[data.length - 1]) {
                    error = 12;
                }
            }

            if (error === null) {
                params = {
                    data: data,
                    scale: me.scale,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, ////'EAN 13?data=1234567890128&scale=4&showText=true'
                params: params
            };
        },

        /**
         * Creates EAN8
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - 7 or 8 digits - for more info see REST
         * @param {boolean} [showText=true] - Display text below the code
         */
        EAN8: function EAN8(data, showText) {
            var me = this,
                query = 'EAN 8',
                params = null,
                error;

            data = data || '';
            showText = (showText === undefined) ? true : showText;
            error = me.validator.ean8(data);

            if (data.length === 7 && error === null) {
                data = this.getCheckSum(data, true);
            } else if (data.length === 8 && error === null) {
                var calcChecksum = this.getCheckSum(data.substr(0, data.length - 1), true);
                if (calcChecksum[calcChecksum.length - 1] !== data[data.length - 1]) {
                    error = 12;
                }
            }
            if (error == null) {
                params = {
                    data: data,
                    scale: me.scale,
                    showText: showText
                };
            }
            return {
                error: error, // number
                query: query, //'EAN 8?data=01234565&scale=4&showText=true'
                params: params
            };
        },

        /**
         * Creates IntelligentMail
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - 20, 25, 29 or 31 numeric digits
         */
        IntelligentMail: function IntelligentMail(data) {
            var me = this,
                query = 'IntelligentMail',
                params = null,
                error;

            data = data || '';
            error = me.validator.intelligentMail(data);

            if (error === null) {
                params = {
                    data: data,
                    scale: me.scale
                };
            }
            return {
                error: error, // number
                query: query, ////'IntelligentMail?data=12345678901234567890&scale=4'
                params: params
            };
        },

        /**
         * Creates RM4SCC </br>
         * for info see : http://www.royalmail.com/sites/default/files/Royal-Mail-Mailmark-barcode-definition-document-May-2014-v3-1.pdf
         * @memberof DPO.project.BarcodeGenerator#
         * @param {string} data - Uppercase letters and numeric digits
         * @return {*} - in inch
         */
        RM4SCC: function RM4SCC(data) {
            var me = this,
                query = 'RM4SCC',
                error = null,
                params = null;

            data = data || '';

            if (me.validator.rm4scc(data)) {
                params = {
                    data: data,
                    scale: me.scale
                };
            } else {
                error = 1;
            }
            return {
                error: error, // number
                query: query, //RM4SCC?data=3213SD0&scale=4'
                params: params
            };
        },

        /**
         * Creates QRCode
         * for info about size see : http://twiki.org/cgi-bin/view/Blog/BlogEntry201102x2
         * @memberof DPO.project.BarcodeGenerator#
         * @returns {{error: *, query: ?string, params: *}}
         * @constructor
         */
        QRCode: function QRCode(barcode) {
            var me = this,
                query = 'QRCode',
                dataType = barcode.getProperty('dataType'),
                error = me.validator.ecc(barcode.getProperty('ecc')),
                value = null;
            if (error) {
                return {
                    error: error,
                    query: null,
                    params: null,
                    body: false
                };
            }

            function validateOnEmptiness (barcode) {
                var hasData = barcode.properties.some(function (property) {
                    return ['dataType', 'ecc'].indexOf(property.name) === -1 && !!property.value;
                });

                return hasData ? null : 1;
            }

            switch (dataType) {
                case 'text':
                case 'phoneNumber':
                    error = validateOnEmptiness(barcode);
                    break;
                case 'email':
                    error = me.validator.email(barcode.getProperty('data'));
                    break;
                case 'url':
                    error = me.validator.url(barcode.getProperty('data'));
                    break;
                case 'meCard':
                case 'vCard':
                    error = validateOnEmptiness(barcode);

                    value = barcode.getProperty('email');
                    if (error === null && value) {
                        error = me.validator.email(value);
                    }

                    value = barcode.getProperty('website');
                    if (error === null && value) {
                        error = me.validator.website(value);
                    }
                    break;
                default:
                    return {
                        error: 1532, // Unknown QR
                        query: null,
                        params: null,
                        body: false
                    };
            }

            var body = null;
            if (error === null) {
                var serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                    clone = serializer.introspector.clone(barcode);
                // Set geometry properties to default value.
                // Otherwise cache control will not works
                clone.position.x = 0;
                clone.position.y = 0;
                clone.width = 1000;
                clone.height = 1000;
                clone.rotation = 0;
                body = serializer.serializeToXML(clone);
            }

            return error == null ? {
                error: null,
                query: query,
                params: {
                    scale: this.scale,
                    data: body
                }
            } : {
                error: error,
                query: null,
                params: null,
                body: false
            };
        },

        /**
         * Creates Data Matrix Barcode
         * @memberof DPO.project.BarcodeGenerator#
         * @returns {{error: *, query: ?string, params: *, body: boolean}}
         * @constructor
         */
        DataMatrix: function DataMatrix(barcode) {
            var query = 'Data Matrix',
                error = null,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                body = serializer.serializeToXML(barcode, null, 'avery:barcode'),
                params;

            params = {
                scale: this.scale,
                data: body
            };

            return {
                error: error, // number
                query: query,
                params: params,
                body: true
            };
        },

        /**
         * Calculate checksum for special barcodes values
         * @memberof DPO.project.BarcodeGenerator#
         * @param {DPO.model.Barcode} barcode
         */
        calculateChecksum: function calculateChecksum(barcode) {
            var me = this,
                type = barcode.barcodeType,
                data = barcode.getProperty('data') || '',
                corrected;
            switch (type) {
                case 'UPC-A':
                    corrected = data.length === 11 ? me.getCheckSum(data, true) : null;
                    break;
                case 'EAN 8':
                    corrected = data.length === 7 ? me.getCheckSum(data, true) : null;
                    break;
                case 'EAN 13':
                    corrected = data.length === 12 ? me.getCheckSum(data, false) : null;
                    break;
            }

            if (corrected) {
                barcode.setProperty('data', corrected);
            }
        },

        /**
         * Returns barcode data
         * @memberof DPO.project.BarcodeGenerator#
         * @param {DPO.model.Barcode} barcode
         * @returns {{error: ?number, query: ?string, params: ?object, body: ?string}}
         */
        getBarcodeData: function getBarcodeData(barcode) {
            var type = barcode.barcodeType,
                value = barcode.getProperty('showText'),
                showText = /** @type boolean*/ (value == null ? true : value === 'true'),
                result;
            switch (type) {
                case 'MaxiCode':
                    result = this.MaxiCode(barcode.getProperty('data'), (barcode.getProperty('ecc') === 'true'));
                    break;
                case 'RM4SCC':
                    result = this.RM4SCC(barcode.getProperty('data'));
                    break;
                case 'Intelligent Mail':
                    result = this.IntelligentMail(barcode.getProperty('data'));
                    break;
                case 'EAN 8':
                    result = this.EAN8(barcode.getProperty('data'), showText);
                    break;
                case 'EAN 13':
                    result = this.EAN13(barcode.getProperty('data'), showText);
                    break;
                case 'Postnet':
                    result = this.Postnet(barcode.getProperty('data'));
                    break;
                case 'Code 39X':
                    result = this.Code39X(barcode.getProperty('data'), (barcode.getProperty('checksum') === 'true'),
                        showText, barcode.getProperty('xunit') - 0);
                    break;
                case 'PDF417':
                    result = this.PDF417(barcode.getProperty('data'), barcode.getProperty('securityLevel') - 0,
                        barcode.getProperty('columns') - 0, barcode.getProperty('xunit') - 0);
                    break;
                case '2/5 Interleaved DeutschePost':
                    result = this.InterleavedDeutschenpost25(barcode.getProperty('data'), showText);
                    break;
                case 'DeutschePost IdentCode':
                    result = this.DeutschePostIdentCode(barcode.getProperty('distribution'), barcode.getProperty('customer'),
                        barcode.getProperty('mailing'), showText);
                    break;

                case 'DeutschePost LeitCode':
                    result = this.DeutschePostLeitCode(barcode.getProperty('postalCode'), barcode.getProperty('streetNumber'),
                        barcode.getProperty('houseNumber'), barcode.getProperty('productCode'), showText);
                    break;
                case 'UPC-A':
                    result = this.UPCA(barcode.getProperty('data'), showText);
                    break;
                case '2/5 Interleaved':
                    result = this.Interleaved25(barcode.getProperty('data'), (barcode.getProperty('checksum') === 'true'),
                        showText, barcode.getProperty('xunit') - 0);
                    break;
                case 'Code 128':
                    result = this.Code128(barcode.getProperty('data'), showText, barcode.getProperty('xunit') - 0);
                    break;
                case 'Code 39':
                    result = this.Code39(barcode.getProperty('data'), (barcode.getProperty('checksum') === 'true'),
                        showText, barcode.getProperty('xunit') - 0);
                    break;
                case 'Codabar':
                    result = this.Codabar(barcode.getProperty('data'), barcode.getProperty('xunit') - 0, showText);
                    break;
                case 'QRCode':
                    result = this.QRCode(barcode);
                    break;
                case 'Data Matrix':
                    result = this.DataMatrix(barcode);
                    break;
                default:
                    return {
                        params: null,
                        body: null,
                        query: null,
                        error: 26754 // Unknown barcode
                    };
            }

            if (result.error == null && result.body) {
                // var s = new DPO.model.Serializer()
                // var xml = s.serializeToXML(barcode);
                // result.body = xml;
                result.body = 'Serialize Barcode';
            }
            return result;
        }
    });

    return BarcodeGenerator;
});
DPO.def('project.DividersCreator', function () {
    /**
     * Creates new Dividers Generator
     * @class DPO.project.DividersCreator
     * @constructor
     */
    function DividersCreator(context) {
        var me = this;
        me.context = context;
        me.project = context.project;
        me.panelSetOptions = context.project.panelSetOptions;
        me.currentSets = [];
        me.transformer = context.projectTransformer;
        me.setStartSettings();
        me.rectForPosition = new DPO.math.Rect(0, 0, me.project.masterPanels[0].width, me.project.masterPanels[0].height);
    }

    DPO.mixin(DividersCreator.prototype, {

        /** Get default image from project and return [url]
         * @returns {Array}
         */
        getDefaultImages: function getDefaultImages() {
            var me = this,
                urls = [];

            var mp = me.getMasterPanelById(me.panelSetOptions.master);
            if (mp.images.length > 0) {
                urls.push(me.context.storage.urlForField(mp.images[0]));
            }
            return urls;
        },

        /** Set start settings according to panelSetOptions
         * @memberof DPO.project.DividersCreator#
         */
        setStartSettings: function setStartSettings() {
            var me = this;
            me.isLeftImagePosition = true;
            me.panelsPerSet = me.panelSetOptions.panelsPerSet || 5; //ToDo: remove 5, there must be value > 0 from project settings

            if (me.panelsPerSet === 1 && me.panelSetOptions.backMaster) {
                me.autocopyDividers = true;
                me.panelsPerSet = me.project.pages[0].panels.length / 2;
                me.reverseBackSet = false;
            } else {
                me.reverseBackSet = me.panelSetOptions.reverseBackSet;
            }
            me.setOrderIsCollate(true);
            me.numOfSets = me.calculateMaxNumberOfSets();

        },

        /** Set order and create sets due to order (not reverse sided)
         * @memberof DPO.project.DividersCreator#
         * @param {boolean} isCollate
         */
        setOrderIsCollate: function setOrderIsCollate(isCollate) {
            var me = this;
            me.isCollate = isCollate;
            me.createDividersSets();
        },

        /** Set order and create sets due to order (reverse sided)
         * @memberof DPO.project.DividersCreator#
         * @param {boolean} frontAndBackSide
         */
        setOrderIsFrontAndBackSide: function setOrderIsFrontAndBackSide(frontAndBackSide) {
            var me = this;
            me.isFrontAndBackSide = frontAndBackSide;
            me.isCollate = !frontAndBackSide;
            me.indexStartFrom = 0;
            me.numOfSets = me.calculateMaxNumberOfSets();
            me.createDividersSets();
        },

        /** Create set from all panels, used if number of sets = 0
         * @memberof DPO.project.DividersCreator#
         * @param {DPO.model.Page} page
         * @param {object[]} allSets
         */
        createDefaultSet: function createDefaultSet(page, allSets) {
            var me = this;

            for (var k = 0; k < page.panels.length; k++) {
                allSets[0].panels.push({
                    panel: page.panels[k],
                    number: me.context.selector.panelIndex(page.panels[k]),
                    index: k,
                    indexInSet: 0
                });
            }
            me.currentSets = allSets;
        },

        /** Create sets according to options
         * @memberof DPO.project.DividersCreator#
         */
        createDividersSets: function createDividersSets() {
            var me = this,
                allSets = [],
                project = me.context.project,
                page = project.pages[0];

            if (me.numOfSets === 0) {
                allSets.push({
                    panels: [],
                    indexOfSet: 0
                });
                me.createDefaultSet(page, allSets);
                return;
            }
            var defaultImageUrl = [].concat(me.getDefaultImages());
            for (var i = 0; i < me.panelsPerSet; i++) {
                allSets.push({
                    panels: [],
                    indexOfSet: i,
                    setText: '',
                    imageUrl: defaultImageUrl
                });
            }

            var func;
            if (!me.reverseBackSet) {
                func = (me.isCollate) ? me.getCollatePanelSets : me.getGroupPanelSets;
            } else {
                func = (me.isFrontAndBackSide) ? me.getReverseSidedPanelSets : me.getCollatePanelSets;
            }

            for (var j = 0; j < project.masterPanels.length; j++) {
                var master = project.masterPanels[j];

                if (me.panelSetOptions.backMaster) {
                    if (master.id === me.panelSetOptions.backMaster) {
                        func.call(me, allSets, master, page);
                    }
                }
                if (master.id === me.panelSetOptions.master) {
                    func.call(me, allSets, master, page);
                }
            }

            me.currentSets = allSets;
        },

        /** Create sets due to ReverseSided Order of panels
         * @memberof DPO.project.DividersCreator#
         * @param {object[]} allSets
         * @param {DPO.model.MasterPanel} mp
         * @param {DPO.model.Page} page
         */
        getReverseSidedPanelSets: function getReverseSidedPanelSets(allSets, mp, page) {
            var me = this,
                indexStartFrom = me.indexStartFrom || 0,
                selector = me.context.selector,
                allPanels = selector.selectChildPanels(mp, page),
                startFrom = indexStartFrom * me.panelsPerSet,
                endOn = me.numOfSets * me.panelsPerSet + startFrom,
                indexInSet = 0,
                numOfPanel = 0;

            var flag = true;

            for (var i = startFrom; i < endOn; i++) {
                if (numOfPanel < 0) {
                    flag = true;
                    numOfPanel = 0;
                    indexInSet++;
                }
                if (numOfPanel > me.panelsPerSet - 1) {
                    numOfPanel = me.panelsPerSet - 1;
                    flag = false;
                    indexInSet++;
                }

                allSets[numOfPanel].panels.push({
                    panel: allPanels[i],
                    number: numOfPanel,
                    index: selector.getPanelPositionOnPage(allPanels[i], me.context.project.pages[0]),
                    indexInSet: indexInSet
                });

                if (flag) {
                    numOfPanel++;
                } else {
                    numOfPanel--;
                }
            }
        },

        /** Create sets due to Collate Order of panels
         * @memberof DPO.project.DividersCreator#
         * @param {object[]} allSets
         * @param {DPO.model.MasterPanel} mp
         * @param {DPO.model.Page} page
         */
        getCollatePanelSets: function getCollatePanelSets(allSets, mp, page) {
            var me = this,
                indexStartFrom = me.indexStartFrom || 0,
                selector = me.context.selector,
                allPanels = selector.selectChildPanels(mp, page),
                startFrom = indexStartFrom * me.panelsPerSet,
                endOn = me.numOfSets * me.panelsPerSet + startFrom,
                indexOfSet = 0,
                indexInSet = 0;

            for (var i = startFrom; i < endOn; i++) {
                if (indexOfSet >= me.panelsPerSet) {

                    indexOfSet = 0;
                    indexInSet++;
                }

                allSets[indexOfSet].panels.push({
                    panel: allPanels[i],
                    number: indexOfSet,
                    index: selector.getPanelPositionOnPage(allPanels[i], me.context.project.pages[0]),
                    indexInSet: indexInSet
                });
                indexOfSet++;
            }
        },

        /** Create sets due to Grouped Order of panels
         * @memberof DPO.project.DividersCreator#
         * @param {object[]} allSets
         * @param {DPO.model.MasterPanel} mp
         * @param {DPO.model.Page} page
         */
        getGroupPanelSets: function getGroupPanelSets(allSets, mp, page) {
            var me = this,
                selector = me.context.selector,
                indexStartFrom = me.indexStartFrom || 0,
                allPanels = selector.selectChildPanels(mp, page),
                startFrom = indexStartFrom * me.panelsPerSet,
                endOn = me.numOfSets * me.panelsPerSet + startFrom,
                indexSet = 0,
                numPanelsInSet = 0;

            for (var i = startFrom; (i < endOn); i++) {
                if (numPanelsInSet >= me.numOfSets) {
                    indexSet++;
                    numPanelsInSet = 0;
                }

                allSets[indexSet].panels.push({
                    panel: allPanels[i],
                    number: indexSet,
                    index: selector.getPanelPositionOnPage(allPanels[i], me.context.project.pages[0]),
                    indexInSet: numPanelsInSet
                });
                numPanelsInSet++;
            }
        },

        /** Calculate max number of panels sets for page
         * @memberof project.DividersCreator#
         * @returns {number}
         */
        calculateMaxNumberOfSets: function calculateMaxNumberOfSets() {
            var me = this,
                max = 0,
                page = me.project.pages[0],
                doubleSided = me.project.panelSetOptions.backMaster;

            if (!doubleSided) {
                // not sure about panels length maybe used project.masterpanels[0].linkedPanels.length as in flex
                max = Math.floor((page.panels.length / me.panelsPerSet));
            } else {
                max = Math.floor((page.panels.length / (me.panelsPerSet * 2)));
            }
            return max;
        },

        getMasterPanelById: function getMasterPanelById(mpId) {
            var me = this;
            for (var j = 0; j < me.context.project.masterPanels.length; j++) {
                var master = me.context.project.masterPanels[j];
                if (master.id === mpId) {
                    return master;
                }
            }
            return null;
        },

        /** Returns array of panels from set, which are connected with MasterPanel
         * @param {object[]} arrayFromSet - array of objects which contains panel and different indexes
         * @param {DPO.model.MasterPanel} mp
         * @returns {Array}
         */
        getChildPanelsFromSet: function getChildPanelsFromSet(arrayFromSet, mp) {
            var result = [];
            for (var j = 0; j < arrayFromSet.length; j++) {
                if (arrayFromSet[j].panel.master === mp.id) {
                    result.push(arrayFromSet[j].panel);
                }
            }
            return result;
        },

        /**
         * Add field to panel and creates field reference
         * @memberof DPO.project.DividersCreator#
         * @param {DPO.model.Field} field
         * @param {object[]} panelsSet
         * @param {DPO.model.MasterPanel} mp
         * @param {DPO.model.MasterPanel} [bmp]
         * @returns {DPO.project.DividersCreator}
         */
        addFieldToSet: function addFieldToPanel(field, panelsSet, mp, bmp) {
            var me = this,
                refs = [],
                pushed = me.transformer.pushFieldToPanel(field, mp),
                pnl, ref, panels = [];

            if (bmp) {
                pushed = me.transformer.pushFieldToPanel(field, bmp);
                panels = panels.concat(me.getChildPanelsFromSet(panelsSet.panels, bmp));
            }
            if (!pushed) {
                return me;
            }
            panels = panels.concat(me.getChildPanelsFromSet(panelsSet.panels, mp));

            field.id = me.transformer.generateId('PF');
            field.contentId = field.id;
            field.geometryId = field.id;

            for (var i = 0; i < panels.length; i++) {
                pnl = panels[i];
                ref = new DPO.model.FieldRef();
                ref.id = me.transformer.generateId('FR');
                ref.contentId = field.id;
                ref.geometryId = field.id;
                ref.zOrder = pnl.fieldRefs.length;
                refs.push(ref);
                pnl.fieldRefs.push(ref);
            }

            me.context.selector.clearCache();
            me.transformer.fireSequentialEvent('added:field', [field, panels, refs]);
            return me;
        },

        /** Apply new design to project
         * @param {object[]} allText - all textBlocks text to add
         * @param {object[]} allImagesParams - all images to add
         * @param callback
         */
        addNewDesign: function addNewDesign(allText, allImagesParams, callback) {
            var me = this,
                mp = me.getMasterPanelById(me.panelSetOptions.master),
                bmp = me.getMasterPanelById(me.panelSetOptions.backMaster);

            var allIndexesWithImages = [];
            for (var i = 0; i < allImagesParams.length; i++) {
                allIndexesWithImages.push(allImagesParams[i].index);
            }
            me.deleteAllFields(mp);
            if (bmp) {
                me.deleteAllFields(bmp);
            }
            if (allText.length) {
                me.createTextBlocks(allText, allIndexesWithImages);
            }
            if (allImagesParams.length) {
                me.createImages(allImagesParams, callback);
            } else {
                callback();
            }
        },

        /** Delete all fields from master panel and child panels
         * @param {DPO.model.MasterPanel} panel
         */
        deleteAllFields: function deleteAllFields(panel) {
            var me = this,
                order = me.context.selector.getFieldOrder(panel),
                allFields = order.getFields(),
                childPanels = me.context.selector.selectChildPanels(panel);

            me.transformer.beginUpdates();
            for (var i = 0; i < childPanels.length; i++) {
                order = me.context.selector.getFieldOrder(childPanels[i]);
                allFields = order.getFields();
                me.transformer.deleteFields(allFields);
            }

            me.transformer.deleteFields(allFields);
            me.transformer.endUpdates();
        },

        /** Set image position according to options left or right
         * @param {DPO.model.MasterPanel} mp
         */
        setPositionOfImages: function setPositionOfImages(mp) {
            var me = this,
                rectWidth = me.rectForPosition.width,
                rectHeight = me.rectForPosition.height,
                areaWidth = rectWidth * 0.3,
                allImages = [].concat(mp.images);

            for (var i = 0; i < allImages.length; i++) {
                var dx = (areaWidth - allImages[i].width) / 2;
                me.transformer.beginUpdates();
                allImages[i].position.y = rectHeight / 2 - allImages[i].height / 2;
                if (me.isLeftImagePosition) {
                    allImages[i].position.x = dx;
                } else {
                    allImages[i].position.x = rectWidth - areaWidth + dx;
                }
                me.transformer.endUpdates();
            }
        },

        /** Create new images on dividers
         * @param {object[]} allImgParams - contains id or url and index of set
         * @param callback
         */
        createImages: function createImages(allImgParams, callback) {
            var me = this,
                sets = me.currentSets,
                mp = me.getMasterPanelById(me.panelSetOptions.master),
                bmp = me.getMasterPanelById(me.panelSetOptions.backMaster),
                images = [];

            function addAllImgs(images) {
                var me = this,
                    count = allImgParams.length;

                if (images.length === count) {
                    for (var i = 0; i < count; i++) {
                        me.addFieldToSet(images[i].img, images[i].panelsSet, mp, bmp);
                    }
                    me.setPositionOfImages(mp);
                    if (me.panelSetOptions.backMaster) {
                        me.setPositionOfImages(bmp);
                    }
                    callback();
                }
            }

            function fail() {
                callback();
            }

            for (var j = 0; j < allImgParams.length; j++) {
                var index = allImgParams[j].index,
                    params = allImgParams[j],
                    loadFrom = params.url;

                me.context.endpoint.copyRemoteImage(
                    loadFrom,
                    me.context.projectData,
                    me.createImage.bind(me, sets[index], images, mp, addAllImgs),
                    fail,
                    me);
            }
        },

        /**  Create new images object
         * @param {object[]} curSet - set of dividers where image will be added
         * @param {object[]} images
         * @param {DPO.model.MasterPanel} mp
         * @param {function} callback
         * @param response
         */
        createImage: function createImage(curSet, images, mp, callback, response) {
            var data = response.data,
                me = this;
            data = data instanceof Array ? data[0] : data;
            var high = data.highResolution;

            var pt = me.transformer,
                w = me.rectForPosition.width * 0.3 / 2,
                h = me.rectForPosition.height / 2,
                aspect = high.width / high.height;
            if (w > h) {
                w = h * aspect;
            } else {
                h = w / aspect;
            }

            var img = pt.createImage(data.name, w, h);
            images.push({
                img: img,
                panelsSet: curSet
            });
            callback.apply(me, [images]);
        },

        /** Create TextBlocks on dividers
         * @param {object[]} allText - spans, printed by user
         * @param {Array} allIndexesWithImages - set indexes where there are images, needed to translate and resize textblocks
         */
        createTextBlocks: function createTextBlocks(allText, allIndexesWithImages) {
            var me = this,
                sets = me.currentSets,
                mp = me.getMasterPanelById(me.panelSetOptions.master),
                bmp = me.getMasterPanelById(me.panelSetOptions.backMaster),
                isTranslated = false;

            var proposedWidth = me.rectForPosition.width * 0.7;
            for (var j = 0; j < allText.length; j++) {
                var index = allText[j].index,
                    textDefaults = mp.textDefaults[0],
                    textBlock = me.transformer.createTextBlock(textDefaults);
                isTranslated = allIndexesWithImages.indexOf(index);

                textBlock.text.textFlow.paragraphs[0].spans[0].value = allText[j].text;

                if (textBlock.width > proposedWidth && isTranslated !== -1) {
                    textBlock.width = proposedWidth;
                }
                if (isTranslated !== -1) {
                    textBlock.position.x = (me.isLeftImagePosition) ? me.rectForPosition.width * 0.3 : me.rectForPosition.x;
                }
                me.transformer.fireGeometryChanged([textBlock]);
                me.addFieldToSet(textBlock, sets[index], mp, bmp);

                /*if (bmp) {
                    me.addFieldToSet(textBlock, sets[index], bmp);
                }*/
            }
        },

        /** Finds panel in a set and returns it's description (especially number of panel)
         * @memberof DPO.project.DividersCreator#
         * @param {object[]} panelsSet
         * @param {DPO.model.Panel} panel
         * @returns {?number}
         */
        getPanelDescriptionFromSet: function getPanelDescriptionFromSet(panelsSet, panel) {
            for (var j = 0; j < panelsSet.length; j++) {
                for (var i = 0; i < panelsSet[j].panels.length; i++) {
                    var curPanel = panelsSet[j].panels[i].panel;
                    if (curPanel === panel) {
                        return panelsSet[j].panels[i];
                    }
                }
            }
            return null;
        }
    });

    return DividersCreator;
});
DPO.def('project.Binder', function () {
    /**
     * @class DPO.project.Binder
     * @extends DPO.model.Introspector
     * @memberof DPO.project
     * @param {DPO.project.DataSourceProvider} provider
     * @param {DPO.model.Selector} selector
     * @property {DPO.project.DataSourceProvider} provider
     * @property {DPO.model.Selector} selector
     * @constructor
     */
    function Binder(provider, selector) {
        this.provider = provider;
        this.selector = selector;
    }

    DPO.inherit(Binder, DPO.model.Introspector);
    DPO.mixin(Binder.prototype, {
        /**
         * Binds data to specified text span(s)
         * @memberof DPO.project.Binder#
         * @param {DPO.model.Span|DPO.model.Span[]} spans
         * @param {number} index
         * @param {object} [record]
         * @returns {boolean}
         */
        bindDataToSpans: function bindDataToSpans(spans, index, record) {
            var me = this,
                bound = false,
                selector = me.selector,
                dataSource = me.provider.getDataSource();
            record = record || dataSource.getRecordData(index) || {};
            spans = spans instanceof Array ? spans : [spans];

            for (var i = 0; i < spans.length; i++) {
                var span = spans[i],
                    text = span.value;
                if (span.serialNumberField) {
                    var serialNumber = selector.getSerialNumber(span.serialNumberField);
                    text = selector.getTextForSerialNumber(index, serialNumber);
                    bound = true;
                }

                if (span.mailMergeField) {
                    text = record[span.mailMergeField] || '';
                    bound = true;
                }

                span.value = text;
            }
            return bound;
        },

        /**
         * Binds data to text block field
         * @memberof DPO.project.Binder#
         * @param {DPO.model.Field} field
         * @param {number} index
         * @param {object} [record]
         * @returns {DPO.model.TextBlock}
         */
        bindDataToTextBlock: function bindDataToTextBlock(field, index, record) {
            var me = this,
                textBlock = /** @type DPO.model.TextBlock */me.clone(field),
                paragraphs = textBlock.text.textFlow.paragraphs,
                bound = false;
            for (var i = 0; i < paragraphs.length; i++) {
                bound = me.bindDataToSpans(paragraphs[i].spans, index, record) || bound;
            }
            return bound ? textBlock : field;
        },

        /**
         * Binds data to barcode field
         * @memberof DPO.project.Binder#
         * @param {DPO.model.Field} field
         * @param {number} index
         * @param {object} [record]
         * @returns {DPO.model.Barcode}
         */
        bindDataToBarcode: function bindDataToBarcode(field, index, record) {
            var me = this,
                selector = this.selector,
                dataSource = me.provider.getDataSource(),
                barcode = /** @type DPO.model.Barcode */me.clone(field),
                properties = barcode.properties,
                bound = false;
            record = dataSource.getRecordData(index) || {};
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i],
                    text = property.value;
                if (property.serialNumberField) {
                    var serialNumber = selector.getSerialNumber(property.serialNumberField);
                    text = selector.getTextForSerialNumber(index, serialNumber);
                    bound = true;
                }

                if (property.mailMergeField) {
                    text = record[property.mailMergeField] || '';
                    bound = true;
                }

                if (barcode.barcodeType === 'Codabar' && property.name === 'data') {
                    var res = /(\w).*(\w)/.exec(property.value);
                    text = res[1] + text + res[2];
                }

                property.value = text;
            }

            return bound ? barcode : field;
        },

        /**
         * Binds data to field
         * @memberof DPO.project.Binder#
         * @param {DPO.model.Field} field
         * @param {number} index
         * @param {object} [record]
         * @returns {DPO.model.Field} field
         */
        bindDataToField: function bindDataToField(field, index, record) {
            if ((field instanceof DPO.model.TextBlock)) {
                return this.bindDataToTextBlock(field, index, record);
            }

            if ((field instanceof DPO.model.Barcode)) {
                return this.bindDataToBarcode(field, index, record);
            }

            return field;
        },

        /**
         * Returns record for specified index
         * @memberof DPO.project.Binder#
         * @param {number} index
         * @returns {object}
         */
        getRecord: function getRecord(index) {
            var dataSource = this.provider.getDataSource();
            return dataSource.getRecordData(index) || {};
        }
    });

    return Binder;
});
DPO.def('project.Expander', function () {
    /**
     * @class DPO.project.Expander
     * @extends DPO.project.Transformer
     * @memberof DPO.project
     * @param {DPO.project.Context} context
     * @property {DPO.model.Project} originalProject
     * @property {DPO.project.Binder} binder
     * @property {DPO.text.LayoutManager} layoutManager
     * @fires project:expanded
     * @constructor
     */
    function Expander(context) {
        var me = this;
        DPO.project.Transformer.call(me, me.clone(context.project));

        me.expendedFields = {};
        me.cleanupProject(context.filter);
        me.context = context;
        me.originalProject = context.project;
        me.binder = new DPO.project.Binder(context.provider, me.selector);
        me.layoutManager = context.layoutManager;
    }

    DPO.inherit(Expander, DPO.project.Transformer);
    DPO.mixin(Expander.prototype, {
        onFontsLoaded: function onFontsLoaded() {
            var me = this;
            me.doExpand();
        },

        /**
         * Removes useless information from text block
         * @param {DPO.model.TextBlock} textBlock
         */
        cleanupTextBlock: function cleanupTextBlock(textBlock) {
            var paragraphs = textBlock.text.textFlow.paragraphs;
            delete textBlock.geometryId;
            delete textBlock.contentId;
            for (var i = 0; i < paragraphs.length; i++) {
                var spans = paragraphs[i].spans;
                for (var j = 0; j < spans.length; j++) {
                    var s = spans[j];
                    delete s.mailMergeField;
                    delete s.mailMergeId;
                    delete s.serialNumberField;
                }
            }
        },

        /**
         * Removes useless information from barcode
         * @param {DPO.model.Barcode} barcode
         */
        cleanupTextBarcode: function cleanupTextBarcode(barcode) {
            var properties = barcode.properties;
            delete barcode.geometryId;
            delete barcode.contentId;
            for (var i = 0; i < properties.length; i++) {
                var p = properties[i];
                delete p.mailMergeField;
                delete p.serialNumberField;
            }
        },

        /**
         * @memberof DPO.project.Expander#
         * @param {DPO.model.TextBlock[]} textBlocks
         */
        layoutTextBlocks: function layoutTextBlocks(textBlocks) {
            var me = this,
                lm = me.layoutManager;
            for (var i = 0; i < textBlocks.length; i++) {
                var textBlock = textBlocks[i],
                    paragraphs = [],
                    containers = lm.layoutTextBlock(textBlock);
                for (var j = 0; j < containers.length; j++) {
                    var c = containers[j],
                        lines = c.lines;
                    if (c.collapsable) {
                        continue;
                    }

                    for (var k = 0; k < lines.length; k++) {
                        var line = lines[k],
                            p = me.clone(c.paragraph);
                        p.spans = line.visibleSpans;
                        paragraphs.push(p);
                    }
                }

                textBlock.text.textFlow.paragraphs = paragraphs;
                me.cleanupTextBlock(textBlock);
            }
        },

        /**
         * Expands panel
         * @memberof DPO.project.Expander#
         * @param {DPO.model.Panel} panel
         */
        expandPanel: function expandPanel(panel) {
            var me = this,
                textBlocks = [],
                index = me.selector.panelIndex(panel),
                order = this.selector.getFieldOrder(panel),
                items = order.items,
                count = me.binder.provider.getDataSource().totalRecords();
            for (var i = 0; i < items.length; i++) {
                var item = items[i],
                    field = me.binder.bindDataToField(/** @type DPO.model.Field*/item.field, index),
                    dataBindingFlags = field.dataBindingFlags();
                if (item.field !== field) {
                    switch (dataBindingFlags) {
                        case 2: // mail merge only
                        case 3: // sequential & mail merge
                            if (index >= count) {
                                var f = me.breakFieldRefs([item.field], panel);
                                f = f.length ? f[0].panelField : item.field;
                                me.deleteFields(f);
                                continue;
                            }
                            break;
                    }

                    if (item.ref) {
                        field.id = me.generateId('PF');
                        field.zOrder = item.zOrder;
                        me.pushFieldToPanel(field, panel);

                        var refs = panel.fieldRefs;
                        for (var j = refs.length - 1; j >= 0; j--) {
                            var ref = refs[j];
                            if (ref.contentId === item.id) {
                                refs.splice(j, 1);
                            }
                        }
                    } else {
                        field = /** @type DPO.model.Field*/DPO.mixin(item.field, field);
                    }
                }

                if (me.expendedFields[field.id]) {
                    continue;
                }

                me.expendedFields[field.id] = true;

                switch (field.constructor) {
                    case DPO.model.TextPath:
                    case DPO.model.TextBlock:
                        textBlocks.push(field);
                        break;
                    case DPO.model.Barcode:
                        me.cleanupTextBarcode(/** @type DPO.model.Barcode*/field);
                        break;
                }
            }

            me.layoutTextBlocks(textBlocks);
        },

        /**
         * Expands page
         * @memberof DPO.project.Expander#
         * @param {DPO.model.Page} page
         */
        expandPage: function expandPage(page) {
            var panels = page.panels;
            for (var i = 0; i < panels.length; i++) {
                this.expandPanel(panels[i]);
            }
        },

        /**
         * Starts asynchronous project expansion
         * @memberof DPO.project.Expander#
         */
        beginExpand: function beginExpand() {
            var me = this,
                pages = me.project.pages,
                index = 0;

            function fn() {
                try {
                    me.fire('project:expand-progress', [me, me.project, index, pages.length]);

                    // To void js execution timeout we should release current thread
                    // So expand 10 pages per call
                    for (var i = 0; index < pages.length && i < 10; i++, index++) {
                        me.expandPage(pages[index]);
                    }

                    if (index < pages.length) {
                        setTimeout(fn, 1);
                    } else {
                        me.endExpand();
                    }
                } catch (e) {
                    me.fire('error:occurred', [me, e]);
                }
            }

            me.beginUpdates();
            setTimeout(fn, 1);
        },

        /**
         * Finishes asynchronous project expansion
         * @memberof DPO.project.Expander#
         */
        endExpand: function endExpand() {
            var me = this;
            me.endUpdates();
            me.fire('project:expanded', [me, me.project]);
        },

        /**
         * Performs project expansion
         * @memberof DPO.project.Expander#
         */
        doExpand: function doExpand() {
            var me = this;
            me.layoutManager.un('fonts:loaded', me.onFontsLoaded, me);
            me.beginExpand();
        },

        /**
         * Expands project
         * @memberof DPO.project.Expander#
         */
        expandProject: function expandProject() {
            var me = this;
            me.layoutManager.on('fonts:loaded', me.onFontsLoaded, me);
            me.expendedFields = {};

            var started = me.layoutManager.loadFonts(me.project);
            if (!started) {
                me.doExpand();
            }
        }
    });

    return Expander;
});
DPO.def('project.DesignApplier', function () {
    /**
     * @class DPO.project.DesignApplier
     * @memberof DPO.project
     * @property {DPO.model.Project} source
     * @property {DPO.model.Project} destination
     * @param {DPO.model.Project} source
     * @param {DPO.model.Project} destination
     * @constructor
     */
    function DesignApplier(source, destination) {
        var me = this;
        me.source = source;
        me.destination = destination;
    }

    DPO.mixin(DesignApplier.prototype, {
        /**
         * Applies design from source project to destination project
         * @returns {DPO.model.Project}
         */
        applyDesign: function applyDesign() {
            var me = this,
                sourceSelector = new DPO.model.Selector(me.source),
                dt = new DPO.project.Transformer(me.destination),
                sourcePanel = me.source.pages[0].panels[0],
                sourceMaster = sourceSelector.selectMasterPanel(sourcePanel),
                destinationPanel = me.destination.pages[0].panels[0],
                destinationMaster = dt.selector.selectMasterPanel(destinationPanel),
                order = sourceSelector.getFieldOrder(sourcePanel),
                fields = order.getFields(),
                i, f;

            dt.beginUpdates();
            me.destination.serialNumbers = dt.clone(me.source.serialNumbers);
            for (i = 0; i < fields.length; i++) {
                f = dt.clone(fields[i]);
                dt.addFieldToPanel(f, destinationPanel);
            }

            order = dt.selector.getFieldOrder(destinationPanel);
            fields = order.getFields();
            var w1 = sourceMaster.width,
                h1 = sourceMaster.height,
                w2 = destinationMaster.width,
                h2 = destinationMaster.height,
                scaleX = w2 / w1,
                scaleY = h2 / h1,
                scale = Math.min(scaleX, scaleY),
                box = {
                    x: 0,
                    y: 0,
                    width: destinationMaster.width,
                    height: destinationMaster.height
                };

            dt.centerFields(fields, true, true, box);
            dt.scaleFields(fields, scale, scale, {
                x: destinationMaster.width / 2,
                y: destinationMaster.height / 2
            });

            fields = [].concat(destinationPanel.textBlocks, destinationPanel.textPaths);
            for (i = 0; i < fields.length; i++) {
                f = fields[i];
                me.resetFont(f, scale);
            }

            if (destinationPanel.backgrounds.length) {
                dt.placeBackground(destinationPanel.backgrounds[0], destinationPanel);
            }
            dt.endUpdates();
            return me.destination;
        },

        /**
         * Reset font size due to scale
         * @memberof DPO.project.DesignApplier#
         */
        resetFont: function resetFont(field, scale) {
            var paragraphs = field.text.textFlow.paragraphs,
                spans;
            for (var i = 0; i < paragraphs.length; i++) {
                spans = paragraphs[i].spans;
                for (var j = 0; j < spans.length; j++) {
                    spans[j].fontSize *= scale;
                }
            }
        }
    });

    return DesignApplier;
});
DPO.def('mmd.Column', function() {
    /**
     * @class DPO.mmd.Column
     * @extends DPO.xml.Model
     * @memberof DPO.mmd
     * @constructor
     */
    function Column() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Column, DPO.xml.Model);
    DPO.mixin(Column.prototype, {
        nodeName: 'Column',
        attributesBinding: [
            { name: 'disabled', type: 'bool', defaultValue: false }
        ],
        valueBinding: {}
    });

    return Column;
});
DPO.def('mmd.Row', function() {
    /**
     * @class DPO.mmd.Row
     * @extends DPO.xml.Model
     * @memberof DPO.mmd
     * @property {boolean} disabled
     * @property {DPO.mmd.Column[]} columns
     * @constructor
     */
    function Row() {
        DPO.xml.Model.apply(this, arguments);
    }

    DPO.inherit(Row, DPO.xml.Model);
    DPO.mixin(Row.prototype, {
        nodeName: 'row',
        attributesBinding: [
            { name: 'disabled', type: 'bool', defaultValue: false }
        ],
        modelsBinding: [
            { el: 'Column',  name: 'columns', cls: DPO.mmd.Column, collection: true }
        ]
    });

    return Row;
});
DPO.def('mmd.Header', function() {
    /**
     * @class DPO.mmd.Header
     * @extends DPO.mmd.Row
     * @memberof DPO.mmd
     * @constructor
     */
    function Header() {
        DPO.mmd.Row.apply(this, arguments);
    }

    DPO.inherit(Header, DPO.mmd.Row);
    DPO.mixin(Header.prototype, {
        nodeName: 'header-row'
    });

    return Header;
});
DPO.def('mmd.Data', function() {
    /**
     * @class DPO.mmd.Data
     * @extends DPO.xml.Model
     * @memberof DPO.mmd
     * @property {string} spreadsheetFileName
     * @property {string} originalName
     * @property {DPO.mmd.Header} header
     * @property {DPO.mmd.Row[]} rows
     * @constructor
     */
    function Data() {
        DPO.xml.Model.apply(this, arguments);
        this.spreadsheetFileName = '';
        this.originalName = '';
    }

    DPO.inherit(Data, DPO.xml.Model);
    DPO.mixin(Data.prototype, {
        ns: null,
        nodeName: 'mailmerge-data',
        modelsBinding: [
            { el: 'header-row',  name: 'header', cls: DPO.mmd.Header },
            { el: 'row',  name: 'rows', cls: DPO.mmd.Row, collection: true }
        ],

        /**
         * Returns columns map
         * @memberof DPO.mmd.Data#
         * @param {boolean} [includeDisabled=false]
         * @returns {object}
         */
        getColumnMap: function getColumnMap(includeDisabled) {
            var map = {},
                columns = this.header.columns;
            for (var i = 0; i < columns.length; i++) {
                var c = columns[i];
                if (!c.disabled || includeDisabled) {
                    map[c.value] = i;
                }
            }

            return map;
        },

        /**
         * Clone current data object
         * @memberof DPO.mmd.Data#
         * @returns {DPO.mmd.Data}
         */
        clone: function clone() {
            var obj = this.toObject();
            return Data.fromObject(obj);
        },

        /**
         * Returns data as simple object
         * @memberof DPO.mmd.Data#
         * @returns {object}
         */
        toObject: function toObject() {
            var header = this.header,
                columns = [],
                resultHeader = {
                    disabled: header.disabled,
                    Column: columns
                },
                resultRows = [],
                i, j, column, row;
            for (i = 0; i < this.header.columns.length; i++) {
                column = this.header.columns[i];
                resultHeader.Column.push({
                    disabled: column.disabled,
                    value: column.value
                });
            }

            for (i = 0; i < this.rows.length; i++) {
                row = this.rows[i];
                columns = [];

                for (j = 0; j < row.columns.length; j++) {
                    column = row.columns[j];
                    columns.push({
                        disabled: column.disabled,
                        value: column.value
                    });
                }

                resultRows.push({
                    disabled: row.disabled,
                    Column: columns
                });
            }

            return {
                'header-row': resultHeader,
                'spreadsheetFileName': this.spreadsheetFileName,
                'originalName': this.originalName,
                'row': resultRows
            };
        },

        /**
         * Returns clone on specified row object
         * @memberof DPO.mmd.Data#
         * @param {DPO.mmd.Row} row
         * @returns {DPO.mmd.Row}
         */
        cloneRow: function cloneRow(row) {
            return copyRowData(new DPO.mmd.Row(), row);
        }
    });

    /**
     * Copies data from object to Row
     * @param {DPO.mmd.Row} row
     * @param {object} obj
     * @param {boolean} [isHeader]
     * @returns {*}
     */
    function copyRowData(row, obj, isHeader) {
        row.disabled = !!obj.disabled;
        row.columns = [];

        var columns = obj.Column || obj.columns;
        for (var i = 0; i < columns.length; i++) {
            var column = new DPO.mmd.Column(),
                c = columns[i];
            column.disabled = !!c.disabled;
            column.value = c.value;
            if (isHeader) {
                column.hasBarcodeData = checkForBarcodeData(c.value);
            }
            row.columns.push(column);
        }
        return row;
    }

    /**
     * Check if string matches to barcode pattern
     * @param {string} value
     * @returns {boolean}
     */
    function checkForBarcodeData(value) {
        return value.substr(0, 4) + value.substr(-1, 1) === '{BCT}' && value.indexOf('#') > -1;
    }


    /**
     * Creates new DPO.mmd.MailMergeData from raw object
     * @memberof DPO.mmd.Data
     * @param {object} obj
     * @returns {DPO.mmd.Data}
     */
    Data.fromObject = function fromObject(obj) {
        var data = new Data(),
            header = new DPO.mmd.Header();
        data.spreadsheetFileName = obj.spreadsheetFileName;
        data.originalName = obj.originalName;
        data.rows = [];
        data.date = new Date().getTime();       // unique attribute
        data.header = copyRowData(new DPO.mmd.Header(), obj.header || obj['header-row'], true);

        var rows = obj.row || obj.rows;
        for (var i = 0; i < rows.length; i++) {
            data.rows.push(copyRowData(new DPO.mmd.Row(), rows[i]));
        }

        data = Data.normalizeData(data);

        return data;
    };

    DPO.mixin(Data, {
        usedNames: [],

        /**
         * Normalize MM data, solves issues with invalid columns name (empty name, duplicate, etc)
         * @param {object} data
         * @returns {object}
         */
        normalizeData: function normalizeData(data) {
            var headers = data.header.columns || [],
                rows = data.rows || [],
                columns = (rows[0] || {}).columns || [],
                name;

            Data.usedNames = [];

            for (var i = 0; i < headers.length; i++) {
                name = headers[i].value;

                if(!Data.isValidName(name)) {
                    name = 'Field-' + (i + 1);
                    headers[i].value = name;
                    columns[i].value = name;
                }

                Data.usedNames.push(name);
            }

            return data;
        },

        /**
         * Checks if column name is valid
         * @param name
         * @returns {boolean}
         */
        isValidName: function isValidName(name) {
            name = (name || '').trim();

            return !!name && !(/^Field-[\d]+$/.test(name)) && (Data.usedNames.indexOf(name) === -1);
        }
    });

    return Data;
});
DPO.def('mmd.MergeMailDataSource', function () {
    /**
     * @class DPO.mmd.MergeMailDataSource
     * @extends DPO.project.DataSource
     * @extends DPO.mixins.TimeMachine
     * @memberof DPO.mmd
     * @param {DPO.mmd.Data} data
     * @constructor
     */
    function MergeMailDataSource(data) {
        var me = this;
        DPO.project.DataSource.apply(me, arguments);
        me.data = data;

        me.initTimeMachine({
            rows: []
        });
        me.registerTimeResource('rows', me.lookupRow);
        me.registerTimeResource('indexes');
        me.registerTimeResource('count');
        me.updateTimeResources();
    }

    DPO.inherit(MergeMailDataSource, DPO.project.DataSource);
    DPO.mixin(MergeMailDataSource.prototype, {
        /**
         * Initialize records
         * @memberof DPO.mmd.MergeMailDataSource#
         */
        updateTimeResources: function updateTimeResources() {
            var me = this,
                rows = me.data.rows,
                count = 0,
                indexes = {};
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                if (row.disabled) {
                    continue;
                }

                indexes[count++] = i;
            }

            me.storeTimeResource('indexes', indexes);
            me.storeTimeResource('count', count);
            me.storeTimeResource('rows', rows);
        },

        lookupRow: function lookupRow(state, index) {
            return state[index];
        },

        /**
         * Returns row by specified index
         * @memberof DPO.mmd.MergeMailDataSource#
         * @param {number} index
         * @returns {DPO.mmd.Row}
         */
        getRow: function getRow(index) {
            var pos = this.indexes[index];
            if (pos === undefined) {
                return null;
            }

            return this.lookupTimeResource('rows', pos);
        },

        /**
         * Get record as specified index
         * @memberof DPO.mmd.MergeMailDataSource#
         * @param {number} index
         * @returns {object}
         */
        getRecordData: function getRecord(index) {
            var row = this.getRow(index);
            if (!row) {
                return null;
            }

            var map = this.data.getColumnMap(),
                columns = Object.keys(map),
                record = {};

            for (var i = 0; i < columns.length; i++) {
                var column = columns[i],
                    j = map[column];

                record[column] = row.columns[j].value;
            }

            return record;
        },

        /**
         * Sets record data for specified index
         * @memberof DPO.mmd.MergeMailDataSource#
         * @param {number} index
         * @param {object} data
         */
        setRecordData: function setRecordData(index, data) {
            var me = this,
                row = me.getRow(index);
            if (!row) {
                return;
            }

            var map = me.data.getColumnMap(),
                columns = Object.keys(map),
                changes = [], i;
            for (i = 0; i < columns.length; i++) {
                var column = columns[i],
                    value = data[column],
                    j = map[column];
                if (value !== undefined && row.columns[j].value !== value) {
                    changes[j] = value;
                }
            }

            if (!changes.length) {
                return;
            }

            me.forgetFuture();
            me.timeTravel();
            var obj = {},
                rowIndex = this.indexes[index],
                clone = me.data.cloneRow(row);
            obj[rowIndex] = clone;

            for (i = 0; i < changes.length; i++) {
                var v = changes[i];
                if (v !== undefined) {
                    clone.columns[i].value = v;
                }
            }

            me.storeTimeResource('rows', obj);
            me.fire('changed:data-source:record', [me, index, data]);
        },

        /**
         * Returns total records count
         * @memberof DPO.mmd.MergeMailDataSource#
         * @returns {number}
         */
        totalRecords: function totalRecords() {
            return this.count;
        },

        /**
         * Returns clone of current data source
         * @memberof DPO.mmd.MergeMailDataSource#
         * @returns {DPO.mmd.MergeMailDataSource}
         */
        clone: function clone() {
            return new MergeMailDataSource(this.getData());
        },

        /**
         * Returns clone of mail merge data object
         * @memberof DPO.mmd.MergeMailDataSource#
         * @returns {DPO.mmd.Data}
         */
        getData: function getData() {
            var me = this,
                data = me.data.clone(),
                indexes = me.indexes,
                count = me.count,
                row, i;
            me.foreachSnapshot(function (state) {
                var rows = state.rows;
                if (!rows) {
                    return;
                }

                var keys = Object.keys(rows);
                for (var i = 0; i < keys.length; i++) {
                    var index = keys[i];
                    data.rows[index - 0] = rows[index];
                }
            });

            for (i = 0; i < data.rows.length; i++) {
                row = data.rows[i];
                row.disabled = true;
            }

            for (i = 0; i < count; i++) {
                var index = indexes[i];
                row = data.rows[index];
                row.disabled = false;

            }
            return data;
        },

        /**
         * Disables/enables record by it's index
         * @memberof DPO.project.MergeMailDataSource#
         * @param {number[]} records
         * @param {boolean} [disabled]
         */
        disableRecords: function disableRecords(records, disabled) {
            var me = this,
                rows = me.data.rows,
                indexes = me.indexes;
            me.forgetFuture();

            for (var i = 0; i < records.length; i++) {
                var rowIndex = indexes[records[i]];
                if (rowIndex !== undefined) {
                    rows[rowIndex].disabled = !!disabled;
                }
            }

            me.updateTimeResources();
            me.timeTravel();
        }
    });

    Object.defineProperty(MergeMailDataSource.prototype, 'indexes', {
        get: function get() {
            return this.lookupTimeResource('indexes');
        }
    });

    Object.defineProperty(MergeMailDataSource.prototype, 'count', {
        get: function get() {
            return this.lookupTimeResource('count');
        }
    });

    return MergeMailDataSource;
});
DPO.def('mmd.DataSourceProvider', function () {
    /**
     * @class DPO.mmd.DataSourceProvider
     * @extends DPO.project.DataSourceProvider
     * @memberof DPO.mmd
     * @param {DPO.mmd.Data} [mailMergeData]
     * @property {DPO.mmd.Data} mailMergeData
     * @constructor
     */
    function DataSourceProvider(mailMergeData) {
        var me = this;
        if (!mailMergeData) {
            mailMergeData = DPO.mmd.Data.fromObject({
                'header-row': {
                    'disabled': false,
                    'Column': []
                },
                'row': []
            });
        }

        me.resetObservable();

        var fallback = {};
        fallback['data-source'] = {
            default: me.createMergeMailDataSource(mailMergeData)
        };
        me.initTimeMachine(fallback);
        me.registerTimeResource('data-source', me.lookupDataSource);
    }

    DPO.inherit(DataSourceProvider, DPO.project.DataSourceProvider);
    DPO.mixin(DataSourceProvider.prototype, {
        /**
         * @memberof DPO.mmd.DataSourceProvider#
         * @returns {DPO.project.DataSource}
         */
        createMergeMailDataSource: function createMergeMailDataSource(mailMergeData) {
            var me = this,
                dataSource = new DPO.mmd.MergeMailDataSource(mailMergeData);
            dataSource.on('changed:data-source:record', me.onRecordChanged, me);
            return dataSource;
        }
    });

    return DataSourceProvider;
});

DPO.def('mmd.DataParser', function() {
    /**
     * @class DPO.mmd.DataParser
     * @memberof DPO.mmd
     * @param {DPO.mmd.MergeMailDataSource} mmd
     * @constructor
     */
    function DataParser(mmd) {
        var me = this;
        me.parseRecords(mmd.data.rows);
    }

    DPO.mixin(DataParser.prototype, {

        /**
         * Parse records
         * @memberof DPO.mmd.DataParser#
         */
        parseRecords: function parseRecords(rows) {
            var me = this,
                headers = DataParser.getColumns(rows[0]),
                regexps = DataParser.regexps,
                parser,
                header,
                i;

            me.results = [];
            me.parsers = [];

            for(i = 0; i < headers.length; i++) {
                header = headers[i];
                parser = null;

                if(header.disabled || !header.value) {
                    continue;
                }

                for(var name in regexps) {
                    if(regexps.hasOwnProperty(name) && regexps[name].test(header.value)) {
                        parser = me.getParser(name);
                        parser.parseData(header.value);
                        break;
                    }
                }
            }

            for(parser in me.parsers) {
                if(me.parsers.hasOwnProperty(parser)) {
                    me.results = me.results.concat(me.parsers[parser].applyData());
                }
            }
        },

        /**
         * Return parser by name
         * @param {string} name
         * @memberof DPO.mmd.DataParser#
         * returns {object}
         */
        getParser: function getParser(name) {
            var me = this;

            if(!me.parsers[name]) {
                switch(name) {
                    case 'barcode':
                        me.parsers[name] = new DPO.mmd.BarcodeParser();
                        break;
                }
            }

            return me.parsers[name];
        },

        /**
         * Return parsed results
         * @memberof DPO.mmd.DataParser
         * returns {array}
         */
        getResults: function getResults() {
            var me = this;

            return me.results;
        }
    });

    DPO.mixin(DataParser, {
        regexps: {
            barcode: /^\{BCT#.*}$/
        },

        getColumns: function getColumns(row) {
            return (row || {}).columns || [];
        }
    });

    return DataParser;
});
DPO.def('mmd.BarcodeParser', function () {
    function BarcodeParser() {
        var me = this;

        me.barcodesData = {}; //
        me.validTokens = {};
        me.invalidTokens = {};
    }

    DPO.mixin(BarcodeParser.prototype, {
        parseData: function parseData(token) {
            var me = this;

            if (!me.validTokens[token]) {
                me.validate(token);
            }

            if (me.invalidTokens[token]) {
                return;
            }

            me.addData(token);
        },

        addData: function addData(token) {
            var me = this,
                self = BarcodeParser,
                parsedToken = me.validTokens[token],
                type = parsedToken.barcodeType,
                subType = parsedToken.barcodeSubType,
                field = parsedToken.barcodeField;

            if (!me.barcodesData[type]) {
                me.barcodesData[type] = [];

                if (self.isQRCode(type)) {
                    me.barcodesData[type].push(
                        self.createItem('dataType', subType),
                        self.createItem('ecc', 'L')
                    );
                }
            }

            me.barcodesData[type].push(
                self.createItem(field, field, token)
            );
        },

        validate: function validate(token) {
            var me = this,
                self = BarcodeParser,
                parsedToken = self.parseToken(token);

            if (self.isAllowedType(parsedToken.barcodeType)) {
                me.validTokens[token] = parsedToken;
            } else {
                me.invalidTokens[token] = parsedToken;
            }
        },

        /**
         * Method creates barcode instances from parsed data
         * and returns array of these instances
         * @returns {Object[]} - array of barcode instances
         */
        applyData: function applyData() {
            var me = this,
                results = [],
                introspector = new DPO.model.Introspector();

            for (var type in me.barcodesData) {
                if (me.barcodesData.hasOwnProperty(type)) {
                    var barcode = introspector.instantiate('Barcode'),
                        data = me.barcodesData[type];
                    barcode.position = new DPO.model.Position();
                    barcode.barcodeType = type;
                    barcode.width = BarcodeParser.defaultBarcodeWidth;
                    barcode.height = BarcodeParser.defaultBarcodeHeight;

                    for (var i = 0; i < data.length; i++) {
                        var property = new DPO.model.BarcodeProperty();
                        DPO.mixin(property, data[i]);
                        barcode.properties.push(property);
                    }

                    results.push(barcode);
                }
            }

            return results;
        }
    });

    DPO.mixin(BarcodeParser, {
        defaultBarcodeWidth: 500,
        defaultBarcodeHeight: 500,

        barcodeTypes: {
            CODABAR: 'Codabar',
            CODE128: 'Code 128',
            CODE39: 'Code 39',
            CODE39X: 'Code 39X',
            EAN13: 'EAN 13',
            UPCA: 'UPC-A',
            EAN8: 'EAN 8',
            INTELLIGENTMAIL: 'Intelligent Mail',
            '2/5INTERLEAVED': '2/5 Interleaved',
            '2/5INTERLEAVEDDEUTSCHENPOST': '2/5 Interleaved DeutschePost',
            MAXICODE: 'MaxiCode',
            PDF417: 'PDF417',
            POSTNET: 'Postnet',
            RM4SCC: 'RM4SCC',
            DATAMATRIX: 'Data Matrix',
            DEUTSCHEPOSTIDENTCODE: 'DeutschePost IdentCode',
            DEUTSCHEPOSTLEITCODE: 'DeutschePost LeitCode',
            QRCODE: 'QRCode'
        },

        barcodeSubTypes: {
            TEXT: 'text',
            EMAIL: 'email',
            URL: 'url',
            PHONENUMBER: 'phoneNumber',
            VCARD: 'vCard',
            MECARD: 'meCard',
            IMAGE: 'image'
        },

        barcodeFields: {
            FIRSTNAME: 'firstName',
            LASTNAME: 'lastName',
            ORGANIZATION: 'organization',
            JOBTITLE: 'jobTitle',
            TELEPHONENUMBER: 'telephoneNumber',
            ADDRESS: 'address',
            CITY: 'city',
            POSTALCODE: 'postalCode',
            NOTE: 'note',
            EMAIL: 'email',
            WEBSITE: 'website',
            POSTALZONE: 'postalCode',
            STREETNUMBER: 'streetNumber',
            HOUSENUMBER: 'houseNumber',
            PRODUCTNUMBER: 'productCode',
            DISTRIBUTIONCENTERCODE: 'distribution',
            CUSTOMERNUMBER: 'customer',
            MAILINGNUMBER: 'mailing',
            DATA: 'data'
        },

        isQRCode: function isQRCode(type) {
            var self = BarcodeParser;

            return self.barcodeTypes.QRCODE === type;
        },

        isAllowedType: function isAllowedType(type) {
            var self = BarcodeParser;

            return self.inObject(self.barcodeTypes, type);
        },

        inObject: function inObject(object, item) {
            for (var key in object) {
                if (object.hasOwnProperty(key) && object[key] === item) {
                    return true;
                }
            }

            return false;
        },

        createItem: function createItem(field, value, mmd) {
            var data = {
                name: field,
                value: value
            };

            if (mmd) {
                data.mailMergeField = mmd;
            }

            return data;
        },

        parseToken: function parseToken(token) {
            var self = BarcodeParser,
                parts = token.substring(5, token.length - 1).split('#'),
                scope = {};

            scope.barcodeType = self.validateType(parts.shift());
            scope.barcodeField = self.validateField(parts.pop());

            if (self.isQRCode(scope.barcodeType)) {
                scope.barcodeSubType = self.validateSubType(parts.pop());
            }

            return scope;
        },

        validateType: function validateType(type) {
            var self = BarcodeParser,
                types = self.barcodeTypes;

            return types[self.normalizeString(type)];
        },

        validateSubType: function validateSubType(subType) {
            var self = BarcodeParser,
                subTypes = self.barcodeSubTypes;

            return subTypes[self.normalizeString(subType)] || subTypes.TEXT;
        },

        validateField: function validateField(field) {
            var self = BarcodeParser,
                fields = self.barcodeFields;

            return fields[self.normalizeString(field)] || fields.DATA;
        },

        normalizeString: function normalizeString(str) {
            return (str || '')
                .trim()
                .replace(/\s+/g, '')
                .toUpperCase();
        }
    });

    return BarcodeParser;
});
/**
 * @memberof DPO
 * @type {object}
 * @namespace DPO.dto
 */

DPO.def('dto.ErrorType', function () {
    /**
     * Project error type
     * @readonly
     * @memberof DPO.dto
     * @enum {string}
     */
    var ErrorType = {
        ERROR: '0',
        PDF_ERROR: '1',
        WARNING: '2',
        CAUTION: '3',
        PDF_WARNING: '4',
        NOTE: '5',
        PDF_NOTE: '6'
    };
    Object.freeze(ErrorType);
    Object.seal(ErrorType);
    return ErrorType;
});

DPO.def('dto.ErrorCode', function () {
    /**
     * Error codes
     * @readonly
     * @memberof DPO.dto
     * @enum {string}
     */
    var ErrorCode = {
        OK: '0',
        IMAGE_NOT_SUPPORTED: '1',
        INVALID_PARAMETERS: '2',
        INTERNAL_ERROR: '3',
        INVALID__BARCODE_DATA: '4',
        UNKNOWN_ERROR: '5',
        PROCESSING_ERROR: '6',
        NOT_PROCESSED_YET: '7',
        FILE_NOT_FOUND: '8',
        IDENTIFICATION_ERROR: '9',
        IMAGE_RESOLUTION_EXCEEDED: '10',
        IMAGE_NOT_SUPPORTED_16bpp: '11',
        VERSION_SMALLER: '12',
        OPERATION_FORBIDDEN: '13',
        CANNOT_PERFORM: '14',
        IMAGE_IN_USE: '15',
        USER_DOES_NOT_EXIST: '16',
        IMAGE_CORRUPTED: '17',
        INVALID_USERNAME_OR_PASSWORD: '18',
        MM_UPLOAD_ERROR: '19',
        AVERY_BUNDLE_UPLOAD_ERROR: '433',
        IMAGE_UPLOAD_ERROR: '20',
        AUTHORIZATION_ERROR: '21',
        RESOURCE_NOT_FOUND: '22',
        INVALID_EMAIL: '27',
        EMPTY_EMAIL: '28',
        MISSING_EMAIL: '29',
        MISSED_PROJECT_IMAGES: '30',
        SAVE_PROJECT_FAULT: '31',
        IMPORT_DATA_FAULT: '32',
        APPLY_DESIGN_FAULT: '33',
        APPLY_ZDL_FAULT: '34',
        OPEN_PROJECT_FAULT: '35',
        DISPLAY_PROJECT_FAULT: '36',
        PRINT_PROJECT_FAULT: '37',
        DISPLAY_PROOF_FAULT: '38',
        LOST_DATA_MESSAGE: '100',
        DESIGN_FILLED_MESSAGE: '101',
        SMALL_FONT_SIZE: '104',
        INVALID_DPI: '105',
        INVALID_TEXT: '106',
        INVALID_DRAWING: '107',
        INVALID_BARCODE: '108',
        INVALID_IMAGE: '109',
        BACK_SIDE_NOT_SELECTED: '110',
        DEFAULT_TEXT_PRESENT: '111',
        CONSECUTIVE_SPACES: '112',
        WHITE_COLOR_USED: '113',
        SWITCHED_FROM_DIY: '114',
        COPY_PROJECT_ERROR: '115',
        CREATE_SINGLE_PDF_ERROR: '116',
        CREATE_PREVIEWS_ERROR: '117',
        METADATA_ADD_ERROR: '118',
        PAGE_COUNT: '119',
        INVALID_TEXT_NON_BLEED: '120',
        INVALID_DRAWING_NON_BLEED: '121',
        INVALID_BARCODE_NON_BLEED: '122',
        INVALID_IMAGE_NON_BLEED: '123',
        IMAGE_USED_AS_BACKGROUND: '124',
        CAS_NUMBER_NOT_FOUND: '125',
        SKU_IS_ON_HOLD: '126',
        UPLOADED_WARNING: '200',
        PDF_NOT_GENERATED: '201',
        PDF_GENERATION_CRASHED: '202',
        PDF_UPLOADED_WARNING: '203',
        IMAGE_TYPE_NOT_SUPPORTED: '204',
        FILE_TYPE_NOT_SUPPORTED: '204',
        EXTENDED_XML_NOT_EXIST: '205',
        PDF_REGENERATION_CRASHED: '206',
        USER_CONTENT_FILE_ALREADY_EXIST: '300',
        NOT_ALLOWED_USER_CONTENT_FILE_SIZE: '301',
        NOT_ALLOWED_IMAGE_FILE_SIZE: '302',
        GENERATION_CMYK: '303',
        ABSENT_PARAMETERS: '304',
        DIFY_SKU_NOT_EXIST_FOR_PRODUCT: '401',
        PREDESIGN_NOT_EXIST_FOR_PRODUCT: '402',
        PROOF_GENERATE_ERROR: '404',
        USER_PROJECT_NOT_EXIST_IN_DB: '406',
        PRODUCT_NOT_EXIST_IN_DB: '407',
        MARKETING_CATEGORY_NOT_EXIST_IN_DB: '408',
        TEMPLATE_NOT_EXIST_FOR_PREDESIGN: '409',
        MERGE_ERROR: '411',
        DEPLOYMENT_NOT_FOUND: '413',
        IMAGE_SIZE_NOT_SUPPORTED: '419',
        IMAGE_NOT_IDENTIFY: '422',
        IMAGE_CONVERT_SVG_TO_PNG: '423',
        PREDESIGN_NOT_FOUND: '428',
        USER_PROJECT_NO_EXIST: '429',
        FILE_SIZE_NOT_SUPPORTED: '431',
        NOT_IMPLEMENTED: '501',
        PDF_HAS_NOT_EMBEDDED_FONTS: '424'
    };
    Object.freeze(ErrorCode);
    Object.seal(ErrorCode);
    return ErrorCode;
});

/**
 * Error Data Transfer Object
 * @typedef {Object} DPO.dto.Error
 * @memberof DPO.dto
 * @property {string} errorMessage
 * @property {string} errorCode
 * @property {string} errorType
 */

/**
 * Product Data Transfer Object
 * @typedef {Object} DPO.dto.Product
 * @memberof DPO.dto
 * @property {string} id
 * @property {string} name
 * @property {string} description
 * @property {string} shortDescription
 * @property {string} descriptionSize
 * @property {string} uriPreview
 * @property {string} sku
 * @property {boolean} mergable
 * @property {string} productType
 * @property {string} printHelp
 * @property {string} colorDescription
 * @property {*} appearances
 * @property {object[]} categories
 * @property {string} productProfile
 * @property {string} difySku
 * @property {string} printProfile
 * @property {string} blankPredesignUri
 */

/**
 * Product Group Data Transfer Object
 * @typedef {Object} DPO.dto.ProductGroup
 * @memberof DPO.dto
 * @property {string} id
 * @property {string} name
 * @property {string} description
 * @property {string} uriPreview3dTall
 * @property {string} uriPreview3dWide
 * @property {boolean} applyToAll
 * @property {number} bleedSize
 * @property {number} safeFloor
 * @property {number} safeRoof
 * @property {number} safeFactor
 * @property {object[]} uiConfigurations
 */

/**
 * Project Location Data Transfer Object
 * @typedef {Object} DPO.dto.ProjectLocation
 * @memberof DPO.dto
 * @property {string} relativePath
 * @property {string} storageId
 */

/**
 * Project Data Transfer Object
 * @typedef {Object} DPO.dto.ProjectData
 * @memberof DPO.dto
 * @property {string} id
 * @property {string} name
 * @property {string} uriPreview
 * @property {*} orientation
 * @property {*} categories
 * @property {string} designThemeName
 * @property {number} diyRanking
 * @property {number} difyRanking
 * @property {*} keywords
 * @property {DPO.dto.Product} product
 * @property {DPO.dto.ProductGroup} productGroup
 * @property {object} mailMergeData
 * @property {object} quote
 * @property {string} content
 * @property {string} uriXML
 * @property {string} uriPDF
 * @property {string} uriZdlXML
 * @property {number} modificationDate
 * @property {string} templateName
 * @property {number} modifiers
 * @property {DPO.dto.ProjectLocation} projectLocation
 * @property {DPO.dto.Error[]} ?applyWarnings
 * @property {DPO.dto.Error[]} ?projectWarnings
 * @property {string} applicationType
 * @property {string} expandedContent
 * @property {boolean} applyDesignDisabled
 * @property {boolean} diyDifyCrossRefDisabled
 * @property {boolean} difyDiyCrossRefDisabled
 * @property {boolean} savingToPcDisabled
 */

DPO.def('dal.Endpoint', function () {
    function parseResponse(json) {
        try {
            var obj = JSON.parse(json);
            return {
                obj: obj,
                error: null
            };
        }
        catch (e) {
            Endpoint.exceptionHandler(e);
            return {
                obj: null,
                error: e
            };
        }
    }

    /**
     * @class DPO.dal.Endpoint
     * @extends DPO.mixins.Observable
     * @memberof DPO.dal
     * @param {string} url Endpoint URL
     * @property {string} url Endpoint URL
     * @constructor
     */
    function Endpoint(url) {
        var me = this;
        me.url = url;
        me.resetObservable();
    }

    Endpoint.exceptionHandler = DPO.emptyFn;
    DPO.mixin(Endpoint.prototype, DPO.mixins.Observable);
    DPO.mixin(Endpoint.prototype, {
        /**
         * Serializes query parameters
         * @memberof DPO.dal.Endpoint#
         * @param {object} obj
         * @returns {string}
         */
        params: function params(obj) {
            var keys = Object.keys(obj || {}),
                str = '?';
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i],
                    value = obj[key];
                if (Object.prototype.toString.call(value) === '[object Array]') {
                    var s = '';
                    for (var j = 0; j < value.length; j++) {
                        if (value[j] != null) {
                            s += encodeURIComponent(key) + '=' + encodeURIComponent(value[j]) + '&';
                        }
                    }
                    str += s;
                } else if (value != null) {
                    str = str + encodeURIComponent(key) + '=' + encodeURIComponent(value) + '&';
                }
            }

            return str.substring(0, str.length - 1);
        },

        /**
         * Prepares XMLHttpRequest for sending
         * @memberof DPO.dal.Endpoint#
         * @param {string} url
         * @param {string} [method]
         * @param {boolean} [privateScope]
         * @returns {XMLHttpRequest}
         */
        prepareRequest: function prepareRequest(url, method, privateScope) {
            var xhr = new XMLHttpRequest();
            xhr.open(method || 'GET', url, true);
            xhr.withCredentials = !!privateScope;
            return xhr;
        },

        /**
         * Creates request handler
         * @memberof DPO.dal.Endpoint#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @param {DPO.xml.Deserializer} [deserializer]
         * @returns {Function}
         */
        requestHandler: function requestHandler(success, fail, scope, deserializer) {
            scope = scope || this;
            function handle() {
                var xhr = this,
                    status = xhr.status,
                    code = status - (status % 100),
                    contentType = xhr.getResponseHeader('Content-Type') || '',
                    mimeType = contentType.split(';')[0],
                    obj, parseResult = {};
                switch (mimeType) {
                    case 'application/xml':
                    case 'text/xml':
                        obj = xhr.responseXML;
                        if (deserializer) {
                            obj = deserializer.deserialize(xhr.responseXML);
                        }
                        break;
                    case 'application/json':
                        parseResult = parseResponse(xhr.responseText);
                        obj = parseResult.obj;
                        break;
                    default:
                        obj = xhr.response;
                        break;
                }
                if (code !== 200 || parseResult.error) {
                    fail.call(scope, (obj && obj.errors) ? obj.errors : (parseResult.error || obj));
                    return;
                }

                success.call(scope, obj);
            }

            return handle;
        },

        /**
         * Creates error handler
         * @memberof DPO.dal.Endpoint#
         * @param {function} fail
         * @param {object} [scope]
         * @returns {Function}
         */
        errorHandler: function errorHandler(fail, scope) {
            scope = scope || this;
            return function RequestHandler() {
                fail.call(scope, [{code: 600}]);
            };
        },

        /**
         * Fetch REST resource
         * @memberof DPO.dal.Endpoint#
         * @param {string} url
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @param {boolean} [privateScope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetch: function fetch(url, success, fail, scope, privateScope) {
            var me = this,
                xhr = this.prepareRequest(url, 'GET', privateScope);
            xhr.addEventListener('error', me.errorHandler( fail, scope));
            xhr.addEventListener('load', me.requestHandler( success, fail, scope));
            xhr.setRequestHeader('Accept', '*/*');
            xhr.send();
            return {
                method: 'GET',
                url: url,
                xhr: xhr,
                scope: scope
            };
        }
    });
    return Endpoint;
});

DPO.def('dal.VersionsMetadata', function () {
    /**
     * Defines REST API versions metadata
     * @mixin DPO.dal.VersionsMetadata
     * @param {object} [metaData]
     * @memberof DPO.dal
     */
    function VersionsMetadata(metaData) {
        this.metaData = metaData || {};
    }

    DPO.mixin(VersionsMetadata.prototype, {
        /**
         * Create method wrapper with specified metadata
         * @memberof DPO.dal.VersionsMetadata#
         * @param {string} path
         * @param {number?} version
         * @param {string} method
         * @param {function} fn
         * @returns {function}
         */
        api: function api(path, version, method, fn) {
            var me = this,
                versions = me.metaData[path] || {};
            if (version == null) {
                var array = Object.keys(versions).map(DPO.toNumber).sort(DPO.compareNumbersAsc);
                version = array[array.length - 1] || 'LATEST_VERSION';
            }

            var data = versions[version];
            if (!data) {
                throw 'REST metadata is not defined: /v' + version + '/' + path;
            }

            if (!data[method]) {
                throw 'REST API ' + '/v' + version + '/' + path + ' does not support ' + method + ' method';
            }

            var wrapper = function restMetaDataWrapper() {
                var args = Array.prototype.slice.call(arguments);
                args[fn.length] = method;
                args[fn.length + 1] = path;
                args[fn.length + 2] = version;
                return fn.apply(this, args);
            };
            wrapper.dpoAPI = path;
            wrapper.dpoVersion = version;
            wrapper.dpoMethod = method;
            return wrapper;
        },

        /**
         * Prepares metadata for GET method
         * @memberof DPO.dal.VersionsMetadata#
         * @param {string} path
         * @param {number} [version]
         * @returns {function}
         * @constructor
         */
        GET: function GET(path, version) {
            var me = this;
            return function (fn) {
                return me.api(path, version, 'GET', fn);
            };
        },

        /**
         * Prepares metadata for POST method
         * @memberof DPO.dal.VersionsMetadata#
         * @param {string} path
         * @param {number} [version]
         * @returns {function}
         * @constructor
         */
        POST: function POST(path, version) {
            var me = this;
            return function (fn) {
                return me.api(path, version, 'POST', fn);
            };
        },

        /**
         * Prepares metadata for PUT method
         * @memberof DPO.dal.VersionsMetadata#
         * @param {string} path
         * @param {number} [version]
         * @returns {function}
         * @constructor
         */
        PUT: function PUT(path, version) {
            var me = this;
            return function (fn) {
                return me.api(path, version, 'PUT', fn);
            };
        },

        /**
         * Prepares metadata for DELETE method
         * @memberof DPO.dal.VersionsMetadata#
         * @param {string} path
         * @param {number} [version]
         * @returns {function}
         * @constructor
         */
        DELETE: function DELETE(path, version) {
            var me = this;
            return function (fn) {
                return me.api(path, version, 'DELETE', fn);
            };
        },

        /**
         * Assigns REST API metadata to specified target
         * @memberof DPO.dal.VersionsMetadata#
         * @param {*} target
         * @param {object} metaData
         */
        assignMetaData: function assignMetaData(target, metaData) {
            var methods = Object.keys(metaData);
            for (var i = 0; i < methods.length; i++) {
                var name = methods[i];
                target[name] = metaData[name](target[name]);
            }
        },

        /**
         * Checks API availability
         * @memberof DPO.dal.VersionsMetadata#
         * @param {*} obj
         * @param {DPO.wadl.Application} wadl
         * @param {boolean} [clean]
         */
        check: function check(obj, wadl, clean) {
            var escapeRegExp = /[\-\[\]\/\{}\(\)\*\+\?\.\\\^\$\|]/g,
                objMethods = [],
                prototype = obj,
                i, url;
            for (; prototype !== null; prototype = Object.getPrototypeOf(prototype)) {
                var keys = Object.keys(prototype);
                for (i = 0; i < keys.length; i++) {
                    var key = keys[i],
                        method = prototype[key];
                    if (method.dpoAPI) {
                        url = method.dpoMethod + ' /dpo8/rest/v' + method.dpoVersion + '/' + method.dpoAPI;
                        url = url.replace(/\/\//g, '/');
                        url = url.replace(/\{.+?\}/g, '{*}');
                        objMethods.push({
                            prop: key,
                            url: url,
                            wrapper: method
                        });
                    }
                }
            }

            var serviceMethods = DPO.dal.Versions.getRestMethods(wadl),
                result = {
                    supported: [],
                    missing: []
                };

            function patternCheck(url) {
                var array = url.split('{*}'),
                    i;
                for (i = 0; i < array.length; i++) {
                    array[i] = array[i].replace(escapeRegExp, '\\$&');
                }

                var regexp = new RegExp(array.join('([a-zA-z0-9\\s\\-]+|{\\*})') + '$'),
                    matched = false;
                for (i = 0; !matched && i < serviceMethods.length; i++) {
                    var method = serviceMethods[i];
                    matched = method.match(regexp);
                }

                return !!matched;
            }

            for (i = 0; i < objMethods.length; i++) {
                var info = objMethods[i];
                if (serviceMethods.indexOf(info.url) === -1 && !patternCheck(info.url)) {
                    result.missing.push(info);
                    if (clean) {
                        obj[info.prop] = null;
                    }
                } else {
                    result.supported.push(info);
                }
            }
            return result;
        },

        /**
         * Collects REST methods from WADl object
         * @param {DPO.wadl.Application} wadl
         * @memberof DPO.dal.VersionsMetadata#
         * @returns {string[]}
         */
        getRestMethods: function getRestMethods(wadl) {
            var methods = [];

            function getMethodSignature(methods, path) {
                var paths = [];
                for (var i = 0; i < methods.length; i++) {
                    var method = methods[i],
                        apiPath = method.name + ' ' + path;
                    apiPath = apiPath.replace(/\/\//g, '/');
                    apiPath = apiPath.replace(/\{.+?\}/g, '{*}');
                    paths.push(apiPath);
                }

                return paths;
            }

            function iterateResource(resource, prefix) {
                var methodSignatures = [],
                    path = (prefix + '/' + resource.path).replace(/\/\//g, '/'),
                    array, i;
                for (i = 0; i < resource.resources.length; i++) {
                    var rs = resource.resources[i];
                    array = iterateResource(rs, path);
                    methodSignatures = methodSignatures.concat(array);
                }

                array = getMethodSignature(resource.methods, path);
                methodSignatures = methodSignatures.concat(array);
                return methodSignatures;
            }

            for (var i = 0; i < wadl.resources.length; i++) {
                var resources = wadl.resources[i],
                    base = resources.base;
                base = base.replace(/https?:\/\/.+?\//, '/');
                for (var j = 0; j < resources.items.length; j++) {
                    methods = methods.concat(iterateResource(resources.items[j], base));
                }
            }

            return methods;
        }
    });

    /**
     * @memberof {DPO.dal}
     * @type {DPO.dal.VersionsMetadata}
     */
    DPO.dal.Versions = new VersionsMetadata({
        '{target}/public/configuration/countries': {
            '1': {GET: true}
        },

        // Products
        '{target}/public/products/categories': {
            '1': {GET: true}
        },
        '{target}/public/products': {
            '1': {GET: true}
        },
        '{target}/public/products/{productId}/suggestions': {
            '1': {GET: true}
        },
        '{target}/public/products/{productId}': {
            '1': {GET: true}
        },

        // Predesigns
        '{target}/public/predesigns/categories': {
            '1': {GET: true}
        },
        '{target}/public/predesigns/category': {
            '1': {GET: true}
        },
        '{target}/public/predesigns': {
            '1': {GET: true}
        },
        '{target}/public/predesigns/{predesignId}': {
            '1': {GET: true}
        },

        // Gallery
        '{target}/public/gallery/categories': {
            '1': {GET: true}
        },
        '{target}/public/gallery/image': {
            '1': {GET: true}
        },
        '{target}/public/gallery/images': {
            '1': {GET: true}
        },
        '{target}/public/gallery/images/{imageId}': {
            '1': {GET: true}
        },

        // Public project
        '{target}/public/projects': {
            '1': {GET: true}
        },
        '{target}/public/projects/create': {
            '1': {GET: true}
        },
        '{target}/public/projects/update': {
            '1': {PUT: true}
        },
        '{target}/public/projects/restore': {
            '1': {POST: true}
        },
        '{target}/public/projects/archive': {
            '1': {POST: true}
        },
        '{target}/public/projects/clone': {
            '1': {GET: true}
        },
        '{target}/public/projects/dify': {
            '1': {PUT: true}
        },
        '{target}/public/projects/pdf': {
            '1': {POST: true}
        },
        '{target}/public/projects/pdf/proof': {
            '1': {POST: true}
        },
        '{target}/public/projects/change/roll': {
            '1': {POST: true}
        },
        '{target}/public/projects/create/roll': {
            '1': {POST: 'application/json'}
        },
        '{target}/public/projects/data': {
            '1': {PUT: true}
        },
        '{target}/public/projects/images': {
            '1': {GET: true, PUT: true}
        },
        '{target}/public/projects/images/low': {
            '1': {GET: true}
        },
        '{target}/public/projects/images/generate/gracol': {
            '1': {GET: true}
        },
        '{target}/public/projects/images/{imageId}': {
            '1': {PUT: true}
        },
        '{target}/public/projects/remote/image': {
            '1': {PUT: true}
        },
        '{target}/public/projects/apply': {
            '1': {POST: true},
            '2': {POST: true}
        },
        '{target}/public/projects/apply/image': {
            '1': {GET: true}
        },
        '{target}/public/projects/apply/predesign': {
            '1': {GET: true}
        },
        '{target}/public/projects/apply/dify': {
            '1': {POST: true}
        },
        '{target}/public/merge/create': {
            '1': {GET: true}
        },
        '{target}/public/projects/replace/predesign': {
            '1': {GET: true}
        },

        // Private project
        '{target}/private/projects/{projectId}/apply': {
            '1': {GET: true, POST: true}
        },
        '{target}/private/projects/{projectId}/images/{imageId}': {
            '1': {PUT: true}
        },
        '{target}/private/projects/{projectId}/images': {
            '1': {PUT: true}
        },
        '{target}/private/projects/{projectId}': {
            '1': {GET: true, DELETE: true}
        },
        '{target}/private/projects': {
            '1': {GET: true, PUT: true}
        },
        '{target}/private/projects/dify': {
            '1': {PUT: true}
        },

        // Private Content
        '{target}/private/content/images/{imageId}/to': {
            '1': {PUT: true}
        },
        '{target}/private/content/images': {
            '1': {GET: true, PUT: true}
        },
        '{target}/private/content/{fileId}': {
            '1': {DELETE: true}
        },
        '{target}/private/content/data': {
            '1': {GET: true, PUT: true}
        },
        '{target}/private/content/data/{fileId}/to': {
            '1': {PUT: true}
        },

        // GHS
        '{target}/public/ghs/substances': {
            '1': {GET: true}
        },
        '{target}/public/ghs/hazard': {
            '1': {GET: true}
        },
        '{target}/public/ghs/precaution': {
            '1': {GET: true}
        },
        '{target}/public/projects/ghs/parse': {
            '1': {GET: true}
        },

        // Flow Config
        '{target}/public/fc': {
            '1': {GET: true}
        },

        // Artworks
        '{target}/private/artwork': {
            '1': {POST: true}
        },
        '{target}/private/artwork/{artworkId}/status': {
            '1': {GET: true}
        },
        '{target}/private/artwork/{artworkId}/rename': {
            '1': {PUT: true}
        },
        '{target}/private/artwork/{artworkId}/preview': {
            '1': {GET: true}
        },
        '{target}/private/artwork/{artworkId}': {
            '1': {GET: true, PUT: true}
        },
        '{target}/public/barcode/{type}': {
            '1': {GET: true}
        },

        'public/flickr/request-token': {
            '1': {GET: true}
        },
        'public/flickr/access-token': {
            '1': {GET: true}
        },
        'user/account-status': {
            '1': {GET: true}
        }
    });

    return VersionsMetadata;
});

DPO.def('dal.Request', function () {
    /**
     * @class DPO.dal.Request
     * @params {string} host
     * @params {string} rest
     * @params {number} version
     * @params {string} method
     * @memberof DPO.dal
     */
    function Request(host, rest, version, method) {
        this.host = host;
        this.rest = rest;
        this.version = version;
        this.method = method;
        this._params = {};
        this._query = {};
    }

    DPO.mixin(Request.prototype, {
        /**
         * Assigns REST parameters
         * @memberof DPO.dal.Request#
         * @param {object} obj
         * @returns {DPO.dal.Request}
         */
        params: function params(obj) {
            DPO.mixin(this._params, obj);
            return this;
        },

        /**
         * Assigns query parameters
         * @memberof DPO.dal.Request#
         * @param {object} obj
         * @returns {DPO.dal.Request}
         */
        query: function query(obj) {
            DPO.mixin(this._query, obj);
            return this;
        },

        /**
         * Creates full URL
         * @memberof DPO.dal.Request#
         * @returns {string}
         */
        buildURL: function buildURL() {
            var me = this,
                keys = Object.keys(me._params),
                url = this.rest,
                query = '?', key, value, i;
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                url = url.replace('{' + key + '}', me._params[key]);
            }

            if (url.match(/{.*}/)) {
                throw 'URL: ' + url + ' have unassigned path parameter(s)';
            }

            keys = Object.keys(me._query);
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                value = me._query[key];
                if (Object.prototype.toString.call(value) === '[object Array]') {
                    var s = '';
                    for (var j = 0; j < value.length; j++) {
                        if (value[j] != null) {
                            s += encodeURIComponent(key) + '=' + encodeURIComponent(value[j]) + '&';
                        }
                    }
                    query += s;
                } else if (value != null) {
                    query = query + encodeURIComponent(key) + '=' + encodeURIComponent(value) + '&';
                }
            }

            return me.host + 'v' + me.version + '/' + url + query.substring(0, query.length - 1);
        },

        /**
         * Opens connection
         * @memberof DPO.dal.Request#
         * @param {boolean} [withCredentials]
         * @returns {DPO.dal.Request}
         */
        open: function open(withCredentials) {
            var me = this,
                xhr = new XMLHttpRequest(),
                url = me.buildURL();
            if (withCredentials === undefined) {
                withCredentials = !!url.match(/\/private\//);
            }
            xhr.open(me.method, url, true);
            xhr.setRequestHeader('Accept', '*/*');
            xhr.withCredentials = withCredentials;
            me.xhr = xhr;
            return me;
        },

        /**
         * Assigns event listeners to current connection
         * @memberof DPO.dal.Request#
         * @param {object} listeners
         * @returns {DPO.dal.Request}
         */
        listen: function listen(listeners) {
            var me = this,
                keys = Object.keys(listeners);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                me.xhr.addEventListener(key, listeners[key]);
            }

            return me;
        },

        /**
         * Assigns event listeners to current connection
         * @memberof DPO.dal.Request#
         * @param {*} [body]
         * @param {string} [mimeType]
         * @returns {DPO.dal.Request}
         */
        send: function send(body, mimeType) {
            if (mimeType) {
                this.xhr.setRequestHeader('Content-Type', mimeType);
            }
            this.xhr.send(body);
            return this;
        }
    });

    return Request;
});

DPO.def('dal.DAL', function () {
    /**
     * @class DPO.dal.DAL
     * @extends DPO.dal.Endpoint
     * @memberof DPO.dal
     * @params {string} host
     * @params {string} target
     * @constructor
     */
    function DAL(host, target) {
        var me = this;
        me.host = host;
        me.url = host;// + 'v1/' + target;
        me.target = target;
        me.resetObservable();
    }

    DPO.inherit(DAL, DPO.dal.Endpoint);
    DPO.mixin(DAL.prototype, {
        /**
         * Creates request
         * @memberof DPO.dal.DAL#
         * @param {*} args
         * @returns {DPO.dal.Request}
         */
        request: function request(args) {
            var rest = args[args.length - 2],
                version = args[args.length - 1],
                method = args[args.length - 3];
            if (typeof version !== 'number' || typeof rest !== 'string' || typeof method !== 'string') {
                throw 'REST metadata is missing';
            }

            var request = new DPO.dal.Request(this.host, rest, version, method);
            return request.params({target: this.target});
        },

        /**
         * Fetches Web Application Description Language XML
         * @memberof DPO.dal.DAL#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        fetchWADL: function fetchWADL(success, fail, scope) {
            var me = this,
                xhr = new XMLHttpRequest(),
                url = me.host + 'application.wadl',
                deserializer = new DPO.xml.Deserializer(DPO.wadl.Application, {
                    introspector: new DPO.xml.Introspector({
                        modelLookupTable: DPO.wadl
                    })
                });
            url = url.replace('/rest', '');
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope, deserializer));
            xhr.open('GET', url, true);
            xhr.send();
        },

        /**
         * Builds full REST URL
         * @memberof DPO.dal.DAL#
         * @param {string} scope
         * @param {string} resource
         * @param {object} [query]
         * @returns {string}
         */
        buildUrl: function buildUrl(scope, resource, query) {
            return this.url + 'v1/US_en/' + scope + '/' + resource + this.params(query);
        },

        /**
         * Builds full REST URL for barcode API.
         * @memberof DPO.dal.DAL#
         * @param {object} barcode
         */
        buildBarcodeUrl: function buildBarcodeUrl(barcode) {
            return this.request(arguments).params({type: barcode.query}).query(barcode.params).buildURL();
        },

        /**
         * Checks account status
         * @memberof DPO.dal.DAL#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        checkAccountStatus: function checkAccountStatus(success, fail, scope) {
            var me = this;
            return me.request(arguments).open(true)
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Creates new account
         * @memberof DPO.dal.DAL#
         * @param {string} url
         * @param {object} form
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        createAccount: function createAccount(url, form, success, fail, scope) {
            var me = this,
                xhr = new XMLHttpRequest();
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope));
            xhr.open('POST', url, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify(form));
        },

        /**
         * Fetches countries
         * @memberof DPO.dal.DAL#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchCountries: function fetchCountries(success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches products' categories
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchProductsCategories: function fetchProductsCategories(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches products using provided parameters
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchProducts: function fetchProducts(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches products data
         * @memberof DPO.dal.DAL#
         * @param {string} productId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchProductsData: function fetchProducts(productId, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({productId: productId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches predesigns' categories
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchPredesignsCategories: function fetchPredesignsCategories(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches predesigns
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchPredesigns: function fetchPredesigns(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches single predesign
         * @memberof DPO.dal.DAL#
         * @param {object} predesignId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchPredesign: function fetchPredesigns(predesignId, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({predesignId: predesignId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches user's projects
         * @memberof DPO.dal.DAL#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchProjects: function fetchPredesigns(success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches project data by specified storage & relative path
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchProjectInfo: function fetchProjectInfo(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Creates project
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        createProject: function createProject(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Creates roll labels project
         * @memberof DPO.dal.DAL#
         * @param {?string} productId
         * @param {?string} predesignId
         * @param {object} quote
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        createRollProject: function createRollProject(productId, predesignId, quote, success, fail, scope) {
            var me = this;
            return me.request(arguments)
                .query({
                    productId: productId,
                    predesignId: predesignId
                })
                .open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(quote), 'application/json');
        },

        /**
         * Creates new empty project with specified image
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        createProjectWithImg: function createProjectWithImg(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Creates project with design source
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        createProjectWithDesignSource: function createProjectWithDesignSource(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Merges external data to specified project location
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        mergeDataToProject: function mergeDataToProject(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Copies image from avery gallery to specified project
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyGalleryImageToProject: function copyGalleryImageToProject(id, projectData, success, fail, scope) {
            var me = this,
                method = projectData.id ? me.copyGalleryImageToPrivateProject : me.copyGalleryImageToPublicProject;
            return method.apply(me, arguments);
        },

        /**
         * Copies image from avery gallery to public project
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyGalleryImageToPublicProject: function copyGalleryImageToPublicProject(id, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                query = {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).params({imageId: id}).query(query).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Copies image from avery gallery to private project
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyGalleryImageToPrivateProject: function copyGalleryImageToPrivateProject(id, projectData, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({imageId: id, projectId: projectData.id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Copies image from user content to specified project
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyUserImageToProject: function copyUserImageToProject(id, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                params = projectData.id ? {
                    projectId: projectData.id
                } : {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).params({imageId: id}).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Get images from user project
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        getImagesFromUserProject: function getImagesFromUserProject(projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                query = {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(query).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Copies images from project storage to user's content
         * @param {object[]} files
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyImagesToUserContent: function copyImagesToUserContent(files, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                query = {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(query).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(files), 'application/json');
        },

        /**
         * Copies file from user content to specified project
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyUserFileToProject: function copyUserFileToProject(id, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                query = projectData.id ? {
                    projectId: projectData.id
                } : {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).params({fileId: id}).query(query).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Deletes user file (image or mail merge file)
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        deleteUserFile: function deleteUserFile(id, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({fileId: id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches images categories
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchImagesCategories: function fetchImagesCategories(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches private images
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchPrivateImages: function fetchPrivateImages(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches private files
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchPrivateFiles: function fetchPrivateFiles(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches images by category
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchImagesByCategory: function fetchImagesByCategory(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches image by id
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchImageById: function fetchImageById(id, success, fail, scope) {
            var me = this;
            return me.request(arguments).query({id: id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Fetches project data by id
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchProjectData: function fetchProjectData(id, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({projectId: id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Clone project by it's identifier
         * @memberof DPO.dal.DAL#
         * @param {string} projectId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        cloneProject: function cloneProject(projectId, success, fail, scope) {
            var me = this;
            return me.request(arguments).query({id: projectId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Loads projects from specified location
         * @memberof DPO.dal.DAL#
         * @param {string} url
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        loadProject: function loadProject(url, success, fail, scope) {
            var me = this,
                xhr = me.prepareRequest(url),
                deserializer = new DPO.model.Deserializer(DPO.model.Project);
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope, deserializer));
            xhr.send();
        },

        /**
         * Return substance data for corresponding cas
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchSubstance: function fetchSubstance(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Return list off hazard codes
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchHazardCodes: function fetchHazardCodes(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Return list off precaution codes
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchPrecautionCodes: function fetchPrecautionCodes(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Return parsed GHS merge data
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        parseGHSMergeData: function parseGHSMergeData(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Generates PDF file
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {DPO.model.Project} project
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        generatePdf: function generatePdf(projectData, project, success, fail, scope) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(project),
                data = DPO.mixin({}, projectData, {content: xml});
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(data), 'application/json');
        },

        /**
         * Creates project archive
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        archiveProject: function archiveProject(projectData, success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(projectData), 'application/json');
        },

        /**
         * Saves user's project
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        saveProject: function saveProject(params, projectData, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(projectData), 'application/json');
        },

        /**
         * Updates project XML & project mail merge data on remove storage
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        updateProject: function updateProject(projectData, success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(projectData), 'application/json');
        },

        /**
         * Deletes user project
         * @memberof DPO.dal.DAL#
         * @param {string} id
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        deleteProject: function deleteProject(id, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({projectId: id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Restores project archive
         * @memberof DPO.dal.DAL#
         * @param {FormData} form
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        restoreProject: function restoreProject(form, success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(form);
        },

        /**
         * Uploads images to project folder
         * @memberof DPO.dal.DAL#
         * @param {FormData} form
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        uploadImages: function uploadImages(form, projectData, success, fail, scope) {
            var me = this,
                method = projectData.id ? me.uploadImagesToPrivateProject : me.uploadImagesToPublicProject;
            return method.apply(me, arguments);
        },

        uploadImagesToPublicProject: function uploadImagesToPublicProject(form, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                query = {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(query).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(form);
        },

        uploadImagesToPrivateProject: function uploadImagesToPrivateProject(form, projectData, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({projectId: projectData.id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(form);
        },

        /**
         * Change design for Roll Labels project
         * @memberof DPO.dal.DAL#
         * @param {object} data
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        changeRollLabelsDesign: function changeRollLabelsDesign(data, success, fail, scope) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(data.project),
                projectDTO = DPO.mixin({}, data.projectData, {content: xml});
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify({
                    versions: data.versions,
                    quote: data.quote,
                    projectDTO: projectDTO
                }), 'application/json');
        },

        /**
         * Uploads Artwork for RollLabel project
         * @memberof DPO.dal.DAL#
         * @param {FormData} form
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        uploadArtwork: function uploadArtwork(form, success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(form);
        },

        /**
         * Fetches Artwork progress
         * @memberof DPO.dal.DAL#
         * @param {string} artworkId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchArtworkStatus: function fetchArtworkStatus(artworkId, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({artworkId: artworkId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Updates Artwork for RollLabel project
         * @memberof DPO.dal.DAL#
         * @param {FormData} form
         * @param {string} artworkId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        updateArtwork: function updateArtwork(form, artworkId, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({artworkId: artworkId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(form);
        },

        /**
         * Fetches Artwork by artworkId
         * @memberof DPO.dal.DAL#
         * @param {string} artworkId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchArtwork: function fetchArtwork(artworkId, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({artworkId: artworkId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Rename Artwork
         * @memberof DPO.dal.DAL#
         * @param {string} artworkId
         * @param {string} name
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        renameArtwork: function renameArtwork(artworkId, name, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({artworkId: artworkId}).query({name: name}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Copies image from specified URL to project storage
         * @param {string} imageUrl
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        copyRemoteImage: function copyRemoteImage(imageUrl, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                params = {
                    imageUrl: imageUrl,
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Load image (with blob type)
         * @memberof DPO.dal.DAL#
         * @param {String} url
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        loadImageByURL: function loadImageByURL(url, success, fail, scope) {
            var me = this,
                xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'blob';
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope));
            xhr.send();
        },

        /**
         * Requests low resolution image
         * @memberof DPO.dal.DAL#
         * @param {string} imageName
         * @param {boolean} cmyk
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        requestLowResImage: function requestLowResImage(imageName, cmyk, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                params = {
                    imageName: imageName,
                    cmyk: cmyk,
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Adds artwork to project from S3
         * @memberof DPO.dal.DAL#
         * @param {string} artworkId
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {*}
         */
        uploadArtworkToProject: function uploadArtworkToProject(artworkId, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                storageId = location.storageId,
                relativePath = location.relativePath,
                url = me.buildUrl('public', 'projects/artwork/' + artworkId, {
                    storageId: storageId,
                    relativePath: relativePath
                }),
                xhr = me.prepareRequest(url, 'PUT');
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope));
            xhr.send();
            return {
                method: 'PUT',
                url: url,
                xhr: xhr,
                scope: scope
            };
        },

        /**
         * Finish upload artwork project
         * @memberof DPO.dal.DAL#
         * @param {string} artworkId
         * @param {object} data
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {*}
         */
        finishArtworkProject: function finishArtworkProject(artworkId, data, success, fail, scope) {
            var me = this,
                url = me.buildUrl('public', 'projects/artwork/finish', {
                    artworkId: artworkId
                }),
                xhr = me.prepareRequest(url, 'PUT');

            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope));

            var serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(data.project),
                projectDTO = DPO.mixin({}, data.projectData, {content: xml});

            xhr.send(JSON.stringify(projectDTO));
            return {
                method: 'PUT',
                url: url,
                xhr: xhr,
                scope: scope
            };
        },

        /**
         * Requests image in CMYK color space
         * @param {string[]} imageNames
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        requestImageInColorSpace: function requestImageInColorSpace(imageNames, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                params = {
                    imageName: imageNames,
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Uploads file for mail merge
         * @memberof DPO.dal.DAL#
         * @param {FormData} form
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        uploadMailMerge: function uploadMailMerge(form, projectData, success, fail, scope) {
            var me = this,
                location = projectData.projectLocation,
                params = {
                    storageId: location.storageId,
                    relativePath: location.relativePath
                };
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(form);
        },

        /**
         * Applies DIFY product & predesign to current project
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        applyDifyProduct: function applyDifyProduct(projectData, success, fail, scope) {
            var me = this;
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(projectData), 'application/json');
        },

        /**
         * Generates proof PDF file for DIFY product
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {DPO.model.Project} project
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        generateProofPdf: function generateProofPdf(projectData, project, success, fail, scope) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(project),
                data = DPO.mixin({}, projectData, {content: xml});
            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(data), 'application/json');
        },

        /**
         * Creates snapshot for DIFY project
         * @memberof DPO.dal.DAL#
         * @param {object} projectData
         * @param {DPO.model.Project} project
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        createDifySnapshot: function createDifySnapshot(projectData, project, params, success, fail, scope) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(project),
                data = DPO.mixin({}, projectData, {content: xml}),
                method = projectData.id ? me.createPrivateDifySnapshot : me.createPublicDifySnapshot;
            return method.apply(me, [data, project, params, success, fail, scope]);
        },

        createPublicDifySnapshot: function createPublicDifySnapshot(projectData, project, params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(projectData), 'application/json');
        },

        createPrivateDifySnapshot: function createPrivateDifySnapshot(projectData, project, params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(projectData), 'application/json');
        },

        /**
         * Get DIY CategoryDTO by DIFY sku
         * @memberof DPO.dal.DAL#
         * @param {string} difySku
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        getDiyCategoryForDifySku: function getDiyCategoryForDifySku(difySku, success, fail, scope) {
            var me = this;
            return me.request(arguments).query({sku: difySku}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Get suggested products
         * @memberof DPO.dal.DAL#
         * @param {string} productId
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        getSuggestedProducts: function getSuggestedProducts(productId, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({productId: productId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Applies current design to specified product
         * @memberof DPO.dal.DAL#
         * @param {string|object} productId
         * @param {object} projectData
         * @param {DPO.model.Project} project
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        applyPredesign: function applyPredesign(productId, projectData, project, success, fail, scope) {
            var me = this,
                method = (!project && projectData.id) ? me.applyPredesignPrivate : me.applyPredesignPublic;
            return method.apply(me, arguments);
        },

        applyPredesignPublic: function applyPredesignPublic(productId, projectData, project, success, fail, scope) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(project),
                data = DPO.mixin({}, projectData, {content: xml});
            return me.request(arguments).query({productId: productId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(data), 'application/json');
        },

        applyPredesignPrivate: function applyPredesignPrivate(productId, projectData, project, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({projectId: projectData.id}).query({productId: productId}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Applies current design to roll label product
         * @param {object} quote
         * @param {object} projectData
         * @param {DPO.model.Project} project
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        applyPredesignToRollProduct: function applyPredesignToRollProduct(quote, projectData, project, success, fail, scope) {
            var me = this,
                method = projectData.id ? me.applyPredesignToRollProductPrivate : me.applyPredesignToRollProductPublic;
            return method.apply(me, arguments);
        },

        applyPredesignToRollProductPublic: function applyPredesignToRollProductPublic(quote, projectData, project, success, fail, scope) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                xml = serializer.serializeToXML(project),
                data = {
                    projectDTO: DPO.mixin({}, projectData, {content: xml}),
                    quote: quote
                };

            return me.request(arguments).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(data), 'application/json');
        },

        applyPredesignToRollProductPrivate: function applyPredesignToRollProductPrivate(quote, projectData, project, success, fail, scope) {
            var me = this;
            return me.request(arguments).params({projectId: projectData.id}).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send(JSON.stringify(quote), 'application/json');
        },

        /**
         * Replaces project predesign
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        replacePredesign: function replacePredesign(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope)
                }).send();
        },

        /**
         * Requests Flickr token
         * @memberof DPO.dal.DAL#
         * @param {string} callbackURL
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        requestFlickrToken: function requestFlickrToken(callbackURL, success, fail, scope) {
            var me = this;
            return me.request(arguments).query({callbackURL: callbackURL}).open().listen({
                'error': me.errorHandler(fail, scope),
                'load': me.requestHandler(success, fail, scope)
            }).send();
        },

        /**
         * Authorize access Flickr token
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        accessFlickrToken: function accessFlickrToken(params, success, fail, scope) {
            var me = this;
            return me.request(arguments).query(params).open().listen({
                'error': me.errorHandler(fail, scope),
                'load': me.requestHandler(success, fail, scope)
            }).send();
        },

        /**
         * Fetches flow configuration
         * @memberof DPO.dal.DAL#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {DPO.dal.Request}
         */
        fetchFlowConfiguration: function fetchFlowConfiguration(params, success, fail, scope) {
            var me = this,
                deserializer = new DPO.xml.Deserializer(DPO.fc.Configuration, {
                    introspector: new DPO.xml.Introspector({
                        modelLookupTable: DPO.fc
                    })
                });
            return me.request(arguments).query(params).open()
                .listen({
                    'error': me.errorHandler(fail, scope),
                    'load': me.requestHandler(success, fail, scope, deserializer)
                }).send();
        }
    });

    // Assign REST metadata
    var versions = DPO.dal.Versions;
    versions.assignMetaData(DAL.prototype, {
        fetchProductsCategories: versions.GET('{target}/public/products/categories'),
        fetchCountries: versions.GET('{target}/public/configuration/countries'),
        fetchProducts: versions.GET('{target}/public/products'),
        fetchProductsData: versions.GET('{target}/public/products/{productId}'),
        fetchPredesignsCategories: versions.GET('{target}/public/predesigns/categories'),
        fetchPredesigns: versions.GET('{target}/public/predesigns'),
        fetchPredesign: versions.GET('{target}/public/predesigns/{predesignId}'),
        fetchProjects: versions.GET('{target}/private/projects'),
        fetchProjectInfo: versions.GET('{target}/public/projects'),
        createProject: versions.GET('{target}/public/projects/create'),
        createRollProject: versions.POST('{target}/public/projects/create/roll'),
        createProjectWithImg: versions.GET('{target}/public/projects/apply/image'),
        createProjectWithDesignSource: versions.GET('{target}/public/projects/apply/predesign'),
        mergeDataToProject: versions.GET('{target}/public/merge/create'),
        copyGalleryImageToPublicProject: versions.PUT('{target}/public/projects/images/{imageId}'),
        copyGalleryImageToPrivateProject: versions.PUT('{target}/private/projects/{projectId}/images/{imageId}'),
        getImagesFromUserProject: versions.GET('{target}/public/projects/images'),
        copyImagesToUserContent: versions.PUT('{target}/private/content/images'),
        copyUserFileToProject: versions.PUT('{target}/private/content/data/{fileId}/to'),
        deleteUserFile: versions.DELETE('{target}/private/content/{fileId}'),
        fetchImagesCategories: versions.GET('{target}/public/gallery/categories'),
        fetchPrivateImages: versions.GET('{target}/private/content/images'),
        fetchPrivateFiles: versions.GET('{target}/private/content/data'),
        fetchImagesByCategory: versions.GET('{target}/public/gallery/images'),
        fetchImageById: versions.GET('{target}/public/gallery/image'),
        fetchProjectData: versions.GET('{target}/private/projects/{projectId}'),
        cloneProject: versions.GET('{target}/public/projects/clone'),
        fetchSubstance: versions.GET('{target}/public/ghs/substances'),
        fetchHazardCodes: versions.GET('{target}/public/ghs/hazard'),
        fetchPrecautionCodes: versions.GET('{target}/public/ghs/precaution'),
        parseGHSMergeData: versions.GET('{target}/public/projects/ghs/parse'),
        generateProofPdf: versions.POST('{target}/public/projects/pdf/proof'),
        generatePdf: versions.POST('{target}/public/projects/pdf'),
        archiveProject: versions.POST('{target}/public/projects/archive'),
        saveProject: versions.PUT('{target}/private/projects'),
        updateProject: versions.PUT('{target}/public/projects/update'),
        deleteProject: versions.DELETE('{target}/private/projects/{projectId}'),
        restoreProject: versions.POST('{target}/public/projects/restore'),
        fetchFlowConfiguration: versions.GET('{target}/public/fc'),
        getSuggestedProducts: versions.GET('{target}/public/products/{productId}/suggestions'),
        uploadImagesToPublicProject: versions.PUT('{target}/public/projects/images'),
        uploadImagesToPrivateProject: versions.PUT('{target}/private/projects/{projectId}/images'),
        changeRollLabelsDesign: versions.POST('{target}/public/projects/change/roll'),
        copyRemoteImage: versions.PUT('{target}/public/projects/remote/image'),
        requestLowResImage: versions.GET('{target}/public/projects/images/low'),
        requestImageInColorSpace: versions.GET('{target}/public/projects/images/generate/gracol'),
        uploadMailMerge: versions.PUT('{target}/public/projects/data'),
        applyDifyProduct: versions.POST('{target}/public/projects/apply/dify'),
        createPublicDifySnapshot: versions.PUT('{target}/public/projects/dify'),
        createPrivateDifySnapshot: versions.PUT('{target}/private/projects/dify'),
        getDiyCategoryForDifySku: versions.GET('{target}/public/predesigns/category'),
        applyPredesignPublic: versions.POST('{target}/public/projects/apply', 1),
        applyPredesignPrivate: versions.GET('{target}/private/projects/{projectId}/apply'),
        applyPredesignToRollProductPublic: versions.POST('{target}/public/projects/apply'),
        applyPredesignToRollProductPrivate: versions.POST('{target}/private/projects/{projectId}/apply'),
        buildBarcodeUrl: versions.GET('{target}/public/barcode/{type}'),
        copyUserImageToProject: versions.PUT('{target}/private/content/images/{imageId}/to'),
        requestFlickrToken: versions.GET('public/flickr/request-token'),
        accessFlickrToken: versions.GET('public/flickr/access-token'),
        checkAccountStatus: versions.GET('user/account-status'),

        uploadArtwork: versions.POST('{target}/private/artwork'),
        fetchArtworkStatus: versions.GET('{target}/private/artwork/{artworkId}/status'),
        updateArtwork: versions.PUT('{target}/private/artwork/{artworkId}'),
        fetchArtwork: versions.GET('{target}/private/artwork/{artworkId}'),
        renameArtwork: versions.PUT('{target}/private/artwork/{artworkId}/rename'),

        replacePredesign: versions.GET('{target}/public/projects/replace/predesign')
    });

    return DAL;
});

DPO.def('render', function () {
    /**
     * @memberof DPO
     * @type {object}
     * @namespace DPO.render
     */
    var render = {};

    /**
     * Applies CSS styles to specified DOM element
     * @memberof DPO.render
     * @param {Element} el
     * @param {object} styles
     * @returns {Element}
     */
    render.applyStyles = function applyStyles(el, styles) {
        var keys = Object.keys(styles);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            el.style.setProperty(key, styles[key], '');
        }

        return el;
    };

    /**
     * Removes all children from specified container
     * @memberof DPO.render
     * @param {Element} container
     */
    render.clearContainer = function clearContainer(container) {
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
    };

    //noinspection OverlyComplexBooleanExpressionJS
    /**
     * Requests animation frame
     * @memberof DPO.render
     * @function
     * @param {function} callback
     */
    render.requestAnimationFrame = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
    render.requestAnimationFrame = render.requestAnimationFrame.bind(window);
    
    return render;
});
DPO.def('render.Context', function () {
    /**
     * Creates new context for render components
     * @class DPO.render.Context
     * @extends DPO.project.Context
     * @memberof DPO.render
     * @param {DPO.model.Project} project
     * @param {DPO.text.LayoutManager} layoutManager
     * @param {object} [storage]
     * @param {DPO.mmd.DataSourceProvider} [provider]
     * @param {DPO.render.DeviceColorSpace} [colorSpace]
     * @property {DPO.model.Project} project
     * @property {DPO.text.LayoutManager} layoutManager
     * @property {object} storage
     * @property {DPO.mmd.DataSourceProvider} provider
     * @property {DPO.project.Transformer} projectTransformer
     * @property {DPO.project.Editor} projectEditor
     * @property {DPO.model.Selector} selector
     * @property {DPO.project.Binder} binder
     * @property {DPO.project.Validator} validator
     * @property {DPO.render.DeviceColorSpace} colorSpace
     * @constructor
     */
    function Context(project, layoutManager, storage, provider, colorSpace) {
        var me = this;
        DPO.project.Context.apply(me, [project, layoutManager, storage, provider]);
        me.colorSpace = colorSpace;
    }

    DPO.inherit(Context, DPO.project.Context);
    Object.defineProperty(Context.prototype, 'colorSpace', {
        get: function get() {
            return this._colorSpace;
        },

        set: function set(value) {
            var me = this;
            if (me._colorSpace === value) {
                return;
            }

            if (me._colorSpace) {
                me._colorSpace.resetObservable();
            }

            me._colorSpace = value;
            me.fire('changed:color-space', [me, value]);
        }
    });

    return Context;
});
DPO.def('render.Markup', function () {
    function makeChildren(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
            var item = array[i];
            result.push(item instanceof Markup ? item.clone() : new Markup(item));
        }

        return result;
    }

    /**
     * Creates a new render markup object.
     * @class DPO.render.Markup
     * @memberof DPO.render
     * @property {string} type
     * @property {object} geometry
     * @property {object} style
     * @property {object} css
     * @property {object} attributes
     * @property {DPO.render.Markup[]} children
     * @property {boolean} overrideChildren
     * @param {string|DPO.render.Markup|{type: string, geometry: object, style: object, children: object[]}} [typeOrMarkup={}] typeOrMarkup
     * @param {object} [geometry={}] geometry
     * @param {object} [style={}] style
     * @param {DPO.render.Markup[]} [children=[]] children
     * @param {object} [css={}]
     * @param {object} [attributes={}]
     * @param {boolean} [overrideChildren=false]
     * @constructor
     */
    function Markup(typeOrMarkup, geometry, style, children, css, attributes, overrideChildren) {
        var me = this;
        if (typeof typeOrMarkup === 'string') {
            me.type = typeOrMarkup;
            me.geometry = DPO.mixin({}, geometry);
            me.style = DPO.mixin({}, style);
            me.children = makeChildren(children || []);
            me.css = DPO.mixin({}, css);
            me.attributes = DPO.mixin({}, attributes);
            me.overrideChildren = !!overrideChildren;
        } else if (typeOrMarkup instanceof Markup || typeof typeOrMarkup === 'object') {
            me.type = typeOrMarkup.type || 'g';
            me.geometry = DPO.mixin({}, typeOrMarkup.geometry);
            me.style = DPO.mixin({}, typeOrMarkup.style);
            me.children = makeChildren(typeOrMarkup.children || []);
            me.css = DPO.mixin({}, typeOrMarkup.css);
            me.attributes = DPO.mixin({}, typeOrMarkup.attributes);
            me.overrideChildren = !!typeOrMarkup.overrideChildren;
            me.extResource = typeOrMarkup.extResource;
        } else {
            me.type = 'g';
            me.geometry = {};
            me.style = {};
            me.children = [];
            me.css = {};
            me.attributes = {};
            me.overrideChildren = false;
        }
    }

    DPO.mixin(Markup.prototype, {
        /**
         * Creates clone of current Markup object
         * @memberof DPO.render.Markup#
         * @returns {DPO.render.Markup}
         */
        clone: function clone() {
            return new Markup(this);
        },

        /**
         * Gets child markup by specified identifier
         * @memberof DPO.render.Markup#
         * @param {string|RegExp} id
         * @returns {DPO.render.Markup}
         */
        getMarkup: function getMarkup(id) {
            var me = this,
                child = null;
            if (typeof id === 'string' && this.geometry.id === id) {
                return this;
            }

            if (id instanceof RegExp && id.test(this.geometry.id || '')) {
                return this;
            }

            for (var i = 0; !child && i < me.children.length; i++) {
                child = me.children[i].getMarkup(id);
            }
            return child;
        }
    });

    return Markup;
});

/**
 * Created by amam on 11/12/14.
 */
Snap.plugin(function (Snap, Element) {
    // Internet Explorer 10/11 doesn't support xml:space="preserve"
    // So this function replaces regular space to non-breaking space
    function replaceSpaces(string) {
        return string.replace(/\s/gm, '\u00A0');
    }

    function applyAttributes(el, attr) {
        Object.keys(attr).forEach(function (key) {
            if (key === 'xml:space') {
                el.node.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', attr[key]);
            } else {
                el.node.setAttribute(key, attr[key]);
            }
        });
    }

    /**
     * Creates SVG element
     * @param {DPO.render.Markup} markup
     * @returns {*}
     */
    Element.prototype.dpoRender = function dpoRender(markup) {
        var attributes = DPO.mixin({}, markup.geometry, markup.style),
            children = markup.children,
            type = markup.type,
            el;
        if (type === 'image') {
            el = this.image(attributes.href, attributes.x, attributes.y, attributes.width, attributes.height);
            delete attributes.href;
            delete attributes.x;
            delete attributes.y;
            delete attributes.width;
            delete attributes.height;
            el.attr(attributes);
        } else {
            el = this[markup.type](attributes);
        }

        for (var i = 0; i < children.length; i++) {
            el.dpoRender(children[i]);
        }

        DPO.render.applyStyles(el.node, markup.css);
        applyAttributes(el, markup.attributes);
        return el;
    };

    /**
     * Updates whole element
     * @param {DPO.render.Markup} markup
     * @returns {*}
     */
    Element.prototype.dpoUpdate = function dpoUpdate(markup) {
        var id = markup.geometry.id,
            el = this.select('#' + id),
            children = markup.children,
            attributes = DPO.mixin({}, markup.geometry, markup.style), i;
        delete attributes.id;

        if (!el) {
            return null;
        }

        if (markup.overrideChildren) {
            var node = el.node;
            while (node.firstChild) {
                node.removeChild(node.lastChild);
            }

            for (i = 0; i < children.length; i++) {
                el.dpoRender(children[i]);
            }
        } else {
            for (i = 0; i < children.length; i++) {
                el.dpoUpdate(children[i]);
            }
        }

        switch (el.type) {
            case 'textPath':
                var href = el.attr('xlink:href'),
                    svg = Snap(el.node.ownerSVGElement),
                    path = svg.select(href);
                path.attr({
                    d: attributes.path
                });

                delete attributes.path;
                break;
            case 'tspan':
                el.node.textContent = replaceSpaces(attributes.text);
                delete attributes.text;
                break;
        }

        el.attr(attributes);
        DPO.render.applyStyles(el.node, markup.css);
        applyAttributes(el, markup.attributes);
        return el;
    };

    /**
     * Updates element position
     * @param {DPO.render.Markup} markup
     * @returns {*}
     */
    Element.prototype.dpoUpdatePosition = function dpoUpdateGeometry(markup) {
        var id = markup.geometry.id,
            transform = markup.geometry.transform,
            children = markup.children,
            el = this.select('#' + id);
        if (el && transform) {
            el.attr({transform: transform});
        }

        for (var i = 0; i < children.length; i++) {
            this.dpoUpdatePosition(children[i]);
        }

        return el;
    };

    /**
     * Updates element style
     * @param {DPO.render.Markup} markup
     * @returns {*}
     */
    Element.prototype.dpoUpdateStyle = function dpoUpdateStyle(markup) {
        var id = markup.geometry.id,
            attributes = DPO.mixin({}, markup.style, markup.css),
            children = markup.children,
            el = this.select('#' + id);
        if (el) {
            el.attr(attributes);
        }

        for (var i = 0; i < children.length; i++) {
            this.dpoUpdateStyle(children[i]);
        }

        return el;
    };

    /**
     * Updates element size
     * @param {DPO.render.Markup} markup
     * @returns {*}
     */
    Element.prototype.dpoUpdateSize = function dpoUpdateSize(markup) {
        var id = markup.geometry.id,
            children = markup.children,
            attributes = DPO.mixin({}, markup.geometry),
            el = this.select('#' + id),
            i;
        if (!el) {
            return null;
        }

        delete attributes.id;
        delete attributes.href;

        if (el.type === 'textPath') {
            var href = el.attr('xlink:href'),
                svg = Snap(el.node.ownerSVGElement),
                path = svg.select(href);
            path.attr({
                d: attributes.path
            });

            delete attributes.path;
        }

        if (markup.overrideChildren) {
            var node = el.node;
            while (node.firstChild) {
                node.removeChild(node.lastChild);
            }
            for (i = 0; i < children.length; i++) {
                el.dpoRender(children[i]);
            }
        } else {
            for (i = 0; i < children.length; i++) {
                this.dpoUpdateSize(children[i]);
            }
        }

        el.attr(attributes);

        return el;
    };

    /**
     * Updates element geometry
     * @param {DPO.render.Markup} markup
     * @returns {*}
     */
    Element.prototype.dpoUpdateGeometry = function dpoUpdateGeometry(markup) {
        var id = markup.geometry.id,
            el = this.select('#' + id),
            children = markup.children,
            attributes = DPO.mixin({}, markup.geometry), i;
        if (!el) {
            return null;
        }

        delete attributes.id;
        delete attributes.src;

        if (el.type === 'textPath') {
            var href = el.attr('xlink:href'),
                svg = Snap(el.node.ownerSVGElement),
                path = svg.select(href);
            path.attr({
                d: attributes.path
            });

            delete attributes.path;
        }

        for (i = 0; i < children.length; i++) {
            el.dpoUpdateGeometry(children[i]);
        }

        el.attr(attributes);

        return el;
    };

    /**
     * Creates new text SVG element
     * @param {object} attr
     * @returns {*}
     */
    Element.prototype.dpoTextPath = function tspan(attr) {
        var doc = this.node.ownerDocument,
            path = doc.createElementNS('http://www.w3.org/2000/svg', 'textPath'),
            el = Snap(path),
            svg = Snap(this.node.ownerSVGElement),
            cfg = DPO.mixin({}, attr),
            p = svg.path(cfg.path).toDefs(),
            id = p.id;

        p.attr({id: id});
        el.attr({'xlink:href': '#' + id});
        delete cfg.path;

        el.attr(cfg);
        this.append(path);
        return el;
    };

    /**
     * Creates new span SVG element
     * @param {object} attr
     * @returns {*}
     */
    Element.prototype.dpoSpan = function tspan(attr) {
        var doc = this.node.ownerDocument,
            span = doc.createElementNS('http://www.w3.org/2000/svg', 'tspan'),
            text = attr.text,
            el = Snap(span);
        delete attr.text;

        el.attr(attr);
        span.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
        span.textContent = replaceSpaces(text);
        // span.textContent = text;
        this.append(span);
        return el;
    };
});

DPO.def('render.Renderer', function () {
    /**
     * Creates a new Renderer object.
     * @class DPO.render.Renderer
     * @extends DPO.model.Introspector
     * @memberof DPO.render
     * @property {string} id
     * @property {RegExp} isField
     * @property {DPO.render.Context} context
     * @param {DPO.render.Context} context
     * @constructor
     */
    function Renderer(context) {
        var me = this;
        me.id = me.id || DPO.id();
        me.isField = new RegExp(me.id + '-field-[^-]+$');
        me.context = me.context || context;
        DPO.model.Introspector.call(me);
    }

    /**
     * Converts model color to HTML color
     * @param {string} color
     * @returns {string}
     */
    function htmlColor(color) {
        return color.replace('0x', '#');
    }

    /**
     * Converts HTML color to model color
     * @param {string} color
     * @returns {string}
     */
    function modelColor(color) {
        return color.replace('#', '0x');
    }

    /**
     * Converts model color to HTML color
     * @memberof DPO.render.Renderer
     * @function
     * @param {string} color
     * @returns {string}
     */
    Renderer.htmlColor = htmlColor;

    /**
     * Converts HTML color to model color
     * @memberof DPO.render.Renderer
     * @function
     * @param {string} color
     * @returns {string}
     */
    Renderer.modelColor = modelColor;

    DPO.inherit(Renderer, DPO.model.Introspector);
    DPO.mixin(Renderer.prototype, {
        styles: {
            page: {
                'fill': '#FFFFFF',
                'stroke': '#B8C2C9',
                'stroke-width': 1
            },
            panel: {
                'fill': 'none',
                'stroke': '#B8C2C9',
                'stroke-width': 1,
                'pointer-events': 'all'
            }
        },

        /**
         * Converts color to current color space
         * @param {string} color
         * @returns {string}
         */
        proofColor: function proofColor(color) {
            color = color.replace('0x', '#');

            var me = this,
                colorSpace = me.context ? me.context.colorSpace : null,
                c = color;
            if (!colorSpace || !colorSpace.ready) {
                return color;
            }

            colorSpace.convertColors([color], function (map) {
                c = map[color];
            });

            return c;
        },

        /**
         * Returns field identifier
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Field} f
         * @returns {string}
         */
        fieldMarkupId: function fieldMarkupId(f) {
            return this.id + '-field-' + f.id;
        },

        /**
         * Returns field by it's markup identifier
         * @param {string} markupId
         * @returns {DPO.model.Field}
         */
        getFieldByMarkupId: function getFieldByMarkupId(markupId) {
            var me = this,
                id = markupId.replace(me.id + '-field-', '');
            return me.context.selector.getField(id);
        },

        /**
         * Creates transformation matrix for specified panel
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Panel} panel
         * @param {DPO.model.Position|{x: number, y : number}} [position]
         * @returns {Snap.Matrix}
         */
        panelCanvasTransform: function panelCanvasTransform(panel, position) {
            position = position || panel.position;
            var x = position.x / 20,
                y = position.y / 20;
            return Snap.matrix().translate(x, y).rotate(-panel.rotation);
        },

        /**
         * Creates transformation matrix for specified page
         * @memberof DPO.render.Renderer#
         * @param page
         * @returns {object}
         */
        pageCanvasTransform: function pageCanvasTransform(page) {
            var rotation = page.getOrientation(),
                m = Snap.matrix().rotate(rotation),
                x1 = 0,
                y1 = 0,
                x2 = page.width / 20,
                y2 = page.height / 20,
                ne = {
                    x: m.x(x2, y1),
                    y: m.y(x2, y1)
                },
                se = {
                    x: m.x(x2, y2),
                    y: m.y(x2, y2)
                },
                sw = {
                    x: m.x(x1, y2),
                    y: m.y(x1, y2)
                },
                x = Math.min(0, ne.x, se.x, sw.x),
                y = Math.min(0, ne.y, se.y, sw.y);
            return Snap.matrix().translate(-x, -y).rotate(rotation);
        },

        /**
         * Return page canvas markup
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Page} page
         * @param {number} dx
         * @param {number} dy
         * @returns {DPO.render.Markup}
         */
        pageCanvasMarkup: function pageCanvasMarkup(page, dx, dy) {
            var me = this;
            return new DPO.render.Markup({
                type: 'g',
                geometry: {
                    id: me.id + '-canvas-page-' + me.context.project.pages.indexOf(page),
                    transform: me.pageCanvasTransform(page).translate(dx, dy)
                }
            });
        },

        /**
         * Converts rectangle to path
         * @memberof DPO.render.Renderer#
         * @private
         * @param {object} g
         * @param {number} dx
         * @param {number} dy
         * @returns {object}
         */
        rectToPath: function rectToPath(g, dx, dy) {
            function p(x, y) {
                return x + ' ' + y + ' ';
            }

            function roundedRectangle(x, y, w, h, r1, r2, r3, r4) {
                var path = 'M' + p(x + r1, y); //A
                path += 'L' + p(x + w - r2, y) + 'Q' + p(x + w, y) + p(x + w, y + r2); //B
                path += 'L' + p(x + w, y + h - r3) + 'Q' + p(x + w, y + h) + p(x + w - r3, y + h); //C
                path += 'L' + p(x + r4, y + h) + 'Q' + p(x, y + h) + p(x, y + h - r4); //D
                path += 'L' + p(x, y + r1) + 'Q' + p(x, y) + p(x + r1, y); //A
                path += 'Z';
                return path;
            }

            function rectangle(x, y, w, h) {
                var path = 'M' + p(x, y);
                path += 'L' + p(x + w, y);
                path += 'L' + p(x + w, y + h);
                path += 'L' + p(x, y + h);
                path += 'Z';
                return path;
            }

            var fn = g.rx || g.ry ? roundedRectangle : rectangle,
                res = {
                    d: fn(g.x + dx, g.y + dy, g.width, g.height, g.rx || 0, g.ry || 0, g.rx || 0, g.ry || 0)
                };

            if (g.id) {
                res.id = g.id;
            }

            return res;
        },

        /**
         * Converts ellipse to path
         * @memberof DPO.render.Renderer#
         * @private
         * @param {object} g
         * @param {number} dx
         * @param {number} dy
         * @returns {object}
         */
        ellipseToPath: function ellipseToPath(g, dx, dy) {
            var cx = g.cx + dx,
                cy = g.cy + dy,
                path = 'M' + (cx - g.rx) + ',' + cy;
            path += 'a' + g.rx + ',' + g.ry + ' 0 1,1 ' + (2 * g.rx) + ',0';
            path += 'a' + g.rx + ',' + g.ry + ' 0 1,1 ' + (-2 * g.rx) + ',0';

            var res = {
                d: path
            };

            if (g.id) {
                res.id = g.id;
            }
            return res;
        },

        /**
         * Converts markup's geometry to path
         * @memberof DPO.render.Renderer#
         * @param {DPO.render.Markup} shape
         * @param {number} [dx]
         * @param {number} [dy]
         * @returns {DPO.render.Markup}
         */
        toPath: function toPath(shape, dx, dy) {
            var geometry = shape.geometry,
                matrix;
            dx = dx || 0;
            dy = dy || 0;

            switch (shape.type) {
                case 'rect':
                    geometry = this.rectToPath(geometry, dx, dy);
                    break;
                case 'ellipse':
                    geometry = this.ellipseToPath(geometry, dx, dy);
                    break;
                case 'path':
                    matrix = Snap.matrix().translate(dx, dy);
                    geometry.d = Snap.path.map(geometry.d, matrix) + 'Z';
                    break;
            }

            return new DPO.render.Markup({
                type: 'path',
                geometry: geometry,
                attributes: shape.attributes,
                style: shape.style,
                children: shape.children
            });
        },

        /**
         * Returns shape markup without x,y translation
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Panel|DPO.model.MasterPanel|DPO.model.Cutout} obj
         * @returns {DPO.render.Markup}
         */
        shapeMarkup: function shapeMarkup(obj) {
            var style = DPO.mixin({}, this.styles.panel),
                type, geometry;
            if (obj instanceof DPO.model.Panel) {
                obj = this.context.selector.selectMasterPanel(/** @type DPO.model.Panel */obj);
            }

            switch (obj.shape) {
                case 'rect':
                    type = 'rect';
                    geometry = {
                        x: 0,
                        y: 0,
                        width: obj.width / 20,
                        height: obj.height / 20,
                        rx: obj.cornerRadius / 20,
                        ry: obj.cornerRadius / 20
                    };
                    break;
                case 'ellipse':
                    type = 'ellipse';
                    geometry = {
                        cx: obj.width / 40,
                        cy: obj.height / 40,
                        rx: obj.width / 40,
                        ry: obj.height / 40
                    };
                    break;
                case 'polygon':
                    type = 'path';
                    geometry = {
                        d: obj.polypoints.makePath(true)
                    };
                    break;
            }

            return new DPO.render.Markup({
                type: type,
                geometry: geometry,
                style: style
            });
        },

        /**
         * Returns page markup
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Page} page
         * @returns {DPO.render.Markup}
         */
        pageMarkup: function pageMarkup(page) {
            return new DPO.render.Markup({
                type: 'rect',
                geometry: {
                    x: 0,
                    y: 0,
                    'stroke-linejoin': 'miter',
                    id: this.id + '-page-' + this.context.project.pages.indexOf(page),
                    width: page.width / 20,
                    height: page.height / 20
                },
                style: DPO.mixin({}, this.styles.page)
            });
        },

        /**
         * Wraps field markup
         * @param {DPO.model.Field} field
         * @param {string} id
         * @param {object|object[]} markup
         * @returns {DPO.render.Markup}
         */
        wrapFieldMarkup: function wrapFieldMarkup(field, id, markup) {
            var p = field.position,
                r = field.rotation,
                m = Snap.matrix(1, 0, 0, 1, p.x / 20, p.y / 20).rotate(360 - r, 0, 0);
            //m.translate(p.x / 20, p.y / 20);
            return new DPO.render.Markup({
                type: 'g',
                geometry: {
                    id: id,
                    transform: m
                },
                children: markup instanceof Array ? markup : [markup]
            });
        },

        /**
         * Returns drawing markup
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Drawing} drawing
         * @param {string} id
         * @returns {DPO.render.Markup}
         */
        drawingMarkup: function drawingMarkup(drawing, id) {
            var me = this,
                outline = drawing.outline,
                style = {
                    'fill': me.proofColor(drawing.color),
                    'stroke': me.proofColor(drawing.outline.color),
                    'stroke-width': drawing.outline.width / 20,
                    'stroke-linejoin': 'round'
                }, type, geometry;

            if (drawing.opacity === 0) {
                style.opacity = 1;
                style['fill-opacity'] = 0;
                style['stroke-opacity'] = outline.opacity;
            } else {
                style.opacity = drawing.opacity;
                style['fill-opacity'] = 1;
                style['stroke-opacity'] = 1;
            }

            switch (drawing.shape) {
                case 'rect':
                    type = 'rect';
                    geometry = {
                        x: 0,
                        y: 0,
                        width: drawing.width / 20,
                        height: drawing.height / 20
                    };
                    break;
                case 'ellipse':
                    type = 'ellipse';
                    geometry = {
                        cx: drawing.width / 40,
                        cy: drawing.height / 40,
                        rx: drawing.width / 40,
                        ry: drawing.height / 40
                    };
                    break;
                case 'polygon':
                    type = 'path';
                    geometry = {
                        d: drawing.polypoints.makePath(true)
                    };
                    break;
            }

            geometry.id = id + '-shape';
            return this.wrapFieldMarkup(drawing, id, {
                type: type,
                geometry: geometry,
                style: style,
                attributes: style
            });
        },

        /**
         * Creates markup for text line
         * @param {DPO.text.Line} line
         * @param {DPO.text.Container} container
         * @returns {DPO.render.Markup[]}
         */
        lineMarkup: function lineMarkup(line, container) {
            var me = this,
                md = DPO.text.DefaultMetrics,
                spans = [], span;
            for (var i = 0; i < line.spans.length; i++) {
                span = line.spans[i];
                spans.push({
                    type: 'dpoSpan',
                    geometry: {
                        text: span.value
                    },
                    style: {
                        'font-family': md.getCSSFontFamily(span.fontFamily),
                        'font-style': span.fontStyle,
                        'font-weight': span.fontWeight,
                        'text-decoration': span.textDecoration,
                        'fill': me.proofColor(span.color)
                    },
                    attributes: {
                        'font-size': span.fontSize
                    }
                });
            }

            span = spans[0];
            span.geometry.x = line.offsetX;
            span.geometry.y = container.offset + line.offsetY;

            // Small workaround for empty paragraph rendering
            if (spans.length === 1 && !spans[0].geometry.text) {
                spans[0].attributes.fill = 'transparent';
                spans[0].geometry.text = '\u00A0';
            }

            return spans;
        },
        /**
         * Created text container markup
         * @param {DPO.text.Container} container
         * @param {number} opacity
         * @param {string} id
         * @returns {DPO.render.Markup}
         */
        containerMarkup: function containerMarkup(container, opacity, id) {
            var lineMarkups = [], markup;
            for (var j = 0; j < container.lines.length; j++) {
                var line = container.lines[j];
                markup = this.lineMarkup(line, container);
                lineMarkups = lineMarkups.concat(markup);
            }

            return new DPO.render.Markup({
                type: 'text',
                geometry: {
                    id: id
                },
                css: {
                    'font-kerning': 'normal',
                    'fill-opacity': opacity
                },
                attributes: {
                    kerning: 'auto'
                },
                children: lineMarkups
            });
        },

        /**
         * Creates markup for text block
         * @param {DPO.model.TextBlock} textBlock
         * @param {string} id
         * @param {boolean} [expanded]
         * @returns {DPO.render.Markup}
         */
        textBlockMarkup: function textBlockMarkup(textBlock, id, expanded) {
            var me = this,
                containers = me.context.layoutManager.layoutTextBlock(textBlock, expanded),
                array = [];
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                array.push(me.containerMarkup(container, textBlock.opacity, id + '-p' + i));
            }

            var markup = me.wrapFieldMarkup(textBlock, id, array);
            markup.overrideChildren = true;
            return markup;
        },

        pathForCircularText: function pathForCircularText(textPath, repeatCount) {
            var rx = textPath.width / 40,
                ry = textPath.height / 40,
                arcFlags = textPath.rotateSense === 'cw' ? ' 0 0 1' : ' 0 1 0',
                path = 'M ' + rx + ',0';
            for (var i = 0; i < repeatCount; i++) {
                path += ' A' + rx + ',' + ry + arcFlags;
                path += ' ' + rx + ',' + ry * 2;

                path += ' A' + rx + ',' + ry + arcFlags;
                path += ' ' + rx + ',0';
            }
            return path;
        },

        /**
         * Creates markup for TextPath field
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.TextPath} textPath
         * @param {string} id
         * @returns {DPO.render.Markup}
         */
        textPathMarkup: function textPathMarkup(textPath, id) {
            var me = this,
                angle = (360 + textPath.textAngle) % 360,
                containers = me.context.layoutManager.layoutTextBlock(textPath),
                container = containers[0],
                markup = me.containerMarkup(container, textPath.opacity, id + '-p0'),
                spanMarkup = markup.children[0],
                dy = 0;
            delete spanMarkup.geometry.x;
            delete spanMarkup.geometry.y;

            if (textPath.rotateSense === 'cw') {
                angle += 90;
            } else {
                dy = container.lines[0].capHeight;
                angle = 360 - angle - 90;
            }

            angle = angle > 180 ? -(angle % 180) : angle;

            var svgPath = me.pathForCircularText(textPath, 3),
                totalLength = Snap.path.getTotalLength(svgPath),
                length = totalLength / 3;
            return me.wrapFieldMarkup(textPath, id, {
                type: 'text',
                geometry: {
                    id: id + '-p0',
                    dy: dy
                },
                css: markup.css,
                children: [{
                    type: 'dpoTextPath',
                    geometry: {
                        id: id + '-text-path',
                        path: svgPath,
                        textAnchor: 'start',
                        startOffset: length * (1 + angle / 360) - container.lines[0].width / 2
                    },
                    overrideChildren: true,
                    children: markup.children
                }]
            });
        },

        /**
         * Creates markup for background field
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Background} background
         * @param {string} id
         * @returns {DPO.render.Markup}
         */
        backgroundMarkup: function backgroundMarkup(background, id) {
            // Workaround for IE
            // IE disables pointer event for image elements
            // So lets create transparent rect to make field selectable
            var me = this,
                rect = {
                    type: 'rect',
                    geometry: {
                        id: id + '-drag-rect',
                        x: 0,
                        y: 0,
                        width: background.width / 20,
                        height: background.height / 20
                    },
                    style: {
                        fill: background.source ? 'white' : me.proofColor(background.color),
                        fillOpacity: background.source ? 0.0001 : 1,
                        stroke: 'none'
                    }
                },
                children = [rect];
            if (background.source) {
                var storage = this.context.storage,
                    url = storage.urlForField(background),
                    aspect = url === storage.loadingImgURL ? 'xMidYMid meet' : 'none';

                children.push({
                    type: 'image',
                    geometry: {
                        id: id + '-image',
                        x: 0,
                        y: 0,
                        width: background.width / 20,
                        height: background.height / 20,
                        href: url
                    },
                    style: {
                        'preserveAspectRatio': aspect,
                        'stroke': 'none',
                        'fill': 'none',
                        'opacity': background.opacity
                    }
                }, me.imageIndicatorConfig(background, id));
            }

            return this.wrapFieldMarkup(background, id, children);
        },

        /**
         * Creates markup for image
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Image} image
         * @param {string} id
         * @returns {DPO.render.Markup}
         */
        imageMarkup: function imageMarkup(image, id) {
            // Workaround for IE
            // IE disables pointer event for image elements
            // So lets create transparent rect to make field selectable
            var rect = {
                type: 'rect',
                geometry: {
                    id: id + '-drag-rect',
                    x: 0,
                    y: 0,
                    width: image.width / 20,
                    height: image.height / 20
                },
                style: {
                    fill: 'white',
                    fillOpacity: 0.0001,
                    stroke: 'none'
                }
            };

            var storage = this.context.storage,
                url = storage.urlForField(image),
                aspect = image.stretch ? 'none' : 'xMidYMid';
            if (url === storage.loadingImgURL) {
                aspect = 'xMidYMid meet';
            }

            return this.wrapFieldMarkup(image, id, [rect, {
                type: 'image',
                geometry: {
                    id: id + '-image',
                    x: 0,
                    y: 0,
                    width: image.width / 20,
                    height: image.height / 20,
                    href: url
                },
                style: {
                    'preserveAspectRatio': aspect,
                    'stroke': 'none',
                    'fill': 'none',
                    'opacity': image.opacity
                }
            }, this.imageIndicatorConfig(image, id)]);
        },

        /**
         * Return image indicator config
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Image|DPO.model.Background} element
         * @param {string} id
         * @returns {object}
         */
        imageIndicatorConfig: function imageIndicatorConfig(element, id) {
            var metrics = DPO.text.DefaultMetrics,
                maxFontMetrics = metrics.getMetrics('Arial', false, false),
                matrix = Snap.matrix().rotate(360 - element.rotation, element.width / 40, element.height / 40).invert(),
                min = Math.min(element.width, element.height),
                max = Math.max(element.width, element.height),
                fontSize = max / 150;

            if (min / max < 0.2) {
                fontSize = min / 40;
            }

            return {
                type: 'text',
                geometry: {
                    id: id + '-indicator-wrapper',
                    x: element.width / 40,
                    y: element.height / 40,
                    transform: matrix
                },
                style: {
                    textAnchor: 'middle',
                    display: 'none'
                },
                overrideChildren: true,
                children: [{
                    type: 'dpoSpan',
                    geometry: {
                        id: id + '-indicator',
                        text: ''
                    },
                    style: {
                        'dy': metrics.getCapHeight(maxFontMetrics, fontSize) / 2,
                        'font-size': fontSize,
                        'font-family': 'Arial',
                        'fill': '#ddd'
                    }
                }]
            };
        },

        /**
         * Creates markup for barcode field
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Barcode} barcode
         * @param {string} id
         * @returns {DPO.render.Markup}
         */
        barcodeMarkup: function barcodeMarkup(barcode, id) {
            // Workaround for IE
            // IE disables pointer event for image elements
            // So lets create transparent rect to make field selectable
            var rect = {
                type: 'rect',
                geometry: {
                    id: id + '-drag-rect',
                    x: 0,
                    y: 0,
                    width: barcode.width / 20,
                    height: barcode.height / 20
                },
                style: {
                    fill: 'white',
                    fillOpacity: 0.0001,
                    stroke: 'none'
                }
            };

            var url = this.context.storage.urlForField(barcode),
                children = [rect];
            if (url) {
                children.push({
                    type: 'image',
                    geometry: {
                        id: id + '-barcode',
                        x: 0,
                        y: 0,
                        width: barcode.width / 20,
                        height: barcode.height / 20,
                        href: url
                    },
                    style: {
                        'preserveAspectRatio': 'none',
                        'stroke': 'none',
                        'fill': 'none'
                    }
                });
            }
            return this.wrapFieldMarkup(barcode, id, children);
        },

        /**
         * Returns field markup
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Field} field
         * @param {?string} [id]
         * @param {number} [index]
         * @param {boolean} [omitDataBinding]
         * @param {boolean} [expanded]
         * @returns {DPO.render.Markup}
         */
        fieldMarkup: function fieldMarkup(field, id, index, omitDataBinding, expanded) {
            var me = this;
            id = id || me.fieldMarkupId(field);
            index = index || 0;
            field = omitDataBinding ? field : me.context.binder.bindDataToField(field, index);

            switch (field.constructor) {
                case DPO.model.Drawing:
                    return me.drawingMarkup(/** @type DPO.model.Drawing*/field, id);
                case DPO.model.TextPath:
                    return me.textPathMarkup(/** @type DPO.model.TextPath*/field, id);
                case DPO.model.TextBlock:
                    return me.textBlockMarkup(/** @type DPO.model.TextBlock*/field, id, expanded);
                case DPO.model.Background:
                    return me.backgroundMarkup(/** @type DPO.model.Background*/field, id);
                case DPO.model.Image:
                    return me.imageMarkup(/** @type DPO.model.Image*/field, id);
                case DPO.model.Barcode:
                    return me.barcodeMarkup(/** @type DPO.model.Barcode*/field, id);
            }

            return me.wrapFieldMarkup(field, id, {
                type: 'rect',
                geometry: {
                    id: id + '-rect',
                    x: 0,
                    y: 0,
                    width: field.width / 20,
                    height: field.height / 20
                },
                style: {
                    'stroke': '#FF0000',
                    'fill': 'none',
                    'stroke-dasharray': '3,2'
                }
            });
        },

        /**
         * Returns fields bounds markup
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Field} field
         * @param {object} [outerStyle]
         * @param {object} [innerStyle]
         * @returns {DPO.render.Markup}
         */
        boundsMarkup: function boundsMarkup(field, outerStyle, innerStyle) {
            var me = this,
                id = me.id + '-bounds-' + field.id,
                pos = field.position,
                m = Snap.matrix().rotate(360 - field.rotation, pos.x / 20, pos.y / 20).translate(pos.x / 20, pos.y / 20),
                bounds = this.context.selector.getBounds(field, true, true);
            outerStyle = DPO.mixin({
                'stroke': '#aaa',
                'fill': 'none'
            }, outerStyle);
            innerStyle = DPO.mixin({
                'stroke': '#aaa',
                'fill': 'none'
            }, innerStyle);

            if (field instanceof DPO.model.TextPath) {
                var rect = {
                        type: 'rect',
                        geometry: {
                            id: id + '-rect',
                            x: (field.width - bounds.width) / 40,
                            y: (field.height - bounds.height) / 40,
                            width: bounds.width / 20,
                            height: bounds.height / 20
                        },
                        style: outerStyle
                    },
                    ellipse = {
                        type: 'ellipse',
                        geometry: {
                            id: id + '-ellipse',
                            cx: field.width / 40,
                            cy: field.height / 40,
                            rx: field.width / 40,
                            ry: field.height / 40

                        },
                        style: innerStyle
                    };

                return new DPO.render.Markup({
                    geometry: {
                        id: id,
                        transform: m
                    },
                    overrideChildren: true,
                    children: [rect, ellipse]
                });
            }
            return new DPO.render.Markup({
                type: 'rect',
                geometry: {
                    id: id,
                    transform: m,
                    x: (field.width - bounds.width) / 40,
                    y: (field.height - bounds.height) / 40,
                    width: bounds.width / 20,
                    height: bounds.height / 20
                },
                style: outerStyle
            });
        },

        itemNumberMarkup: function itemNumberMarkup(page, panel) {
            function pad(num, size) {
                var s = '0' + num;
                return s.substr(s.length - size);
            }

            var selector = this.context.selector,
                index = selector.panelIndex(panel),
                mp = selector.selectMasterPanel(panel),
                min = Math.min(mp.width, mp.height),
                max = Math.max(mp.width, mp.height),
                r = max / 200,
                aspect = min / max;
            if (aspect < 0.2) {
                r = min / 40;
            }

            var metrics = DPO.text.DefaultMetrics,
                maxFontMetrics = metrics.getMetrics('Arial', false, false),
                fontSize = r,
                id = this.id + '-item-number-' + index;
            return new DPO.render.Markup({
                geometry: {
                    id: id
                },
                attributes: {
                    'pointer-events': 'none'
                },
                children: [{
                    type: 'circle',
                    geometry: {
                        id: id + '-circle',
                        cx: mp.width / 40,
                        cy: mp.height / 40,
                        r: r
                    },
                    style: {
                        opacity: 0.2,
                        stroke: 'none',
                        fill: '#1a4c6e'
                    }
                }, {
                    type: 'text',
                    geometry: {
                        id: id + '-text',
                        x: mp.width / 40,
                        y: mp.height / 40
                    },
                    style: {
                        opacity: 0.8,
                        textAnchor: 'middle'
                    },
                    overrideChildren: true,
                    children: [{
                        type: 'dpoSpan',
                        geometry: {
                            id: id + '-span',
                            text: pad(index + 1, 2)
                        },
                        style: {
                            'dy': metrics.getCapHeight(maxFontMetrics, fontSize) / 2,
                            'font-size': fontSize,
                            'font-family': 'Arial',
                            'fill': 'white'
                        }
                    }]
                }]
            });
        },

        /**
         * Calculates preferred text block height
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.TextBlock} textBlock
         * @returns {number}
         */
        preferredTextBlockHeight: function preferredTextBlockHeight(textBlock) {
            if (textBlock instanceof DPO.model.TextPath) {
                return textBlock.height;
            }

            var containers = this.context.layoutManager.layoutTextBlock(textBlock),
                height = 0;

            for (var i = 0; i < containers.length; i++) {
                var c = containers[i];
                height += c.height;
            }

            return height * 20;
        },

        getIntersections: function getIntersections(path, x1, x2) {
            path = Snap.path.toCubic(path);

            var line1 = DPO.math.Line.fromPoints({x: x1, y: 0}, {x: x1, y: 1}),
                line2 = DPO.math.Line.fromPoints({x: x2, y: 0}, {x: x2, y: 1}),
                segment = 0,
                total = 0,
                x = 0, y = 0,
                intersections = [],
                bezier,
                ts, t;
            for (var i = 0; i < path.length; i++) {
                var p = path[i];
                if (p[0] === 'M') {
                    x = +p[1];
                    y = +p[2];
                } else {
                    bezier = new DPO.math.CubicBezier(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    ts = [];
                    ts = ts.concat(bezier.intersectionsWithLine(line1));
                    ts = ts.concat(bezier.intersectionsWithLine(line2));

                    for (var j = 0; j < ts.length; j++) {
                        t = ts[j];
                        intersections.push({
                            bezier: bezier,
                            segment: segment,
                            t: t,
                            length: total + bezier.getLength(t),
                            point: bezier.compute(t)
                        });
                    }

                    total += bezier.getLength();
                    x = p[5];
                    y = p[6];
                    segment++;
                }
            }

            return {
                totalLength: total,
                intersections: intersections
            };
        },

        getClosestIntersection: function getClosestIntersection(intersections, p) {
            var closest = intersections[0],
                pt = closest.point,
                distance = Math.pow(p.x - pt.x, 2) + Math.pow(p.y - pt.y, 2);
            for (var i = 1; i < intersections.length; i++) {
                var pos = intersections[i],
                    d = Math.pow(p.x - pos.point.x, 2) + Math.pow(p.y - pos.point.y, 2);
                if (distance > d) {
                    distance = d;
                    closest = pos;
                }
            }

            return closest;
        },

        getPanelPath: function getPanelPath(panel, inflation) {
            var me = this,
                shape = me.toPath(me.shapeMarkup(panel)),
                trimPath = shape.geometry.d,
                box = Snap.path.getBBox(trimPath),
                scaleX = (box.width + inflation) / box.width,
                scaleY = (box.height + inflation) / box.height,
                matrix = Snap.matrix().scale(scaleX, scaleY, box.cx, box.cy);
            return Snap.path.map(trimPath, matrix);
        },

        calculateBleedSafeLabelMetric: function calculateBleedSafeLabelMetric(panel, labels, zoom) {
            var me = this,
                ctx = me.context,
                lm = ctx.layoutManager,
                mp = ctx.selector.selectMasterPanel(panel),
                mpw = mp.width / 20,
                labelWidth = mpw / 3,
                i, containers, container, line;


            var style = {
                    color: '#000000',
                    fontSize: 72,
                    fontFamily: 'Arial',
                    fontStyle: 'normal',
                    fontWeight: 'normal',
                    textDecoration: 'none'
                },
                preferredHeight = 22 / zoom,
                textHeight = 0;

            for (i = 0; i < labels.length; i++) {
                containers = lm.layoutPlainText(DPO.text.ShrinkLayout, labels[i], Infinity, preferredHeight, style);
                container = containers[0];
                line = container.lines[0];
                textHeight = Math.max(textHeight, line.height);
            }

            var preferredWidth = preferredHeight / 0.18;
            if (preferredWidth > 0.85 * mpw) {
                labelWidth = mpw * 0.85;
            } else {
                labelWidth = preferredWidth;
            }

            var labelX = (mpw - labelWidth) / 2,
                labelHeight = labelWidth * 0.18,
                textWidth = labelWidth * 0.7;


            for (i = 0; i < labels.length; i++) {
                containers = lm.layoutPlainText(DPO.text.FitLayout, labels[i], textWidth, labelHeight, null, 'center', 'middle');
                line = containers[0].lines[0];
                style.fontSize = Math.min(style.fontSize, line.spans[0].fontSize);
            }

            return {
                preferredHeight: preferredHeight,
                preferredWidth: preferredWidth,
                style: style,
                radius: labelHeight * 0.4,
                circleOffset: labelHeight * 0.39,
                circleRadius: labelHeight * 0.3,
                textWidth: textWidth,
                labelLeft: labelX,
                labelRight: labelX + labelWidth,
                labelWidth: labelWidth,
                labelHeight: Math.max(labelHeight * 0.75, style.fontSize * 1.3)
            };
        },

        extractSubPath: function extractSubPath(path, start, end, totalLength) {
            path = Snap.path.toCubic(path);

            var clockwise = start.segment + start.t < end.segment + end.t,
                monolithPath = Math.abs(start.length - end.length) < totalLength / 2,
                sp = '', p1, p2;
            if (clockwise && monolithPath) {
                sp = Snap.path.getSubpath(path, start.length, end.length);
            }

            if (!clockwise && monolithPath) {
                sp = Snap.path.getSubpath(path, end.length, start.length);
            }

            if (clockwise && !monolithPath) {
                p1 = Snap.path.getSubpath(path, 0, start.length);
                p2 = Snap.path.getSubpath(path, end.length, totalLength);
                p1 = Snap.path.toCubic(p1);
                p1[0][0] = 'L';
                sp = p2 + p1.toString();
            }

            if (!clockwise && !monolithPath) {
                p1 = Snap.path.getSubpath(path, start.length, totalLength);
                p2 = Snap.path.getSubpath(path, 0, end.length);
                p2 = Snap.path.toCubic(p2);
                p2[0][0] = 'L';
                sp = p1.toString() + p2.toString();
            }
            return sp;
        },

        /**
         * Created markup for bleed label
         * @memberof DPO.render.Renderer#
         * @param {DPO.model.Panel} panel
         * @param {string} text
         * @param {object} metrics
         * @param {string} [id]
         * @returns {DPO.render.Markup}
         */
        bleedLabelMarkup: function bleedLabelMarkup(panel, text, metrics, id) {
            function p(x, y) {
                return x + ' ' + y + ' ';
            }

            function bleedLabelBorderCW(x, y, w, r, sy, ey) {
                var path = p(x, sy);
                path += 'L' + p(x, y + r) + 'Q' + p(x, y) + p(x + r, y); //A
                path += 'L' + p(x + w - r, y) + 'Q' + p(x + w, y) + p(x + w, y + r); //B
                path += 'L' + p(x + w, ey);
                return path;
            }

            function bleedLabelBorderCCW(x, y, w, r, sy, ey) {
                var path = p(x + w, ey);
                path += 'L' + p(x + w, y + r) + 'Q' + p(x + w, y) + p(x + w - r, y); //B
                path += 'L' + p(x + r, y) + 'Q' + p(x, y) + p(x, y + r); //A
                path += 'L' + p(x, sy);
                return path;
            }

            var me = this,
                bleedPath = me.getPanelPath(panel, me.context.project.bleedOffset / 10),
                labelOffsetY = -metrics.labelHeight,
                result = me.getIntersections(bleedPath, metrics.labelLeft, metrics.labelRight),
                start = me.getClosestIntersection(result.intersections, {x: metrics.labelLeft, y: 0}),
                end = me.getClosestIntersection(result.intersections, {x: metrics.labelRight, y: 0});
            id = id || me.id + '-bleed-label';

            function getLabelBorderPath(start, end, totalLength) {
                var r = metrics.radius,
                    lw = metrics.labelWidth,
                    lx = metrics.labelLeft,
                    clockwise = start.segment + start.t < end.segment + end.t,
                    monolithPath = Math.abs(start.length - end.length) < totalLength / 2,
                    svgPath = '';

                if (clockwise && monolithPath) {
                    svgPath = bleedLabelBorderCCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }

                if (!clockwise && monolithPath) {
                    svgPath = bleedLabelBorderCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }

                if (clockwise && !monolithPath) {
                    svgPath = bleedLabelBorderCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }

                if (!clockwise && !monolithPath) {
                    svgPath = bleedLabelBorderCCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }
                return 'L' + svgPath;
            }

            var sp = me.extractSubPath(bleedPath, start, end, result.totalLength),
                spBox = Snap.path.getBBox(sp);
            labelOffsetY += spBox.y;

            var svgPath = sp + getLabelBorderPath(start, end, result.totalLength),
                textX, containers, textMarkup, line;
            containers = me.context.layoutManager.layoutPlainText(
                DPO.text.ShrinkLayout,
                text,
                metrics.textWidth,
                metrics.labelHeight,
                metrics.style);

            line = containers[0].lines[0];
            textX = metrics.labelLeft + (metrics.labelWidth - line.width) / 2;
            textMarkup = me.containerMarkup(containers[0], 1, id + '-text');
            textMarkup.geometry.transform = Snap.matrix().translate(textX, spBox.y - line.height);
            var warning = {
                geometry: {
                    id: id + '-warning'
                },
                style: {
                    'pointer-events': 'all',
                    cursor: 'pointer'
                },
                children: [{
                    type: 'circle',
                    geometry: {
                        cx: metrics.labelRight - metrics.circleOffset,
                        cy: labelOffsetY + metrics.circleOffset,
                        r: metrics.circleRadius
                    },
                    style: {
                        'pointer-events': 'all',
                        fill: '#FF0008',
                        stroke: 'none'
                    }
                }, {
                    type: 'text',
                    geometry: {
                        id: id + '-qm',
                        x: metrics.labelRight - metrics.circleOffset * 1.3,
                        y: labelOffsetY + metrics.circleOffset * 1.4,
                        text: '?'
                    },
                    style: {
                        fill: '#FFFFFF'
                    },
                    attributes: {
                        'font-size': metrics.circleRadius * 1.5
                    }
                }]
            };
            return new DPO.render.Markup({
                geometry: {
                    id: id
                },
                children: [{
                    type: 'path',
                    geometry: {
                        id: id + '-path',
                        d: svgPath
                    },
                    style: {
                        'stroke': '#AAAAAA',
                        'fill': '#FFFFFF',
                        'fill-opacity': 0.8
                    }
                }, textMarkup, warning]
            });
        },

        safeLabelMarkup: function safeLabelMarkup(panel, text, metrics, id) {
            function p(x, y) {
                return x + ' ' + y + ' ';
            }

            function safeLabelBorderCW(x, y, w, r, sy, ey) {
                var path = p(x, sy) + 'L' + p(x, y - r) + 'Q' + p(x, y) + p(x + r, y);
                path += 'L' + p(x + w - r, y);
                path += 'Q' + p(x + w, y) + p(x + w, y - r);
                path += 'L' + p(x + w, ey);
                return path;
            }

            function safeLabelBorderCCW(x, y, w, r, sy, ey) {
                var path = p(x + w, ey) + 'L' + p(x + w, y - r);
                path += 'Q' + p(x + w, y) + p(x + w - r, y);
                path += 'L' + p(x + r, y);
                path += 'Q' + p(x, y) + p(x, y - r);
                path += 'L' + p(x, sy);
                return path;
            }

            var me = this,
                mp = me.context.selector.selectMasterPanel(panel),
                side = Math.min(mp.width, mp.height),
                fc = me.context.flowConfig,
                offset = me.context.project.safeOffset / 10;
            if (fc && side <= fc.productGeometryCharacteristic.panelSafelineRenderLimit) {
                offset = 0;
            }

            var safePath = me.getPanelPath(panel, offset),
                labelOffsetY = metrics.labelHeight,
                result = me.getIntersections(safePath, metrics.labelLeft, metrics.labelRight),
                start = me.getClosestIntersection(result.intersections, {x: metrics.labelLeft, y: 0}),
                end = me.getClosestIntersection(result.intersections, {x: metrics.labelRight, y: 0});
            id = id || me.id + '-safe-label';

            function getLabelBorderPath(start, end, totalLength) {
                var r = metrics.radius,
                    lw = metrics.labelWidth,
                    lx = metrics.labelLeft,
                    clockwise = start.segment + start.t < end.segment + end.t,
                    monolithPath = Math.abs(start.length - end.length) < totalLength / 2,
                    svgPath = '';

                if (clockwise && monolithPath) {
                    svgPath = safeLabelBorderCCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }

                if (!clockwise && monolithPath) {
                    svgPath = safeLabelBorderCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }

                if (clockwise && !monolithPath) {
                    svgPath = safeLabelBorderCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }

                if (!clockwise && !monolithPath) {
                    svgPath = safeLabelBorderCCW(lx, labelOffsetY, lw, r, start.point.y, end.point.y);
                }
                return 'L' + svgPath;
            }

            var sp = me.extractSubPath(safePath, start, end, result.totalLength),
                spBox = Snap.path.getBBox(sp);
            labelOffsetY += spBox.y2;

            var svgPath = sp + getLabelBorderPath(start, end, result.totalLength),
                textX, containers, textMarkup, line;
            containers = me.context.layoutManager.layoutPlainText(
                DPO.text.ShrinkLayout,
                text,
                metrics.textWidth,
                metrics.labelHeight,
                metrics.style);

            line = containers[0].lines[0];
            textX = metrics.labelLeft + (metrics.labelWidth - line.width) / 2;
            textMarkup = me.containerMarkup(containers[0], 1, id + '-text');
            textMarkup.geometry.transform = Snap.matrix().translate(textX, labelOffsetY - line.height + line.descender / 2);
            var warning = {
                geometry: {
                    id: id + '-warning'
                },
                style: {
                    'pointer-events': 'all',
                    cursor: 'pointer'
                },
                children: [{
                    type: 'circle',
                    geometry: {
                        cx: metrics.labelRight - metrics.circleOffset,
                        cy: labelOffsetY - metrics.circleOffset,
                        r: metrics.circleRadius
                    },
                    style: {
                        fill: '#FF0008',
                        stroke: 'none'
                    }
                }, {
                    type: 'text',
                    geometry: {
                        id: id + '-qm',
                        x: metrics.labelRight - metrics.circleOffset * 1.3,
                        y: labelOffsetY - metrics.circleOffset * 0.55,
                        text: '?'
                    },
                    style: {
                        fill: '#FFFFFF'
                    },
                    attributes: {
                        'font-size': metrics.circleRadius * 1.5
                    }
                }]
            };

            return new DPO.render.Markup({
                geometry: {
                    id: id
                },
                children: [{
                    type: 'path',
                    geometry: {
                        id: id + '-path',
                        d: svgPath
                    },
                    style: {
                        'stroke': '#AAAAAA',
                        'fill': '#FFFFFF',
                        'fill-opacity': 0.8
                    }
                }, textMarkup, warning]
            });
        }
    });

    return Renderer;
});

DPO.def('render.BaseTransformTool', function () {
    /**
     * @class DPO.render.BaseTransformTool
     * @extends DPO.mixins.Observable
     * @property {DPO.model.Field[]} selectedFields
     * @fires selected
     * @fires changed:fields
     * @constructor
     */
    function BaseTransformTool() {
        var me = this;
        me.selectedFields = [];
        me.lockedFields = [];
        me.panEnabled = false;
        me.transforming = 0;
        me.resetObservable();
    }

    DPO.mixin(BaseTransformTool.prototype, DPO.mixins.Observable);
    DPO.mixin(BaseTransformTool.prototype, {
        /**
         * Returns array of locked fields
         * @memberof DPO.render.BaseTransformTool#
         * @returns {DPO.model.Field[]}
         */
        getLockedFields: function lockedFields() {
            return [].concat(this.lockedFields);
        },

        /**
         * Lock fields (disable selection & editing)
         * @memberof DPO.render.BaseTransformTool#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         */
        lockFields: function lockFields(fields) {
            fields = fields instanceof Array ? fields : [fields];

            var array = this.lockedFields;
            for (var i = 0; i < fields.length; i++) {
                var index = array.indexOf(fields[i]);
                if (index === -1) {
                    array.push(fields[i]);
                }
            }

            this.deselectFields(array);
        },

        /**
         * Unlock fields (enable selection & editing)
         * @memberof DPO.render.BaseTransformTool#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         */
        unlockFields: function unlockFields(fields) {
            fields = fields instanceof Array ? fields : [fields];

            var array = this.lockedFields;
            for (var i = 0; i < fields.length; i++) {
                var index = array.indexOf(fields[i]);
                if (index !== -1) {
                    array.splice(index, 1);
                }
            }
        },

        /**
         * Select fields
         * @memberof DPO.render.BaseTransformTool#
         * @param {DPO.model.Field[]} fields
         * @param {boolean} [append]
         * @param {boolean} [skipUpdate]
         */
        selectFields: function selectFields(fields, append, skipUpdate) {
            var locked = this.lockedFields,
                array = [].concat(append ? this.selectedFields : []);
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    solidBg = f instanceof DPO.model.Background && !f.source;
                if (array.indexOf(f) === -1 && locked.indexOf(f) === -1 && !solidBg) {
                    array.push(f);
                }
            }

            var different = this.selectedFields.length !== array.length;
            for (i = 0; !different && i < array.length; i++) {
                different = this.selectedFields[i] !== array[i];
            }

            if (different) {
                this.selectedFields = array;
                if (!skipUpdate) {
                    this.update();
                }

                this.fire('selected', [this.selectedFields]);
            }
        },

        /**
         * Deselect fields
         * @memberof DPO.render.BaseTransformTool#
         * @param {DPO.model.Field[]} fields
         */
        deselectFields: function deselectFields(fields) {
            var me = this,
                array = [].concat(this.selectedFields);

            for (var i = 0; i < fields.length; i++) {
                var index = array.indexOf(fields[i]);
                if (index !== -1) {
                    array.splice(index, 1);
                }
            }

            var different = me.selectedFields.length !== array.length;
            for (i = 0; !different && i < array.length; i++) {
                different = me.selectedFields[i] !== array[i];
            }

            if (different) {
                me.selectedFields = array;
                me.update();
                me.fire('selected', [me.selectedFields]);
            }
        },

        beginTransforming: function beginTransforming() {
            var me = this;
            me.transforming++;
            me.projectTransformer.beginUpdates();
            me.editor.dangerousAreaVisible(me.transforming > 0);

            if (me.transforming === 1) {
                me.fire('begin:transform', [me]);
            }
        },

        endTransforming: function endTransforming() {
            var me = this;
            if (me.transforming === 0) {
                return;
            }
            
            me.projectTransformer.endUpdates();
            me.transforming--;
            me.editor.dangerousAreaVisible(me.transforming > 0);

            if (me.transforming === 0) {
                me.fire('end:transform', [me]);
            }
        },

        firePositionChanged: function firePositionChanged() {
            this.fire('changed:position', [this.selectedFields]);
        },

        fireSizeChanged: function fireSizeChanged() {
            this.fire('changed:size', [this.selectedFields]);
        },

        /**
         * Updates transform tool
         * @memberof DPO.render.BaseTransformTool#
         */
        update: DPO.emptyFn,

        /**
         * Translate selected fields by dx,dy
         * @memberof DPO.render.BaseTransformTool#
         * @param {number} dx
         * @param {number} dy
         */
        translate: DPO.emptyFn,

        /**
         * Rotate selected fields by d degrees
         * @memberof DPO.render.BaseTransformTool#
         * @param {number} d
         */
        rotate: DPO.emptyFn
    });

    return BaseTransformTool;
});
DPO.def('render.TextTransformTool', function () {
    /**
     * @mixin DPO.render.TextTransformTool
     */
    var TextTransformTool = {};
    DPO.mixin(TextTransformTool, DPO.mixins.Observable, {
        dataIndex: null,
        renderer: null,
        context: null,
        canvas: null,
        coordinateTransformer: null,
        projectEditor: null,

        initTextTransformTool: function initTextTransformTool(textAreaContainer, cfg) {
            var me = this,
                textArea = document.createElement('textarea');

            me.id = me.id || DPO.id();
            textArea.id = me.id + '-edit-text-area';
            textArea.setAttribute('wrap', 'off');
            textArea.style.setProperty('position', 'absolute', '');
            textArea.style.setProperty('z-index', '-1000', '');
            textArea.style.setProperty('left', '-350px', '');
            textArea.style.setProperty('top', '-350px', '');
            textArea.style.setProperty('width', '300px', '');
            textArea.style.setProperty('height', '300px', '');

            me.onKeyDownListener = me.onKeyDown.bind(me);
            me.onKeyPressListener = me.onKeyPress.bind(me);
            me.onPasteListener = me.onPaste.bind(me);
            me.onSelectListener = me.onSelect.bind(me);
            me.onBlurListener = me.onBlur.bind(me);
            me.textSelectionMouseMoveListener = me.onTextSelectionMouseMove.bind(me);
            me.textSelectionMouseUpListener = me.onTextSelectionMouseUp.bind(me);
            me.projectTransformer.registerTimeResource('selectionStart');
            me.projectTransformer.registerTimeResource('selectionEnd');

            textAreaContainer.insertBefore(textArea, textAreaContainer.childNodes[0]);
            me.recordIndex = 0;
            me.textEditCfg = {
                textEditorCfg: cfg || {},
                textArea: textArea,
                textFlow: null,
                cursor: null
            };
            me.clearCharCache();
            me.resetObservable();
        },

        destroyTextTransformTool: function destroyTextTransformTool() {
            var me = this;
            if (me.textEditCfg) {
                me.editTextBlock(null);
                var textArea = me.textEditCfg.textArea;
                textArea.parentElement.removeChild(textArea);
                me.textEditCfg = null;
            }
        },

        adjustTextBlockHeight: function adjustTextBlockHeight() {
            var me = this,
                ctx = me.context,
                cfg = me.textEditCfg,
                field = /** @type DPO.model.TextBlock*/ctx.selector.getField(cfg.textEditor.textBlockId),
                g = ctx.layoutManager.calculateTextBlockGeometry(field, 'top', true);
            if (g.height > field.height) {
                ctx.projectEditor.beginUpdates();
                ctx.projectEditor.setProperties(field, g);
                ctx.projectEditor.endUpdates();
            }
        },

        onStyleChanged: function onStyleChanged(textEditor) {
            var me = this,
                markup = me.renderer.fieldMarkup(textEditor.textBlock, null, textEditor.index),
                canvas = me.canvas;
            me.clearCharCache();
            canvas.dpoUpdate(markup);
            me.adjustTextBlockHeight();
            me.updateTextSelection();
        },

        onTextDestroyed: function onTextDestroyed() {
            this.editTextBlock(null, false);
        },

        onTextRestored: function onTextRestored(textEditor) {
            var me = this,
                pt = me.projectTransformer,
                markup = me.renderer.fieldMarkup(textEditor.textBlock, null, textEditor.index, true),
                canvas = me.canvas,
                cfg = me.textEditCfg,
                text = cfg.textEditor.getPlainText();
            me.clearCharCache();
            canvas.dpoUpdate(markup);
            cfg.textArea.value = text;

            var start = pt.lookupTimeResource('selectionStart') || 0,
                end = pt.lookupTimeResource('selectionEnd') || 0;
            start = Math.max(0, start);
            end = Math.min(text.length, end);
            cfg.textArea.setSelectionRange(start, end);
        },

        onTextChanged: function onTextChanged() {
            var me = this,
                cfg = me.textEditCfg;
            me.clearCharCache();

            var start = cfg.textArea.selectionStart,
                text = cfg.textEditor.getPlainText();
            me.adjustTextBlockHeight();

            start = Math.min(text.length, start + 1);
            cfg.textArea.value = text;
            me.setTextSelectionRange(start, start);
            me.updateTextSelection();
        },

        onTextFieldGeometryChanged: function onTextFieldGeometryChanged() {
            this.clearCharCache();
            this.updateTextSelection();
        },

        selectAllText: function selectAllText() {
            var me = this,
                cfg = me.textEditCfg;
            if (!cfg.textEditor) {
                return;
            }

            var text = cfg.textEditor.getPlainText();
            me.setTextSelectionRange(0, text.length);
            me.updateTextSelection();
        },

        selectWordAtIndex: function selectWordAtIndex(index) {
            var me = this,
                spaceRegexp = /\s/,
                cfg = me.textEditCfg;
            if (!cfg.textEditor) {
                return;
            }

            var text = cfg.textEditor.getPlainText(),
                start = Math.max(index, 0),
                end = Math.min(index, text.length),
                ch;
            for (; start > 0; start--) {
                ch = text[start];
                if (spaceRegexp.test(ch)) {
                    start++;
                    break;
                }
            }

            for (; end < text.length; end++) {
                ch = text[end];
                if (spaceRegexp.test(ch)) {
                    break;
                }
            }

            me.setTextSelectionRange(start, end);
            me.updateTextSelection();
        },

        startTextEditing: function startTextEditing(textBlock) {
            var me = this,
                cfg = me.textEditCfg,
                ctx = me.renderer.context,
                boundTextBlock = ctx.binder.bindDataToField(textBlock, me.recordIndex);
            cfg.originalTextBlock = textBlock;
            cfg.textEditor = new DPO.text.Editor(boundTextBlock, me.recordIndex, me.renderer.context, cfg.textEditorCfg);
            cfg.textEditor.on('text:destroyed', me.onTextDestroyed, me);
            cfg.textEditor.on('text:restored', me.onTextRestored, me);
            cfg.textEditor.on('text:changed', me.onTextChanged, me);
            cfg.textEditor.on('style:changed', me.onStyleChanged, me);
            cfg.textArea.style.setProperty('display', 'block', '');
            cfg.textArea.value = cfg.textEditor.getPlainText();
            cfg.textArea.focus();
            cfg.textArea.addEventListener('keydown', me.onKeyDownListener);
            cfg.textArea.addEventListener('keypress', me.onKeyPressListener);
            cfg.textArea.addEventListener('paste', me.onPasteListener, true);
            cfg.textArea.addEventListener('select', me.onSelectListener);
            cfg.textArea.addEventListener('blur', me.onBlurListener);
            cfg.caretInterval = setInterval(function () {
                var caret = Snap('#' + me.id + '-caret');
                if (caret) {
                    var visible = caret.attr('display') !== 'none';
                    caret.attr({
                        'display': visible ? 'none' : 'inline'
                    });
                }
            }, 500);

            me.projectTransformer.on('changed:field:geometry', me.onTextFieldGeometryChanged, me);
            me.fire('begin:text:editing', [this, cfg.originalTextBlock]);
            me.clearCharCache();
            me.setTextSelectionRange(cfg.textArea.selectionStart, cfg.textArea.selectionEnd);
            me.updateTextSelection();
            me.onBeginTextEditing(textBlock);
        },

        stopTextEditing: function stopTextEditing() {
            var me = this,
                cfg = me.textEditCfg,
                te = cfg.textEditor,
                selectionId = me.id + '-text-selection',
                selection = Snap('#' + selectionId);

            if (!te) {
                return;
            }

            if (selection) {
                selection.remove();
            }

            cfg.textEditor = null;
            cfg.textArea.removeEventListener('keydown', me.onKeyDownListener);
            cfg.textArea.removeEventListener('keypress', me.onKeyPressListener);
            cfg.textArea.removeEventListener('paste', me.onPasteListener, true);
            cfg.textArea.removeEventListener('select', me.onSelectListener);
            cfg.textArea.removeEventListener('blur', me.onBlurListener);
            cfg.textArea.style.setProperty('display', 'none', '');
            cfg.textArea.blur();
            cfg.textArea.value = '';
            clearInterval(cfg.caretInterval);

            te.destroy();

            var textBlock = te.originalTextBlock;
            if (textBlock) {
                me.fire('end:text:editing', [this, textBlock]);
            }
            me.endTextSelection();
            me.projectTransformer.un('changed:field:geometry', me.onTextFieldGeometryChanged, me);
            me.onEndTextEditing();
        },

        editTextBlock: function editTextBlock(textBlock, skipFlush) {
            var me = this,
                cfg = me.textEditCfg;
            if (cfg.textEditor && cfg.textEditor.originalTextBlock === textBlock) {
                cfg.textArea.focus();
                return false;
            }

            me.stopTextEditing(skipFlush);

            if (textBlock) {
                me.startTextEditing(textBlock);
            }

            return !!textBlock;
        },

        onBeginTextEditing: function onBeginTextEditing() {
        },

        onEndTextEditing: function onEndTextEditing() {
        },

        spliceText: function spliceText(start, end, value, delta) {
            var me = this,
                cfg = me.textEditCfg,
                offset = cfg.textEditor.spliceText(start, end, value),
                text = cfg.textEditor.getPlainText();

            delta = delta === undefined ? value.length : delta;
            delta = Math.min(text.length, start + offset + delta);
            delta = Math.max(delta, 0);

            cfg.textArea.value = text;
            me.setTextSelectionRange(delta, delta);
            me.updateTextSelection();
            me.fire('selected:text', [this]);
        },

        collectRichTextAttributes: function collectRichTextAttributes() {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectTransformer,
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                textEditor = cfg.textEditor, attributes, spans, paragraphs;
            if (textEditor) {
                paragraphs = textEditor.getParagraphs(start < end ? start + 1 : start, end);
                spans = textEditor.getSpans(start < end ? start + 1 : start, end);
                attributes = pt.selector.collectRichTextAttributes(spans);
                attributes.textAlignment = pt.selector.collectRichTextAttributes(paragraphs).textAlignment;
                attributes.verticalTextAlignment = pt.selector.collectRichTextAttributes(textEditor.textBlock).verticalTextAlignment;
            } else {
                attributes = pt.selector.collectRichTextAttributes(me.selectedFields);
            }

            return attributes;
        },

        /**
         * @param {DPO.model.Paragraph[]} paragraphs
         */
        insertParagraphs: function insertParagraphs(paragraphs) {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                textEditor = cfg.textEditor,
                start, count;
            pt.beginUpdates();
            if (textEditor) {
                start = cfg.textArea.selectionStart;
                count = cfg.textArea.selectionEnd - start;
                textEditor.insertParagraph(start, count, paragraphs);
            } else {
                for (var i = 0; i < me.selectedFields.length; i++) {
                    var f = me.selectedFields[i];
                    textEditor = new DPO.text.Editor(f, me.recordIndex, me.renderer.context);
                    textEditor.overrideParagraphs(paragraphs);
                    textEditor.destroy();

                    me.adjustTextBlockGeometry(f);
                }
            }
            pt.endUpdates();
            me.updateTextSelection();
        },

        applyTextAlignment: function applyTextAlignment(alignment) {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                textEditor = cfg.textEditor, text;
            pt.beginUpdates();
            if (textEditor) {
                textEditor.applyTextAlignment(alignment, start, end - start);
            } else {
                for (var i = 0; i < me.selectedFields.length; i++) {
                    var f = me.selectedFields[i];
                    textEditor = new DPO.text.Editor(f, me.recordIndex, me.renderer.context);
                    text = textEditor.getPlainText();
                    textEditor.applyTextAlignment(alignment, 0, text.length);
                    textEditor.destroy();
                }
            }
            pt.endUpdates();
            me.updateTextSelection();
        },

        /**
         * Applies vertical text alignment for textFlow
         * @memberof DPO.render.TextTransformTool#
         * @param {string} alignment
         */
        applyVerticalTextAlignment: function applyVerticalTextAlignment(alignment) {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                textEditor = cfg.textEditor;
            pt.beginUpdates();
            if (textEditor) {
                textEditor.applyVerticalTextAlignment(alignment);
            } else {
                for (var i = 0; i < me.selectedFields.length; i++) {
                    var f = me.selectedFields[i];
                    textEditor = new DPO.text.Editor(f, me.recordIndex, me.renderer.context);
                    textEditor.applyVerticalTextAlignment(alignment);
                    textEditor.destroy();
                }
            }
            pt.endUpdates();
            me.updateTextSelection();
        },

        /**
         * Applies rotate sense for textBlock
         * @memberof DPO.render.TextTransformTool##
         * @param {string} type
         */
        applyRotateSense: function applyRotateSense(type) {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                textEditor = cfg.textEditor;
            pt.beginUpdates();
            if (textEditor) {
                textEditor.applyRotateSense(type);
            } else {
                for (var i = 0; i < me.selectedFields.length; i++) {
                    var f = me.selectedFields[i];
                    textEditor = new DPO.text.Editor(f, me.recordIndex, me.renderer.context);
                    textEditor.applyRotateSense(type);
                    textEditor.destroy();
                }
            }
            pt.endUpdates();
            me.updateTextSelection();
        },

        /**
         * Adjust text block height & position to fit inner text
         * @memberof DPO.render.TextTransformTool##
         * @param {DPO.model.TextBlock} textBlock
         */
        adjustTextBlockGeometry: function adjustTextBlockGeometry(textBlock) {
            var me = this,
                pe = me.projectEditor,
                g = me.context.layoutManager.calculateTextBlockGeometry(textBlock, 'top', true),
                adjust = g.height > textBlock.height;
            if (adjust) {
                pe.beginUpdates();
                textBlock.position.x = g.position.x;
                textBlock.position.y = g.position.y;
                textBlock.width = g.width;
                textBlock.height = g.height;
                pe.fireGeometryChanged([textBlock]);
                pe.endUpdates();
            }

            return adjust;
        },

        /**
         * Applies text overflow method
         * @memberof DPO.render.TextTransformTool##
         * @param {string} type
         */
        applyTextOverflow: function applyTextOverflow(type) {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                textEditor = cfg.textEditor;
            pt.beginUpdates();
            if (textEditor) {
                textEditor.applyTextOverflow(type);
            } else {
                for (var i = 0; i < me.selectedFields.length; i++) {
                    var f = me.selectedFields[i];
                    textEditor = new DPO.text.Editor(f, me.recordIndex, me.renderer.context);
                    textEditor.applyTextOverflow(type);
                    textEditor.destroy();
                    me.adjustTextBlockGeometry(f);
                }
            }
            pt.endUpdates();
            me.updateTextSelection();
        },

        insertSerialNumber: function insertSerialNumber(serialNumber) {
            var me = this,
                ctx = me.renderer.context,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                start = cfg.textArea.selectionStart,
                textEditor = cfg.textEditor;
            pt.beginUpdates();
            if (textEditor) {
                var pos = textEditor.splitPosition(start),
                    span = pt.clone(pos.span);
                pt.setSerialNumber(/** @type DPO.model.Span*/span, serialNumber);
                ctx.binder.bindDataToSpans(span, me.recordIndex);
                textEditor.insertSpans(start, span);
            }
            pt.endUpdates();
            me.updateTextSelection();
        },

        applyStyle: function applyStyle(style) {
            var me = this,
                cfg = me.textEditCfg,
                pt = me.projectEditor,
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                ctx = me.renderer.context,
                textEditor = cfg.textEditor,
                text;
            pt.beginUpdates();
            if (textEditor) {
                textEditor.applyStyle(style, start, end - start);
            } else {
                for (var i = 0; i < me.selectedFields.length; i++) {
                    var f = me.selectedFields[i];
                    textEditor = new DPO.text.Editor(f, me.recordIndex, ctx);
                    text = textEditor.getPlainText();
                    textEditor.applyStyle(style, 0, text.length);
                    textEditor.destroy();
                    me.adjustTextBlockGeometry(f);
                }
            }

            ctx.layoutManager.loadFonts(ctx.project);
            pt.endUpdates();
            me.updateTextSelection();
        },

        detectSerialSelection: function detectSerialSelection() {
            var me = this,
                cfg = me.textEditCfg,
                textEditor = cfg.textEditor;

            if (!textEditor) {
                return null;
            }

            var positions = textEditor.getBindingPositions(),
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                span, s, i, pos;

            for (i = 0; !span && i < positions.length; i++) {
                pos = positions[i];
                s = pos.span;
                if (!s.serialNumberField) {
                    continue;
                }

                if (start >= pos.start && end <= pos.end) {
                    span = s;
                } else {
                    var prevPos = positions[i - 1] ? positions[i - 1].end : -Infinity,
                        nextPos = positions[i + 1] ? positions[i + 1].start : Infinity;

                    if (start >= pos.start && start < pos.end && end <= nextPos) {
                        span = s;
                    } else if (end <= pos.end && end > pos.start && start >= prevPos) {
                        span = s;
                    } else if (end > pos.end && start < pos.start && end <= nextPos && start >= prevPos) {
                        span = s;
                    }
                }
            }

            return span ? me.context.selector.getSerialNumber(span.serialNumberField) : null;
        },

        onTextSelectionMouseMove: function onTextSelectionMouseMove(e) {
            var me = this,
                cfg = me.textEditCfg,
                field = cfg.textEditor.textBlock,
                offset = me.coordinateTransformer.getMouseOffset(e),
                pos = me.getTextSelectionPosition(field, offset.x, offset.y);
            me.textSelection.end = pos;
            me.moveCaret(me.textSelection.start, pos);
        },

        onTextSelectionMouseUp: function onTextSelectionMouseUp() {
            this.endTextSelection();
            this.fire('selected:text', [this]);
        },

        startTextSelection: function startTextSelection(offset) {
            var me = this,
                f = me.textEditCfg.textEditor.textBlock,
                pos = me.getTextSelectionPosition(f, offset.x, offset.y);
            me.textSelection = {
                start: pos,
                end: pos
            };
            me.textEditCfg.textArea.focus();
            me.moveCaret(pos);
            Snap.mousemove(me.textSelectionMouseMoveListener).mouseup(me.textSelectionMouseUpListener);
        },

        endTextSelection: function endTextSelection() {
            var me = this;
            Snap.unmousemove(me.textSelectionMouseMoveListener)
                .unmouseup(me.textSelectionMouseUpListener);
        },

        clearCharCache: function clearCharCache() {
            this.charCache = {};
        },

        getCharGeometry: function getCharGeometry(paragraph, index, paragraphEl) {
            var me = this,
                key = paragraph + '-' + index,
                geometry = me.charCache[key];
            if (geometry) {
                return geometry;
            }

            var cfg = me.textEditCfg,
                field = cfg.textEditor.textBlock,
                fieldMarkupId = me.renderer.fieldMarkupId(field),
                rotation = 0;
            paragraphEl = paragraphEl || Snap('#' + fieldMarkupId + '-p' + paragraph);
            if (field instanceof DPO.model.TextPath) {
                rotation = paragraphEl.node.getRotationOfChar(index);
            }

            geometry = {
                paragraph: paragraph,
                index: index,
                bounds: paragraphEl.node.getExtentOfChar(index),
                rotation: rotation,
                startPosition: paragraphEl.node.getStartPositionOfChar(index),
                endPosition: paragraphEl.node.getEndPositionOfChar(index)
            };

            me.charCache[key] = geometry;
            return geometry;
        },

        getCharGeometryAtPos: function getCharGeometryAtPos(field, x, y) {
            var me = this,
                keys = Object.keys(me.charCache),
                key, i, g, b, query;
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                g = me.charCache[key];
                b = g.bounds;
                if (b.x > x || b.y > y || (b.x + b.width) < x || (b.y + b.height) < y) {
                    continue;
                }

                return g;
            }

            var id = me.renderer.fieldMarkupId(field),
                el = Snap('#' + id),
                paragraphs = field.text.textFlow.paragraphs,
                svgElement = me.canvas.node.ownerSVGElement || me.canvas.node,
                hitPoint = svgElement.createSVGPoint(),
                text, index;

            hitPoint.x = x;
            hitPoint.y = y;

            for (i = 0; i < paragraphs.length; i++) {
                query = '#' + id + '-p' + i;
                text = Snap(el).select(query);
                index = text.node.getCharNumAtPosition(hitPoint);
                if (index >= 0) {
                    return me.getCharGeometry(i, index, text);
                }
            }

            return null;
        },

        getTextHitTestApproximation: function getTextHitTestApproximation(field, pointInCanvas) {
            var me = this,
                editableId = me.textEditCfg.textEditor && me.textEditCfg.textEditor.textBlockId,
                canvasToFieldMatrix = me.coordinateTransformer.canvasToFieldMatrix(field),
                svgElement = me.canvas.node.ownerSVGElement || me.canvas.node,
                hitPoint = svgElement.createSVGPoint();
            hitPoint.x = canvasToFieldMatrix.x(pointInCanvas.x, pointInCanvas.y);
            hitPoint.y = canvasToFieldMatrix.y(pointInCanvas.x, pointInCanvas.y);

            var lm = me.renderer.context.layoutManager,
                containers = lm.layoutTextBlock(field, editableId === field.id),
                id = me.renderer.fieldMarkupId(field),
                dy = Infinity,
                best = null;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i],
                    lines = container.lines;
                for (var j = 0; j < lines.length; j++) {
                    var line = lines[j],
                        point = new DPO.math.Point(hitPoint.x, hitPoint.y),
                        containerPoint = point.translate(0, -container.offset),
                        projectPoint = line.geometry.projectPoint(containerPoint),
                        delta = Math.abs(projectPoint.y - containerPoint.y);
                    if (dy > delta) {
                        dy = delta;
                        best = {
                            field: field,
                            textElementId: id + '-p' + i,
                            approximatedHitPoint: projectPoint.translate(0, container.offset),
                            projectPoint: projectPoint,
                            textLayout: containers,
                            container: container,
                            containerIndex: i,
                            line: line,
                            lineIndex: j
                        };
                    }
                }
            }

            return best;
        },

        findPosByApproximation: function findPosByApproximation(best) {
            var length = best.line.geometry.lengthAtPoint(best.projectPoint),
                lm = this.renderer.context.layoutManager,
                charIndex = lm.getCharIndexAtLength(best.line, length);
            for (var i = 0; i < best.container.lines.length; i++) {
                var line = best.container.lines[i];
                if (line !== best.line) {
                    charIndex += line.totalLength();
                } else {
                    break;
                }
            }

            var text = Snap('#' + best.textElementId),
                count = text.node.getNumberOfChars(),
                hitPoint = best.approximatedHitPoint,
                bounds = text.node.getExtentOfChar(charIndex);
            charIndex += Math.round((hitPoint.x - bounds.x) / bounds.width);
            charIndex = Math.min(charIndex, count);
            charIndex = Math.max(charIndex, 0);
            return {
                paragraphIndex: best.containerIndex,
                charIndex: charIndex
            };
        },

        getTextSelectionPosition: function getTextSelectionPosition(field, x, y) {
            var me = this,
                matrix = me.coordinateTransformer.clientToCanvasMatrix(),
                canvasPos = {
                    x: matrix.x(x, y),
                    y: matrix.y(x, y)
                },
                canvasToFieldMatrix = me.coordinateTransformer.canvasToFieldMatrix(field),
                svgElement = me.canvas.node.ownerSVGElement || me.canvas.node,
                hitPoint = svgElement.createSVGPoint();
            hitPoint.x = canvasToFieldMatrix.x(canvasPos.x, canvasPos.y);
            hitPoint.y = canvasToFieldMatrix.y(canvasPos.x, canvasPos.y);

            var g = me.getCharGeometryAtPos(field, hitPoint.x, hitPoint.y),
                sp, ep, sd, ed;
            if (g) {
                sp = g.startPosition;
                ep = g.endPosition;
                sd = Math.pow(sp.x - hitPoint.x, 2) + Math.pow(sp.y - hitPoint.y, 2);
                ed = Math.pow(ep.x - hitPoint.x, 2) + Math.pow(ep.y - hitPoint.y, 2);
                return {
                    paragraphIndex: g.paragraph,
                    charIndex: g.index + (ed < sd ? 1 : 0)
                };
            }

            var best = me.getTextHitTestApproximation(field, canvasPos),
                text = Snap('#' + best.textElementId);
            hitPoint.x = best.approximatedHitPoint.x;
            hitPoint.y = best.approximatedHitPoint.y;

            var charIndex = text.node.getCharNumAtPosition(hitPoint);
            if (charIndex === -1) {
                return me.findPosByApproximation(best);
            } else {
                sp = text.node.getStartPositionOfChar(charIndex);
                ep = text.node.getEndPositionOfChar(charIndex);
                sd = Math.pow(sp.x - hitPoint.x, 2) + Math.pow(sp.y - hitPoint.y, 2);
                ed = Math.pow(ep.x - hitPoint.x, 2) + Math.pow(ep.y - hitPoint.y, 2);
                return {
                    paragraphIndex: best.containerIndex,
                    charIndex: charIndex + (ed < sd ? 1 : 0)
                };
            }
        },

        /**
         * Select specified tex range
         * @memberof DPO.render.TextTransformTool#
         * @param {object} startPos
         * @param {object} [endPos]
         */
        moveCaret: function moveCaret(startPos, endPos) {
            var me = this,
                cfg = me.textEditCfg,
                start = cfg.textEditor.combinePosition(startPos.paragraphIndex, startPos.charIndex),
                end = start, tmp;
            if (endPos) {
                end = cfg.textEditor.combinePosition(endPos.paragraphIndex, endPos.charIndex);
            }

            if (start > end) {
                tmp = start;
                start = end;
                end = tmp;
            }

            me.setTextSelectionRange(start, end);
        },

        updateTextBlockSelection: function updateTextBlockSelection(selection, start, end) {
            var me = this,
                cfg = me.textEditCfg,
                positions = cfg.textEditor.getBindingPositions(),
                textBlock = cfg.textEditor.textBlock,
                rectangles = [],
                sp, g, i, j;

            function pushRect(rects, rect) {
                var prev = rects[rects.length - 1];
                if (prev && prev.y === rect.y && prev.fill === rect.fill) {
                    prev.width = rect.x + rect.width - prev.x;
                } else {
                    rects.push(rect);
                }
            }

            for (i = start; i < end; i++) {
                sp = cfg.textEditor.splitPosition(i);
                if (!sp || sp.newLineChar) {
                    continue;
                }

                g = me.getCharGeometry(sp.line, sp.char);
                pushRect(rectangles, {
                    fill: 'rgb(181, 213, 255)',
                    x: g.bounds.x,
                    y: g.bounds.y,
                    width: g.bounds.width,
                    height: g.bounds.height
                });
            }

            for (i = 0; i < positions.length; i++) {
                var p = positions[i],
                    color = p.span.serialNumberField ? 'rgb(0, 213, 0)' : 'rgb(255, 255, 0)',
                    array = [];
                for (j = p.start; j < p.end; j++) {
                    sp = cfg.textEditor.splitPosition(j);
                    g = me.getCharGeometry(sp.line, sp.char);
                    pushRect(array, {
                        fill: color,
                        fillOpacity: 0.4,
                        x: g.bounds.x,
                        y: g.bounds.y,
                        width: g.bounds.width,
                        height: g.bounds.height
                    });
                }

                rectangles = rectangles.concat(array);
            }

            var width = textBlock.width / 20;
            for (i = 0; i < rectangles.length; i++) {
                var r = rectangles[i];
                r.width = Math.min(r.width, width - r.x);
                selection.rect(r);
            }
        },

        /**
         * Returns circular text metrics
         * @param {DPO.model.TextPath} textPath
         * @param {number} start
         * @param {number} end
         * @returns {{center: {x: number, y: number}, a: number, b: number, ascender: number, descender: number, svgPath: *, totalLength: *, lineWidth: number}}
         */
        getCircularTextMetrics: function getCircularTextMetrics(textPath, start, end) {
            function getLargestSpan(array) {
                var max = Number.NEGATIVE_INFINITY,
                    span = null;
                for (var i = 0; i < array.length; i++) {
                    var s = array[i];
                    if (max < s.fontSize) {
                        span = s;
                        max = s.fontSize;
                    }
                }
                return span;
            }

            var me = this,
                span = getLargestSpan(textPath.text.textFlow.paragraphs[0].spans),
                metrics = DPO.text.DefaultMetrics,
                m = metrics.getMetricsForSpan(span),
                ascender = metrics.getAscender(m, span.fontSize),
                descender = metrics.getDescender(m, span.fontSize),
                capHeight = metrics.getCapHeight(m, span.fontSize),
                svgPath = me.renderer.pathForCircularText(textPath, 1),
                totalLength = Snap.path.getTotalLength(svgPath);

            if (textPath.rotateSense === 'ccw') {
                ascender = span.fontSize;
                descender = -(ascender - capHeight) / 2;
            }

            var e = new DPO.text.Editor(textPath, 0, me.renderer.context, {commitChanges: false});
            e.spliceText(end, Number.MAX_VALUE, '');
            e.spliceText(0, start, '');

            var lm = me.renderer.context.layoutManager,
                containers = lm.layoutTextBlock(e.textBlock),
                textLine = containers[0].lines[0],
                a = textPath.width / 40,
                b = textPath.height / 40;
            e.destroy();
            return {
                center: {x: a, y: b},
                a: a,
                b: b,
                capHeight: capHeight,
                ascender: ascender,
                descender: descender,
                svgPath: svgPath,
                totalLength: totalLength,
                lineWidth: textLine.width
            };
        },

        getCircularTextPath: function getCircularTextPath(textPath, start, end) {
            function getLineForCharGeometry(cg, ascender, descender, start) {
                var pos = start ? cg.startPosition : cg.endPosition,
                    x1 = pos.x,
                    y1 = pos.y - ascender,
                    x2 = pos.x,
                    y2 = pos.y - descender,
                    m = Snap.matrix().rotate(cg.rotation, pos.x, pos.y),
                    p1 = {x: m.x(x1, y1), y: m.y(x1, y1)},
                    p2 = {x: m.x(x2, y2), y: m.y(x2, y2)};
                return {
                    p1: p1,
                    p2: p2,
                    line: DPO.math.Line.fromPoints(p1, p2)
                };
            }

            function getClosestPoint(points, p) {
                var distance = Infinity,
                    result = null;
                for (var i = 0; i < points.length; i++) {
                    var p1 = points[i],
                        d = Math.pow(p1.x - p.x, 2) + Math.pow(p1.y - p.y, 2);
                    if (d < distance) {
                        distance = d;
                        result = p1;
                    }
                }

                return result;
            }

            var me = this,
                cfg = me.textEditCfg,
                metrics = me.getCircularTextMetrics(textPath, start, end),
                c = metrics.center,
                inner = new DPO.math.Ellipse(c, metrics.a + metrics.descender, metrics.b + metrics.descender),
                outer = new DPO.math.Ellipse(c, metrics.a + metrics.ascender, metrics.b + metrics.ascender),
                d = '';

            if (metrics.totalLength <= metrics.lineWidth) {
                d += 'M ' + c.x + ' ' + (c.y - outer.b);
                d += ' A ' + outer.a + ',' + outer.b + ' 0 1 1 ';
                d += c.x + ' ' + (c.y + outer.b);
                d += 'L ' + c.x + ' ' + (c.y + inner.b);
                d += ' A ' + inner.a + ',' + inner.b + ' 0 1 0 ';
                d += c.x + ' ' + (c.y - inner.b);
                d += 'L ' + c.x + ' ' + (c.y - outer.b);
                d += ' A ' + outer.a + ',' + outer.b + ' 0 1 0 ';
                d += c.x + ' ' + (c.y + outer.b);
                d += 'L' + c.x + ' ' + (c.y + inner.b);
                d += ' A ' + inner.a + ',' + inner.b + ' 0 1 1 ';
                d += c.x + ' ' + (c.y - inner.b) + 'Z';
                d += 'L' + (c.x - outer.a / 2) + ' ' + (c.y + outer.b / 2);
                return d;
            }

            var sp = cfg.textEditor.splitPosition(start),
                sg = me.getCharGeometry(sp.line, sp.char),
                ep = cfg.textEditor.splitPosition(end - 1),
                eg = me.getCharGeometry(ep.line, ep.char),
                sl = getLineForCharGeometry(sg, metrics.ascender, metrics.descender, true),
                el = getLineForCharGeometry(eg, metrics.ascender, metrics.descender, false),
                points1 = inner.intersectionWithLine(sl.line).concat(outer.intersectionWithLine(sl.line)),
                points2 = inner.intersectionWithLine(el.line).concat(outer.intersectionWithLine(el.line));

            var p0 = getClosestPoint(points1, sl.p1),
                p1 = getClosestPoint(points2, el.p1),
                p2 = getClosestPoint(points2, el.p2),
                p3 = getClosestPoint(points1, sl.p2),
                a1, a2;
            if (textPath.rotateSense === 'ccw') {
                a1 = (Snap.angle(p3.x, p3.y, p2.x, p2.y, c.x, c.y) + 360) % 360;
                a2 = (Snap.angle(p0.x, p0.y, p1.x, p1.y, c.x, c.y) + 360) % 360;

                d += 'M ' + p2.x + ' ' + p2.y;
                d += ' A ' + outer.a + ',' + outer.b;
                d += (a1 < 180) ? ' 0 0 1 ' : ' 0 1 1 ';
                d += p3.x + ',' + p3.y + '';
                d += ' L ' + p0.x + ' ' + p0.y;
                d += ' A ' + inner.a + ',' + inner.b;
                d += (a2 < 180) > 0 ? ' 0 0 0 ' : ' 0 1 0 ';
                d += p1.x + ',' + p1.y + ' Z';
            } else {
                a1 = (Snap.angle(p2.x, p2.y, p3.x, p3.y, c.x, c.y) + 360) % 360;
                a2 = (Snap.angle(p1.x, p1.y, p0.x, p0.y, c.x, c.y) + 360) % 360;

                d += 'M ' + p0.x + ' ' + p0.y;
                d += ' A ' + outer.a + ',' + outer.b;
                d += (a1 < 180) ? ' 0 0 1 ' : ' 0 1 1 ';
                d += p1.x + ',' + p1.y + '';
                d += ' L ' + p2.x + ' ' + p2.y;
                d += ' A ' + inner.a + ',' + inner.b;
                d += (a2 < 180) ? ' 0 0 0 ' : ' 0 1 0 ';
                d += p3.x + ',' + p3.y + ' Z';
            }

            return d;
        },

        updateTextPathSelection: function updateTextPathSelection(selection, start, end) {
            var me = this,
                cfg = me.textEditCfg,
                editor = cfg.textEditor,
                textPath = /** @type DPO.model.TextPath*/editor.textBlock,
                positions = cfg.textEditor.getBindingPositions(),
                paths = [],
                i;

            if (start < end) {
                paths.push({
                    d: me.getCircularTextPath(textPath, start, end),
                    fill: 'rgb(181, 213, 255)',
                    stroke: 'none'
                });
            }

            for (i = 0; i < positions.length; i++) {
                var pos = positions[i],
                    color = pos.span.serialNumberField ? 'rgb(0, 213, 0)' : 'rgb(255, 255, 0)';
                if (pos.start !== pos.end) {
                    paths.push({
                        d: me.getCircularTextPath(textPath, pos.start, pos.end),
                        fill: color,
                        fillOpacity: 0.4,
                        stroke: 'none'
                    });
                }
            }

            for (i = 0; i < paths.length; i++) {
                selection.path(paths[i]);
            }
        },

        setTextSelectionRange: function setTextSelectionRange(start, end) {
            var me = this,
                cfg = this.textEditCfg;
            cfg.textArea.setSelectionRange(start, end);
            me.projectTransformer.storeTimeResource('selectionStart', start);
            me.projectTransformer.storeTimeResource('selectionEnd', end);
            me.updateTextSelection();
        },

        updateTextSelectionInternal: function updateTextSelectionInternal() {
            var me = this,
                cfg = me.textEditCfg;
            delete me.updateTextSelectionInternal;

            if (!cfg || !cfg.textEditor) {
                return;
            }

            var start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                startPos = cfg.textEditor.splitPosition(start),
                endPos = cfg.textEditor.splitPosition(end);
            if (!startPos || !endPos) {
                return;
            }

            var index = endPos.char,
                line = endPos.line,
                pos, geometry, bounds, rotation;

            if (index === 0) {
                geometry = me.getCharGeometry(line, index);
                bounds = geometry.bounds;
                rotation = geometry.rotation;
                pos = geometry.startPosition;
            } else {
                geometry = me.getCharGeometry(line, index - 1);
                bounds = geometry.bounds;
                rotation = geometry.rotation;
                pos = geometry.endPosition;
            }

            var zoom = me.coordinateTransformer.getScale(),
                h = bounds.height,
                x = pos.x,
                y = pos.y,
                caretAttr = {
                    'id': me.id + '-caret',
                    'stroke': '#000',
                    'stroke-width': 1.5 / zoom,
                    'x1': x,
                    'y1': y + h * 0.15,
                    'x2': x,
                    'y2': y - h * 0.75,
                    'transform': Snap.matrix().rotate(rotation, pos.x, pos.y)
                };

            var selectionId = me.id + '-text-selection',
                selection = Snap('#' + selectionId),
                field = cfg.textEditor.originalTextBlock,
                fieldMarkupId = me.renderer.fieldMarkupId(field),
                el = Snap('#' + fieldMarkupId);
            if (!selection) {
                selection = el.g({id: selectionId});
                selection.insertBefore(el.node.childNodes[0]);
                selection.line(caretAttr);
            } else {
                selection.selectAll('rect, path').remove();
                selection.select('#' + me.id + '-caret').attr(caretAttr);
            }

            if (cfg.textEditor.textBlock instanceof DPO.model.TextPath) {
                me.updateTextPathSelection(selection, start, end);
            } else {
                me.updateTextBlockSelection(selection, start, end);
            }

            cfg.textArea.focus();
        },

        updateTextSelection: function updateTextSelection() {
            var me = this;
            DPO.render.requestAnimationFrame(me.updateTextSelectionInternal.bind(me));
            me.updateTextSelectionInternal = DPO.emptyFn;
        },

        onPaste: function onPaste(e) {
            e.stopPropagation();
            e.preventDefault();

            var me = this,
                cfg = me.textEditCfg,
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                clipboardData = e.clipboardData || /* istanbul ignore next */ window.clipboardData,
                value = clipboardData.getData('Text'),
                offset;

            if (start === end) {
                offset = cfg.textEditor.spliceText(start, 0, value);
            } else {
                offset = cfg.textEditor.spliceText(start, end - start, value);
            }

            var position = offset + start + value.length;
            cfg.textArea.value = cfg.textEditor.getPlainText();
            me.fire('selected:text', [this]);

            // IE wants additional delay for selectionStart updating
            //setTimeout(function () {
            me.setTextSelectionRange(position, position);
            me.updateTextSelection();
            //}, 1);
        },

        onSelect: function onSelect() {
            this.updateTextSelection();
            this.fire('selected:text', [this]);
        },

        onBlur: function onBlur() {
            //console.log('Blur');
            //this.editTextBlock(null);
        },

        onKeyPress: function onKeyPress(e) {
            // Firefox trigger events for non char key, skip it.
            // noinspection JSUnresolvedVariable
            // noinspection OverlyComplexBooleanExpressionJS
            if (!e.charCode || e.keyCode === 13 || e.metaKey || e.altKey || e.ctrlKey) {
                return;
            }

            e.preventDefault();

            var me = this,
                cfg = me.textEditCfg,
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd,
                value = String.fromCharCode(e.charCode);
            me.spliceText(start, end - start, value);
            me.fire('selected:text', [this]);
        },

        onKeyDown: function onKeyDown(e) {
            var me = this,
                cfg = me.textEditCfg,
                start = cfg.textArea.selectionStart,
                end = cfg.textArea.selectionEnd;
            if (e.keyCode === 90 && (e.metaKey || e.ctrlKey)) {
                var pt = me.context.projectTransformer;
                if (e.shiftKey) {
                    pt.redo();
                } else {
                    pt.undo();
                }

                e.preventDefault();
                e.stopPropagation();
                return;
            }

            if (e.metaKey || e.altKey || e.ctrlKey) {
                return;
            }

            switch (e.keyCode) {
                case 8:
                    if (start === end) {
                        me.spliceText(start - 1, 1, '');
                    } else {
                        me.spliceText(start, end - start, '');
                    }
                    me.fire('selected:text', [this]);
                    break;
                case 9:
                    me.selectNextField();
                    break;
                case 13:
                    var field = cfg.textEditor.textBlock;
                    if (!(field instanceof DPO.model.TextPath)) {
                        cfg.textEditor.insertParagraph(start, start === end ? 0 : end - start);
                        me.setTextSelectionRange(start + 1, start + 1);
                        me.fire('selected:text', [this]);
                    }
                    break;
                case 27:
                    me.editTextBlock(null, true);
                    break;
                case 46:
                    me.spliceText(start, start === end ? 1 : end - start, '');
                    break;
                case 35:
                case 38:
                case 36:
                case 39:
                case 37:
                case 40:
                    setTimeout(function () {
                        me.updateTextSelection();
                        me.fire('selected:text', [me]);
                    }, 1);
                    return;
                default:
                    return;
            }
            e.preventDefault();
        }
    });

    return TextTransformTool;
});

DPO.def('render.CropImageTool', function () {
    /**
     * @mixin DPO.render.CropImageTool
     */
    var CropImageTool = {};
    DPO.mixin(CropImageTool, DPO.mixins.Observable, {
        initCropImageTool: function initCropImageTool() {
            var me = this;
            me.cropMouseMoveListener = me.onCropMouseMove.bind(me);
            me.cropMouseUpListener = me.onCropMouseUp.bind(me);
            me.cropImageCfg = {
                controls: {}
            };
        },

        /**
         * Begins/ends crop image
         * @param {DPO.model.Image} image
         */
        cropImage: function cropImage(image) {
            var me = this,
                cfg = me.cropImageCfg;
            if (image === cfg.field) {
                return;
            }

            var cropGroupId = me.id + '-crop-group',
                cropGroup = Snap('#' + cropGroupId);
            if (cropGroup) {
                cropGroup.remove();
            }

            me.cropImageCfg = cfg;

            me.el.attr({
                display: image ? 'none' : 'inherit'
            });

            if (image) {
                cfg.changed = false;
                cfg.field = image;
                cfg.fieldMarkupId = me.renderer.fieldMarkupId(image);
                cfg.viewBox = {
                    x1: 0,
                    y1: 0,
                    x2: image.width / 20,
                    y2: image.height / 20
                };
                me.renderCropControls();
            } else {
                if (cfg.changed) {
                    me.fire('cropped:image', [this, cfg.viewBox, cfg.field]);
                }
                cfg.field = null;
                cfg.fieldMarkupId = null;
                cfg.controls = {};
                cfg.shadow = null;
            }
        },

        startImageCropping: function startImageCropping() {
            var me = this;
            Snap.mousemove(me.cropMouseMoveListener).mouseup(me.cropMouseUpListener);
        },

        onCropMouseMove: function onCropMouseMove(e) {
            var me = this,
                cfg = this.cropImageCfg,
                pos = cfg.field.position,
                rotation = cfg.field.rotation * Math.PI / 180,
                vb = cfg.viewBox,
                startPoint = cfg.points[cfg.sizingPoint],
                mouse = me.coordinateTransformer.getMouseOffset(e),
                toCanvas = me.coordinateTransformer.clientToCanvasMatrix(),
                currentPoint = {
                    x: toCanvas.x(mouse.x, mouse.y) - pos.x / 20,
                    y: toCanvas.y(mouse.x, mouse.y) - pos.y / 20
                },
                dx = (currentPoint.x * Math.cos(rotation) - currentPoint.y * Math.sin(rotation)) - startPoint.x,
                dy = (currentPoint.x * Math.sin(rotation) + currentPoint.y * Math.cos(rotation)) - startPoint.y;

            cfg.changed = true;
            cfg.modifyViewBox(vb, dx, dy);
            me.applyCropConstraints(vb, cfg.field);
            me.renderCropControls();
        },

        onCropMouseUp: function onCropMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            this.stopImageCropping();
        },

        stopImageCropping: function stopImageCropping() {
            var me = this;
            Snap.unmousemove(me.cropMouseMoveListener).unmouseup(me.cropMouseUpListener);
        },

        applyCropConstraints: function applyCropConstraints(vb, field) {
            var cfg = this.cropImageCfg,
                p = cfg.sizingPoint,
                width = field.width / 20,
                height = field.height / 20,
                size = 10;

            vb.x1 = Math.max(vb.x1, 0);
            vb.y1 = Math.max(vb.y1, 0);
            vb.x2 = Math.min(vb.x2, width);
            vb.y2 = Math.min(vb.y2, height);

            switch (p) {
                case 'nw':
                    vb.x1 = Math.min(vb.x1, vb.x2 - size);
                    vb.y1 = Math.min(vb.y1, vb.y2 - size);
                    break;
                case 'n':
                    vb.y1 = Math.min(vb.y1, vb.y2 - size);
                    break;
                case 'ne':
                    vb.y1 = Math.min(vb.y1, vb.y2 - size);
                    vb.x2 = Math.max(vb.x2, vb.x1 + size);
                    break;
                case 'e':
                    vb.x2 = Math.max(vb.x2, vb.x1 + size);
                    break;
                case 'se':
                    vb.x2 = Math.max(vb.x2, vb.x1 + size);
                    vb.y2 = Math.max(vb.y2, vb.y1 + size);
                    break;
                case 's':
                    vb.y2 = Math.max(vb.y2, vb.y1 + size);
                    break;
                case 'sw':
                    vb.x1 = Math.min(vb.x1, vb.x2 - size);
                    vb.y2 = Math.max(vb.y2, vb.y1 + size);
                    break;
                case 'w':
                    vb.x1 = Math.min(vb.x1, vb.x2 - size);
                    break;
            }
        },

        cropImageHandler: function cropImageHandler(e) {
            var me = this,
                cfg = this.cropImageCfg,
                id = e.target.id,
                controlId = id.replace(me.id + '-crop-control-', '');

            function keepAspect(vb1, vb2) {
                var w1 = vb1.x2 - vb1.x1,
                    h1 = vb1.y2 - vb1.y1,
                    w2 = vb2.x2 - vb2.x1,
                    h2 = vb2.y2 - vb2.y1,
                    aspect = Math.max(w2 / w1, h2 / h1);
                w2 = w1 * aspect;
                h2 = h1 * aspect;
                return {
                    dx: w1 - w2,
                    dy: h1 - h2
                };
            }

            switch (controlId) {
                case 'nw':
                    cfg.modifyViewBox = function nw(vb, dx, dy) {
                        var box = DPO.mixin({}, vb);
                        box.x1 += dx;
                        box.y1 += dy;

                        var o = keepAspect(vb, box);
                        vb.x1 += o.dx;
                        vb.y1 += o.dy;
                    };
                    break;
                case 'n':
                    cfg.modifyViewBox = function nw(vb, dx, dy) {
                        vb.y1 += dy;
                    };
                    break;
                case 'ne':
                    cfg.modifyViewBox = function nw(vb, dx, dy) {
                        var box = DPO.mixin({}, vb);
                        box.x2 += dx;
                        box.y1 += dy;

                        var o = keepAspect(vb, box);
                        vb.x2 -= o.dx;
                        vb.y1 += o.dy;
                    };
                    break;
                case 'e':
                    cfg.modifyViewBox = function nw(vb, dx) {
                        vb.x2 += dx;
                    };
                    break;
                case 'se':
                    cfg.modifyViewBox = function nw(vb, dx, dy) {
                        var box = DPO.mixin({}, vb);
                        box.x2 += dx;
                        box.y2 += dy;

                        var o = keepAspect(vb, box);
                        vb.x2 -= o.dx;
                        vb.y2 -= o.dy;
                    };
                    break;
                case 's':
                    cfg.modifyViewBox = function nw(vb, dx, dy) {
                        vb.y2 += dy;
                    };
                    break;
                case 'sw':
                    cfg.modifyViewBox = function nw(vb, dx, dy) {
                        var box = DPO.mixin({}, vb);
                        box.x1 += dx;
                        box.y2 += dy;

                        var o = keepAspect(vb, box);
                        vb.x1 += o.dx;
                        vb.y2 -= o.dy;
                    };
                    break;
                case 'w':
                    cfg.modifyViewBox = function nw(vb, dx) {
                        vb.x1 += dx;
                    };
                    break;
                default:
                    return false;
            }

            cfg.sizingPoint = controlId;
            me.startImageCropping(e);
            return true;
        },

        calculateCropControlsPositions: function calculateCropControlsPositions(line) {
            var cfg = this.cropImageCfg,
                vb = cfg.viewBox,
                x1 = vb.x1,
                y1 = vb.y1,
                x2 = vb.x2,
                y2 = vb.y2,
                cx = (x1 + x2) / 2,
                cy = (y1 + y2) / 2,
                l1 = line,
                l2 = l1 * 2,
                d = {
                    nw: {x: x1, y: y1},
                    n: {x: cx, y: y1},
                    ne: {x: x2, y: y1},
                    e: {x: x2, y: cy},
                    se: {x: x2, y: y2},
                    s: {x: cx, y: y2},
                    sw: {x: x1, y: y2},
                    w: {x: x1, y: cy}
                };
            cfg.points = d;
            cfg.lines = {
                nw: [d.nw.x, d.nw.y + l2, d.nw.x, d.nw.y, d.nw.x + l2, d.nw.y],
                n: [d.n.x - l1, d.n.y, d.n.x + l1, d.n.y],
                ne: [d.ne.x - l2, d.ne.y, d.ne.x, d.ne.y, d.ne.x, d.ne.y + l2],
                e: [d.e.x, d.e.y - l1, d.e.x, d.e.y + l1],
                se: [d.se.x, d.se.y - l2, d.se.x, d.se.y, d.se.x - l2, d.se.y],
                s: [d.s.x - l1, d.s.y, d.s.x + l1, d.s.y],
                sw: [d.sw.x + l2, d.sw.y, d.sw.x, d.sw.y, d.sw.x, d.sw.y - l2],
                w: [d.w.x, d.w.y - l1, d.w.x, d.w.y + l1]
            };
        },

        renderCropControls: function renderCropControls() {
            var me = this,
                cfg = me.cropImageCfg,
                field = cfg.field;
            if (!field) {
                return;
            }

            var vb = cfg.viewBox,
                width = field.width / 20,
                height = field.height / 20,
                cropGroupId = me.id + '-crop-group',
                el = Snap('#' + cfg.fieldMarkupId),
                cropGroup = Snap('#' + cropGroupId),
                zoom = me.coordinateTransformer.getScale();
            if (!cropGroup) {
                cropGroup = el.g({id: cropGroupId});
            }

            me.calculateCropControlsPositions(7 / zoom);

            var p = Snap.format('M 0,0 L {w},0 L {w},{h} L 0,{h} z M {x1},{y1} L {x2},{y1} L {x2},{y2} L {x1},{y2} z', {
                w: width,
                h: height,
                x1: vb.x1,
                y1: vb.y1,
                x2: vb.x2,
                y2: vb.y2
            });

            if (!cfg.shadow) {
                cfg.shadow = cropGroup.path({
                    'id': me.id + '-crop-shadow',
                    'd': p
                });
            }

            cfg.shadow.attr({
                'd': p,
                'fill': 'black',
                'fill-opacity': 0.2,
                'fill-rule': 'evenodd',
                'stroke': 'none'
            });

            var controlAttr = {
                    'fill': 'none',
                    'stroke': '#426972',
                    'stroke-width': 3 / zoom,
                    'stroke-linejoin': 'miter'
                },
                keys = Object.keys(cfg.lines);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i],
                    control = cfg.controls[key];
                controlAttr.id = me.id + '-crop-control-' + key;
                controlAttr.cursor = key + '-resize';
                controlAttr.points = cfg.lines[key];
                controlAttr.caret = key + '-resize';
                if (control) {
                    control.attr(controlAttr);
                } else {
                    cfg.controls[key] = cropGroup.polyline(controlAttr);
                }
            }
        }
    });

    return CropImageTool;
});
DPO.def('render.PanTool', function () {
    /**
     * @mixin DPO.render.PanTool
     */
    var PanTool = {};
    DPO.mixin(PanTool, DPO.mixins.Observable, {
        workingArea: null,

        panMode: function enablePanTool(enabled) {
            var me = this;
            if (enabled === undefined) {
                return me.panEnabled;
            }

            me.panEnabled = enabled;
            me.workingArea.setAttribute('class', enabled ? 'pan-enabled' : '');
            return me.panEnabled;
        },

        startPan: function startPan(x, y) {
            var me = this;
            me.panOrigin = {
                x: x,
                y: y
            };

            me.workingArea.setAttribute('class', 'pan-enabled panning');
            Snap.mousemove(me.panMouseMoveListener).mouseup(me.panMouseUpListener);
        },

        endPan: function startPan() {
            var me = this;
            me.workingArea.setAttribute('class', 'pan-enabled');
            Snap.unmousemove(me.panMouseMoveListener).unmouseup(me.panMouseUpListener);
        },

        onPanMouseMove: function onPanMouseMove(e) {
            var me = this,
                p = me.panOrigin;
            me.workingArea.scrollLeft += p.x - e.screenX;
            me.workingArea.scrollTop += p.y - e.screenY;
            me.panOrigin = {
                x: e.screenX,
                y: e.screenY
            };
        },

        onPanMouseUp: function onPanMouseUp() {
            this.endPan();
        }
    });

    return PanTool;
});
DPO.def('render.SelectionTool', function () {
    /**
     * Provides API for fields selections functionality.
     * @memberof DPO.render
     * @mixin DPO.render.SelectionTool
     */
    var SelectionTool = {};

    DPO.mixin(SelectionTool, DPO.mixins.Observable, {
        selectFieldsInRect: function selectFieldsInRect(x, y, width, height) {
            var me = this,
                m = me.coordinateTransformer.clientToCanvasMatrix(),
                x1 = m.x(x, y) * 20,
                y1 = m.y(x, y) * 20,
                x2 = m.x(x + width, y + height) * 20,
                y2 = m.y(x + width, y + height) * 20,
                array = me.editor.getVisibleFields(me.editor.panel),
                selector = me.context.selector,
                fields = [],
                i, f;

            for (i = 0; i < array.length; i++) {
                f = array[i];
                if (selector.isFieldInsideBox(f, x1, y1, x2 - x1, y2 - y1)) {
                    fields.push(f);
                }
            }

            for (i = fields.length - 1; i >= 0; i--) {
                f = fields[i];
                if (!f.movable || !f.editable) {
                    fields.splice(i, 1);
                }
            }

            if (fields.length > 1) {
                for (i = fields.length - 1; i >= 0; i--) {
                    f = fields[i];
                    if (f instanceof DPO.model.Background) {
                        fields.splice(i, 1);
                    }
                }
            }

            me.selectFields(fields, false);
        },

        startSelection: function startSelection(x, y) {
            var me = this;
            me.selectionBounds = {
                x1: x,
                y1: y,
                x2: x,
                y2: y
            };
            me.selectionRect.attr({
                x: x,
                y: y,
                width: 1,
                height: 1,
                display: 'inline'
            });
            Snap.mousemove(me.selectionMouseMoveListener).mouseup(me.selectionMouseUpListener);
        },

        stopSelection: function stopSelection() {
            var me = this,
                b = me.selectionBounds,
                x1 = Math.min(b.x1, b.x2),
                y1 = Math.min(b.y1, b.y2),
                x2 = Math.max(b.x1, b.x2),
                y2 = Math.max(b.y1, b.y2);
            me.selectFieldsInRect(x1, y1, x2 - x1, y2 - y1);
            me.selectionRect.attr({display: 'none'});
            Snap.unmousemove(me.selectionMouseMoveListener).unmouseup(me.selectionMouseUpListener);
        },

        onSelectionMouseMove: function onSelectionMouseMove(e) {
            if (!this.isInsideRoot(e.target)) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            var me = this,
                offset = me.coordinateTransformer.getMouseOffset(e),
                b = me.selectionBounds;
            b.x2 = offset.x;
            b.y2 = offset.y;

            var x1 = Math.min(b.x1, b.x2),
                y1 = Math.min(b.y1, b.y2),
                x2 = Math.max(b.x1, b.x2),
                y2 = Math.max(b.y1, b.y2);
            me.selectionRect.attr({
                x: x1,
                y: y1,
                width: x2 - x1,
                height: y2 - y1
            });
        },

        onSelectionMouseUp: function onSelectionMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();

            this.stopSelection();
            this.triggerContextMenu(e);
        }
    });

    return SelectionTool;
});
DPO.def('render.MouseTransformTool', function () {
    /**
     * @class DPO.render.MouseEventChain
     * @param {object} scope
     * @param {function} fn
     * @param {DPO.render.MouseEventChain} [next]
     * @constructor
     */
    function MouseEventChain(scope, fn, next) {
        this.scope = scope;
        this.fn = fn;
        this.next = next;
    }

    DPO.mixin(MouseEventChain.prototype, {
        /**
         * @memberof MouseEventChain#
         * @returns {boolean}
         */
        handleEvent: function handleEvent() {
            var me = this,
                processed = me.fn.apply(me.scope, arguments);
            if (!processed && me.next) {
                return me.next.handleEvent.apply(me.next, arguments);
            }

            return processed;
        }
    });

    var supportedMimeTypes = {
        'application/dpo8.mail-merge-field-id': 0,
        'application/dpo8.serial-number-id': 0,
        'application/dpo8.svg-path': 0,
        'text/plain': 1,
        'text/uri-list': 2, //Edge
        'Text': 100 // IE support Text only
    };

    function mimeTypeFilter(mimeType) {
        return supportedMimeTypes[mimeType] !== undefined;
    }

    function mimeTypeSorter(a, b) {
        var pa = supportedMimeTypes[a];
        var pb = supportedMimeTypes[b];
        return pa - pb;
    }

    function prepareMimeTypes(event) {
        var types = event.dataTransfer.types,
            mimeTypes = [];
        for (var i = 0; i < types.length; i++) {
            mimeTypes.push(types[i]);
        }

        return mimeTypes.filter(mimeTypeFilter).sort(mimeTypeSorter);
    }

    /**
     * @class DPO.render.MouseTransformTool
     * @extends DPO.render.BaseTransformTool
     * @extends DPO.render.TextTransformTool
     * @property {boolean} disabled
     * @constructor
     */
    function MouseTransformTool(cfg) {
        var me = this;
        DPO.render.BaseTransformTool.call(this);
        DPO.mixin(this, cfg);

        me.id = DPO.id();
        me.displayOutlines = false;

        me.noopHandlerLink = new MouseEventChain(me, DPO.emptyFn, null);
        me.defaultHandlerLink = new MouseEventChain(me, me.defaultHandler, null);
        me.selectionHandlerLink = new MouseEventChain(me, me.selectionHandler, me.defaultHandlerLink);
        me.cropImageHandlerLink = new MouseEventChain(me, me.cropImageHandler, me.selectionHandlerLink);
        me.transformHandlerLink = new MouseEventChain(me, me.transformHandler, me.cropImageHandlerLink);
        me.labelClickHandlerLink = new MouseEventChain(me, me.labelClickHandler, me.transformHandlerLink);
        me.panHandlerLink = new MouseEventChain(me, me.handlePanHandler, me.labelClickHandlerLink);
        me.pickCoordidatesHandlerLink = new MouseEventChain(me, me.pickCoordinatesHandler, me.panHandlerLink);
        me.handlerChain = me.panHandlerLink;
        me.clickState = {};

        me.mouseDownListener = function mouseDownListener(event, x, y) {
            if (!event.altKey && !event.ctrlKey && !event.metaKey) {
                event.preventDefault();
                me.handlerChain.handleEvent(event, x, y);
            }
        };

        me.selectionMouseMoveListener = me.onSelectionMouseMove.bind(me);
        me.selectionMouseUpListener = me.onSelectionMouseUp.bind(me);

        me.translationMouseMoveListener = me.onTranslationMouseMove.bind(me);
        me.translationMouseUpListener = me.onTranslationMouseUp.bind(me);

        me.rotationMouseMoveListener = me.onRotationMouseMove.bind(me);
        me.rotationMouseUpListener = me.onRotationMouseUp.bind(me);

        me.resizeMouseMoveListener = me.onResizeMouseMove.bind(me);
        me.resizeMouseUpListener = me.onResizeMouseUp.bind(me);

        me.panMouseMoveListener = me.onPanMouseMove.bind(me);
        me.panMouseUpListener = me.onPanMouseUp.bind(me);

        me.contextMenuListener = me.onContextMenu.bind(me);
        me.dragOverListener = me.onDragOver.bind(me);
        me.dropListener = me.onDrop.bind(me);

        me.projectTransformer.on('changed:field:geometry', me.onFieldsGeometryChanged, me);
        me.projectTransformer.on('broke:reference', me.onBrokeReference, me);

        me.transformInfo = null;
        me.root.mousedown(me.mouseDownListener);
        me.root.node.addEventListener('contextmenu', me.contextMenuListener, true);
        me.root.node.addEventListener('dragover', me.dragOverListener);
        me.root.node.addEventListener('drop', me.dropListener);
        me.clearCharCache();
        me.render();

        me.initCropImageTool();
        me.initTextTransformTool(me.editor.el);
        me.editor.on('changed:zoom', me.onZoomChanged, me);
        me.onZoomChanged(me.editor, me.editor.zoom);
    }

    DPO.inherit(MouseTransformTool, DPO.render.BaseTransformTool);

    DPO.mixin(MouseTransformTool.prototype,
        DPO.render.TextTransformTool,
        DPO.render.CropImageTool,
        DPO.render.PanTool,
        DPO.render.SelectionTool
    );

    DPO.mixin(MouseTransformTool.prototype, {
        snapStep: 0,
        snapToEdgeEnabled: false,
        disableDoubleClick: false,

        selectNextField: function selectNextField() {
            var me = this,
                panel = me.editor.panel,
                selector = me.editor.context.selector,
                order = selector.getFieldOrder(panel),
                fields = order.getFields(),
                currentField = me.selectedFields[0];
            if (fields.length < 2) {
                return;
            }

            DPO.stableSort(/** @type Array*/fields, function (a, b) {
                var r1 = new DPO.math.Rect(a.position.x, 0, a.position.x + a.width, 10),
                    r2 = new DPO.math.Rect(b.position.x, 0, b.position.x + b.width, 10),
                    rect = r1.intersection(r2);
                if (rect && (rect.width === a.width || rect.width === b.width)) {
                    return 0;
                }

                return r1.x1 - r2.x1;
            });

            DPO.stableSort(/** @type Array*/fields, function (a, b) {
                var r1 = new DPO.math.Rect(0, a.position.y, 10, a.position.y + a.height),
                    r2 = new DPO.math.Rect(0, b.position.y, 10, b.position.y + b.height),
                    rect = r1.intersection(r2);
                if (rect && (rect.height === a.height || rect.height === b.height)) {
                    return 0;
                }

                return r1.y2 - r2.y2;
            });

            currentField = currentField || fields[fields.length - 1];

            var textEdit = !!me.textEditCfg.textEditor,
                index = fields.indexOf(currentField),
                i = (index + 1) % fields.length;
            currentField = fields[i];

            for (; textEdit && i !== index; i = (i + 1) % fields.length) {
                var f = fields[i];
                if ((f instanceof DPO.model.TextBlock) && textEdit) {
                    currentField = f;
                    break;
                }
            }

            me.editTextBlock(null);
            me.cropImage(null);
            me.selectFields([currentField]);
            if (textEdit && currentField.editable && currentField instanceof DPO.model.TextBlock) {
                me.editTextBlock(currentField);
                me.selectAllText();
            }
            me.editor.navigateToFields([currentField], true);
        },

        firePositionChanged: function firePositionChanged() {
            this.$super.firePositionChanged.call(this);
            this.updateFieldsBounds();
        },

        fireSizeChanged: function fireSizeChanged() {
            this.$super.fireSizeChanged.call(this);
            this.updateFieldsBounds();
        },

        onBrokeReference: function onBrokeReference(panel, changes) {
            var me = this,
                selected = me.selectedFields;
            for (var i = 0; i < changes.length; i++) {
                var c = changes[i];
                for (var j = 0; j < selected.length; j++) {
                    selected[j] = c.masterField === selected[j] ? c.panelField : selected[j];
                }
            }

            me.selectedFields = selected;
            me.updateFieldsBounds();
        },

        onFieldsGeometryChanged: function onFieldGeometryChanged() {
            this.updateFieldsBounds();
            if (!this.transforming) {
                this.rebuildTrackingTool();
            }
        },

        getFieldEl: function getFieldEl(el) {
            var me = this,
                root = me.root.node;
            while (el && el !== root) {
                if (me.editor.isField.test(el.id)) {
                    return el;
                }
                el = el.parentElement || /* istanbul ignore next */ el.parentNode;
            }

            return null;
        },

        /**
         * Check if node is inside root element
         * @memberof DPO.render.MouseTransformTool#
         * @param {Node|EventTarget} target
         * @returns {boolean}
         */
        isInsideRoot: function isInsideRoot(target) {
            var root = this.root.node;
            while (target != null && target !== root) {
                target = target.parentNode;
            }
            return target === root;
        },

        onZoomChanged: function onZoomChanged(editor, zoom) {
            var me = this,
                cfg = me.textEditCfg,
                circleAttributes = {
                    'r': 4 / zoom,
                    'stroke-width': 0.5 / zoom
                };
            me.trackingPolygon.attr({
                'stroke-width': 1 / zoom,
                'stroke-dasharray': cfg.textEditor ? 5 / zoom + ',' + 5 / zoom : '100%,0%'
            });
            me.dragPolygon.attr({
                'stroke-width': 13 / zoom
            });
            me.rotationLine.attr({
                'stroke-width': 1 / zoom
            });

            me.el.selectAll('#' + me.id + '-bounds-group > *').attr({
                'stroke-width': 1 / zoom
            });

            for (var i = 0; i < me.resizers.length; i++) {
                me.resizers[i].attr(circleAttributes);
            }

            var ti = this.transformInfo;
            if (ti) {
                me.updateResizeControl();
                me.updateRotationControl();

                me.rotationLine.attr(ti.rotationLine);
            }

            me.renderCropControls();
        },

        getFieldsForOutlinesDisplaying: function getFieldsForOutlinesDisplaying() {
            var me = this,
                fields = [].concat(me.selectedFields),
                array, i, f;
            if (!me.displayOutlines) {
                return fields;
            }

            array = me.editor.getVisibleFields(me.editor.panel);
            for (i = 0; i < array.length; i++) {
                f = array[i];
                if (f instanceof DPO.model.TextBlock) {
                    fields.push(f);
                }
            }

            return fields;
        },

        updateFieldsBounds: function updateFieldsBounds() {
            var me = this,
                zoom = this.editor.zoom,
                fields = me.getFieldsForOutlinesDisplaying(),
                outerStyle = {},
                innerStyle = {},
                i, ids = [];

            for (i = 0; i < fields.length; i++) {
                var f = fields[i],
                    markup = me.editor.boundsMarkup(f, outerStyle, innerStyle),
                    el = me.boundsGroup.select('#' + markup.geometry.id);
                ids.push(markup.geometry.id);
                if (el) {
                    me.boundsGroup.dpoUpdate(markup);
                } else {
                    me.boundsGroup.dpoRender(markup);
                }
            }

            me.el.selectAll('#' + me.id + '-bounds-group > *').forEach(function (item) {
                if (ids.indexOf(item.node.id) === -1) {
                    item.remove();
                } else {
                    item.attr({
                        'stroke-width': 1 / zoom
                    });
                }
            });
        },

        transformingEnabled: function transformingEnabled() {
            var enabled = true;
            for (var i = 0; i < this.selectedFields.length; i++) {
                var f = this.selectedFields[i];
                enabled = enabled && !(f instanceof DPO.model.Background);
            }

            return enabled;
        },

        updateTrackingTool: function updateTrackingTool() {
            var me = this,
                info = me.transformInfo;
            if (!info) {
                me.trackingGroup.attr({
                    display: 'none'
                });
                return;
            }

            var fields = me.selectedFields,
                singleField = fields.length === 1,
                movable = true,
                enabled = me.transformingEnabled(),
                i;
            for (i = 0; i < fields.length; i++) {
                var f = fields[i];
                movable = movable && f.movable;
            }

            enabled = enabled && movable;

            me.trackingGroup.attr({
                display: 'inline'
            });

            var normalized = (720 - info.rotation) % 360,
                q = Math.round(normalized / 15) * 15,
                d = Math.round(normalized / 45),
                cursors = [
                    ['nw-resize', 315, false],
                    ['n-resize', 0, false],
                    ['ne-resize', 45, false],
                    ['e-resize', 90, true],
                    ['se-resize', 135, true],
                    ['s-resize', 180, true],
                    ['sw-resize', 225, false],
                    ['w-resize', 270, false]
                ];
            for (i = 0; i < info.resizers.length; i++) {
                var c = info.resizers[i],
                    index = (d + i) % cursors.length,
                    deg = (cursors[i][1] + q) % 180,
                    resizer = me.resizers[i],
                    display = enabled;
                if (singleField && !movable) {
                    display = cursors[index][2];
                }

                resizer.attr({
                    display: display ? 'inline' : 'none',
                    cx: c.x,
                    cy: c.y,
                    cursor: cursors[index][0]
                });
                resizer.node.setAttribute('class', 'resize-control-' + deg);
            }

            info.rotationControl.display = enabled ? 'inline' : 'none';
            info.rotationLine.display = enabled ? 'inline' : 'none';

            me.updateRotationControl();
            me.rotationLine.attr(info.rotationLine);

            me.trackingPolygon.attr({
                points: info.points
            });

            me.dragPolygon.attr({
                display: enabled ? 'inline' : 'none',
                points: info.points
            });
        },

        updateRotationControl: function updateRotationControl() {
            if (this.disabled) {
                return;
            }
            var me = this,
                zoom = me.editor.zoom,
                info = me.transformInfo,
                r = 12.5,
                m = Snap.matrix();

            if (info) {
                m.scale(1 / zoom)
                    .translate(info.rotationControl.x * zoom - r, info.rotationControl.y * zoom - r)
                    .rotate(info.rotation, r, r);
                me.rotationControl.attr({
                    transform: m
                });
            }

            me.rotationControl.attr({
                'stroke-width': 1.5,
                'display': info.rotationControl.display
            });
        },

        transformDirections: function transformDirections(directions, matrix) {
            var result = {},
                keys = Object.keys(directions);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i],
                    point = directions[key];
                result[key] = {
                    x: matrix.x(point.x, point.y),
                    y: matrix.y(point.x, point.y)
                };
            }

            return result;
        },

        makeDirections: function makeDirections(x1, y1, x2, y2, rotation) {
            var cx = (x1 + x2) / 2,
                cy = (y1 + y2) / 2,
                m = Snap.matrix().rotate(360 - rotation, cx, cy),
                d = {
                    nw: {x: m.x(x1, y1), y: m.y(x1, y1)},
                    ne: {x: m.x(x2, y1), y: m.y(x2, y1)},
                    se: {x: m.x(x2, y2), y: m.y(x2, y2)},
                    sw: {x: m.x(x1, y2), y: m.y(x1, y2)}
                };
            d.n = {x: (d.nw.x + d.ne.x) / 2, y: (d.nw.y + d.ne.y) / 2};
            d.e = {x: (d.ne.x + d.se.x) / 2, y: (d.ne.y + d.se.y) / 2};
            d.s = {x: (d.se.x + d.sw.x) / 2, y: (d.se.y + d.sw.y) / 2};
            d.w = {x: (d.sw.x + d.nw.x) / 2, y: (d.sw.y + d.nw.y) / 2};
            return d;
        },

        updateResizeControl: function updateResizeControl() {
            var me = this,
                zoom = me.editor.zoom,
                info = me.transformInfo,
                d = info.directions,
                rad = Math.PI / 180 * (270 - info.rotation),
                r = Math.min(30 / zoom, 90),
                point = {
                    x: d.n.x + Math.cos(rad) * r,
                    y: d.n.y + Math.sin(rad) * r
                };
            info.rotationControl = DPO.mixin(info.rotationControl || {}, {
                x: point.x,
                y: point.y
            });
            info.rotationLine.x2 = point.x + Math.cos(rad) * -10 / zoom;
            info.rotationLine.y2 = point.y + Math.sin(rad) * -10 / zoom;
        },

        makeTransformInfoFromDirections: function makeTransformInfoFromDirections(d, rotation) {
            rotation = rotation == null ? this.transformInfo.rotation : rotation;

            var cx = (d.nw.x + d.se.x) / 2,
                cy = (d.nw.y + d.se.y) / 2;
            this.transformInfo = {
                rotation: rotation,
                center: {
                    x: cx,
                    y: cy
                },
                resizers: [d.nw, d.n, d.ne, d.e, d.se, d.s, d.sw, d.w],
                rotationLine: {
                    x1: d.n.x,
                    y1: d.n.y
                },
                directions: d,
                points: [d.nw.x, d.nw.y, d.ne.x, d.ne.y, d.se.x, d.se.y, d.sw.x, d.sw.y]
            };

            this.updateResizeControl();
        },

        /**
         * Returns selected fields bound in points
         * @memberof DPO.render.MouseTransformTool#
         * @param {boolean} [ignoreTransform]
         * @param {boolean} [renderBounds] If true returns render bounds; otherwise project bounds
         * @returns {{cx: number, cy: number, x: Number, y: Number, width: number, height: number, left: Number, right: Number, top: Number, bottom: Number}}
         */
        getFieldsBounds: function getFieldsBounds(ignoreTransform, renderBounds) {
            var me = this,
                pt = me.projectEditor,
                bounds = pt.selector.getBounds(me.selectedFields, ignoreTransform, renderBounds),
                keys = Object.keys(bounds);
            for (var i = 0; i < keys.length; i++) {
                bounds[keys[i]] /= 20;
            }
            return bounds;
        },

        /**
         * Rebuilds tracking tool for selected fields
         * @memberof DPO.render.MouseTransformTool#
         */
        rebuildTrackingTool: function rebuildTrackingTool() {
            if (this.disabled) {
                return;
            }

            var me = this,
                fields = me.selectedFields,
                singleField = fields.length === 1;
            if (!fields.length) {
                me.endRotation();
                me.stopTranslation();
                me.stopResizing();
                me.transformInfo = null;
                me.updateTrackingTool();
                return;
            }

            var b = me.getFieldsBounds(singleField, true),
                dx = 0, dy = 0;
            if (singleField) {
                var c = me.projectEditor.selector.getCenter(fields);
                dx = c.x / 20 - b.cx;
                dy = c.y / 20 - b.cy;
            }

            var d = me.makeDirections(
                b.left + dx,
                b.top + dy,
                b.right + dx,
                b.bottom + dy,
                singleField ? fields[0].rotation : 0);
            me.makeTransformInfoFromDirections(d, singleField ? fields[0].rotation : 0);
            me.updateTrackingTool();
        },

        /**
         * Updates all visual elements
         * @memberof DPO.render.MouseTransformTool#
         */
        update: function update() {
            if (!this.disabled) {
                this.updateFieldsBounds();
                this.rebuildTrackingTool();
            }
        },

        render: function render() {
            var me = this;
            me.boundsGroup = me.el.g().attr({id: me.id + '-bounds-group'});

            me.trackingGroup = me.el.g().attr({
                id: me.id + '-tracking-group',
                display: 'none'
            });
            me.trackingPolygon = me.trackingGroup.polygon(0, 0, 0, 0, 0, 0, 0, 0).attr({
                'id': me.id + '-tracking-polygon',
                'fill': 'none',
                'stroke': '#426972',
                'stroke-width': 1,
                'stroke-linejoin': 'miter'
            });
            me.dragPolygon = me.trackingGroup.polygon(0, 0, 0, 0, 0, 0, 0, 0).attr({
                'id': me.id + '-drag-polygon',
                'fill': 'none',
                'stroke': 'transparent',
                'stroke-width': 13,
                'stroke-linejoin': 'miter',
                'cursor': 'move'
            });

            me.rotationLine = me.trackingGroup.line(0, 0, 11, 11).attr({
                'stroke': '#426972',
                'stroke-width': 1
            });

            var circle = {
                    'cx': 0,
                    'cy': 0,
                    'r': 4,
                    'fill': '#FFFFFF',
                    'stroke': '#466B74',
                    'stroke-width': 1
                },
                g = me.trackingGroup;

            me.resizers = [
                g.circle(DPO.mixin({id: me.id + '-resizer-north-west'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-north'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-north-east'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-east'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-south-east'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-south'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-south-west'}, circle)),
                g.circle(DPO.mixin({id: me.id + '-resizer-west'}, circle))
            ];

            me.rotationControl = me.trackingGroup.path([
                'M1.5 10.5 C 3 -2 21 -2 23 10.5 C 21 -2 3 -2 1.5 10.5',
                'M23 14.5 C 21 26.5 3 26.5 1.5 14.5 C 3 26.5 21 26.5 23 14.5',
                'M1 11.5 L0.5 7.5 3.5 8.5 Z',
                'M12.25 9 A 3.5 3.5 0 1 0 12.3 9',
                'M23 14.5 L23.5 18.5 20 17.5 Z'
            ].join(' ')).attr({
                'id': me.id + '-rotation',
                'class': 'rotation-control',
                'fill': '#36a3dc',
                'stroke': '#36a3dc',
                'stroke-width': 3
            });

            me.selectionRect = me.root.rect(0, 0, 0, 0).attr({
                'id': me.id + '-selection-rect',
                'fill': '#1a4c6e',
                'fill-opacity': 0.1,
                'stroke': '#1a4c6e',
                'display': 'none'
            });
        },

        triggerContextMenu: function triggerContextMenu(originalEvent) {
            if (originalEvent.button !== 2) {
                return;
            }

            var evt = document.createEvent('MouseEvent');
            //noinspection JSDeprecatedSymbols
            evt.initMouseEvent('contextmenu', true, false, window,
                1, originalEvent.screenX, originalEvent.screenY,
                originalEvent.clientX, originalEvent.clientY,
                false, false, false, false, originalEvent.button,
                this.editor.el);

            this.editor.el.dispatchEvent(evt);
        },

        onContextMenu: function onContextMenu(e) {
            e.preventDefault();
            e.stopPropagation();
        },

        onPlainTextDrop: function onPlainTextDrop(event, text) {
            var me = this,
                cfg = me.textEditCfg,
                textEditor = cfg.textEditor,
                offset = me.coordinateTransformer.getMouseOffset(event),
                pos = me.getTextSelectionPosition(textEditor.textBlock, offset.x, offset.y),
                index = textEditor.combinePosition(pos.paragraphIndex, pos.charIndex),
                protoSpan = textEditor.getSpans(index, index)[0],
                protoParagraph = textEditor.textBlock.text.textFlow.paragraphs[pos.paragraphIndex],
                introspector = new DPO.model.Introspector(),
                lines = text.split('\n'),
                paragraphs = [];
            for (var i = 1; i < lines.length; i++) {
                var p = introspector.clone(protoParagraph),
                    span = introspector.clone(protoSpan);
                span.value = lines[i];
                p.spans = [span];
                paragraphs.push(p);
            }
            textEditor.spliceText(index, 0, lines[0]);
            if (paragraphs.length > 0) {
                textEditor.insertParagraph(index + lines[0].length, 0, paragraphs);
            }
            cfg.textArea.focus();
        },

        createPlainTextBlock: function createPlainTextBlock(event, text) {
            var me = this,
                editor = this.editor,
                pt = editor.projectEditor,
                mp = editor.masterPanel,
                textDefaults = mp.textDefaults[0],
                textBlock = pt.createTextBlock(textDefaults),
                protoParagraph = textBlock.text.textFlow.paragraphs[0],
                protoSpan = protoParagraph.spans[0],
                lines = text.split('\n'),
                introspector = new DPO.model.Introspector(),
                paragraphs = [], i;
            for (i = 0; i < lines.length; i++) {
                var p = introspector.clone(protoParagraph),
                    span = introspector.clone(protoSpan);
                span.value = lines[i];
                p.spans = [span];
                paragraphs.push(p);
            }

            textBlock.text.textFlow.paragraphs = paragraphs;
            textBlock.height = Infinity;
            textBlock.width = Infinity;

            var containers = editor.context.layoutManager.layoutTextBlock(textBlock),
                h = 0,
                w = 0;
            for (i = 0; i < containers.length; i++) {
                var container = containers[i];
                h += container.height * 20;
                w += container.preferredWidth * 20 + protoSpan.fontSize * 40;
            }

            textBlock.height = h;
            textBlock.width = w;

            pt.beginUpdates();
            pt.addFieldToPanel(textBlock, editor.panel);
            editor.alignFieldToPos(textBlock, event.clientX, event.clientY, mp.width, mp.height);
            pt.endUpdates();

            me.selectFields([textBlock]);
            me.editTextBlock(textBlock);
        },

        onBindDataDrop: function onBindDataDrop(event, mailMergeField, serialNumberField) {
            var me = this,
                cfg = me.textEditCfg,
                textEditor = cfg.textEditor,
                offset = me.coordinateTransformer.getMouseOffset(event),
                pos = me.getTextSelectionPosition(textEditor.textBlock, offset.x, offset.y),
                index = textEditor.combinePosition(pos.paragraphIndex, pos.charIndex),
                protoSpan = textEditor.getSpans(index, index)[0],
                introspector = new DPO.model.Introspector(),
                fieldSpan = introspector.clone(protoSpan),
                spaceSpan1 = introspector.clone(protoSpan),
                spaceSpan2 = introspector.clone(protoSpan),
                spans = [spaceSpan1, fieldSpan, spaceSpan2];
            fieldSpan.value = '«' + mailMergeField + '»';

            delete fieldSpan.mailMergeField;
            delete spaceSpan1.mailMergeField;
            delete spaceSpan2.mailMergeField;
            delete fieldSpan.serialNumberField;
            delete spaceSpan1.serialNumberField;
            delete spaceSpan2.serialNumberField;

            if (mailMergeField) {
                fieldSpan.mailMergeField = mailMergeField;
            } else {
                fieldSpan.serialNumberField = serialNumberField;
            }

            spaceSpan1.value = ' ';
            spaceSpan2.value = ' ';

            me.context.binder.bindDataToSpans(spans, me.recordIndex);
            textEditor.insertSpans(index, spans);
            cfg.textArea.focus();
        },

        onCreateDataDrop: function onCreateDataDrop(event, mailMergeField, serialNumberField) {
            var me = this,
                editor = this.editor,
                pt = editor.projectEditor,
                mp = editor.masterPanel,
                textDefaults = mp.textDefaults[0],
                textBlock = pt.createTextBlock(textDefaults),
                p = textBlock.text.textFlow.paragraphs[0],
                span = p.spans[0];

            delete span.mailMergeField;
            delete span.serialNumberField;

            if (mailMergeField) {
                span.mailMergeField = mailMergeField;
            } else {
                span.serialNumberField = serialNumberField;
            }

            p.spans = [span];

            textBlock.height = Infinity;
            textBlock.width = Infinity;
            textBlock = editor.context.binder.bindDataToField(textBlock, me.recordIndex);

            var containers = editor.context.layoutManager.layoutTextBlock(textBlock),
                h = 0,
                w = 0;
            for (var i = 0; i < containers.length; i++) {
                var container = containers[i];
                h += container.height * 20;
                w += container.preferredWidth * 20 + span.fontSize * 40;
            }

            textBlock.height = h;
            textBlock.width = w;

            pt.beginUpdates();
            pt.addFieldToPanel(textBlock, editor.panel);
            editor.alignFieldToPos(textBlock, event.clientX, event.clientY, mp.width, mp.height);
            pt.endUpdates();

            me.selectFields([textBlock]);
            me.editTextBlock(textBlock);
        },

        onSvgPathDrop: function onSvgPathDrop(event, path) {
            var me = this,
                editor = me.editor;
            editor.createDrawing(path, event.clientX, event.clientY);
        },

        onDrop: function onDrop(event) {
            var me = this,
                handled = false,
                types = prepareMimeTypes(event);

            function handleMimeType(event, mimeType, data) {
                switch (mimeType) {
                    case 'application/dpo8.mail-merge-field-id':
                        if (me.textEditCfg.textEditor) {
                            me.onBindDataDrop(event, data, null);
                        } else {
                            me.onCreateDataDrop(event, data, null);
                        }
                        break;
                    case 'application/dpo8.serial-number-id':
                        if (me.textEditCfg.textEditor) {
                            me.onBindDataDrop(event, null, data);
                        } else {
                            me.onCreateDataDrop(event, null, data);
                        }
                        break;
                    case 'text/plain':
                        if (me.textEditCfg.textEditor) {
                            me.onPlainTextDrop(event, data);
                        } else {
                            me.createPlainTextBlock(event, data);
                        }
                        break;
                    case 'Text':
                    case 'text/uri-list':
                        var decoded = DPO.decodeDataURL(data);
                        if (decoded === null) {
                            handleMimeType(event, 'text/plain', data);
                        } else {
                            handleMimeType(event, decoded.mime, decoded.data);
                        }

                        break;
                    case 'application/dpo8.svg-path':
                        me.onSvgPathDrop(event, data);
                        break;
                    default:
                        return false;
                }

                return true;
            }

            for (var i = 0; !handled && i < types.length; i++) {
                var type = types[i],
                    data = event.dataTransfer.getData(type);
                handled = handleMimeType(event, type, data);
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        onDragOver: function onDragOver(event) {
            var me = this,
                types = prepareMimeTypes(event),
                canHandle = false;

            for (var i = 0; !canHandle && i < types.length; i++) {
                var type = types[i];
                switch (type) {
                    case 'application/dpo8.mail-merge-field-id':
                    case 'application/dpo8.serial-number-id':
                    case 'text/plain':
                    case 'Text':
                        var offset = me.coordinateTransformer.getMouseOffset(event),
                            field = me.editor.getFieldAtPos(offset.x, offset.y);

                        if (field && field instanceof DPO.model.TextBlock) {
                            me.selectFields([field]);
                            me.editTextBlock(field);

                            var textEditor = me.textEditCfg.textEditor,
                                pos = me.getTextSelectionPosition(textEditor.textBlock, offset.x, offset.y);
                            me.moveCaret(pos);
                        } else {
                            me.editTextBlock(null);
                            me.selectFields([]);
                        }
                        canHandle = true;
                        break;
                    case 'application/dpo8.svg-path':
                        me.editTextBlock(null);
                        me.selectFields([]);
                        canHandle = true;
                        break;
                }
            }

            if (canHandle) {
                event.preventDefault();
                event.stopPropagation();
                event.dataTransfer.dropEffect = 'copy';
            } else {
                me.editTextBlock(null);
                me.selectFields([]);
            }
        },

        handlePanHandler: function handlePanHandler(e) {
            var me = this;
            if (me.panEnabled) {
                me.startPan(e.screenX, e.screenY);
            }

            return me.panEnabled;
        },

        transformHandler: function transformHandler(e) {
            var me = this,
                offset = me.coordinateTransformer.getMouseOffset(e),
                id = e.target.id,
                controlId = id.replace(me.id + '-', '');

            switch (controlId) {
                case 'drag-polygon':
                    me.startTranslation(offset.x, offset.y, null);
                    return true;
                case 'rotation':
                    me.startRotation(offset.x, offset.y);
                    return true;
                case 'resizer-north-west':
                case 'resizer-north':
                case 'resizer-north-east':
                case 'resizer-east':
                case 'resizer-south-east':
                case 'resizer-south':
                case 'resizer-south-west':
                case 'resizer-west':
                    me.startResizing(Snap(e.target), controlId.replace('resizer-', ''), offset.x, offset.y, e.shiftKey);
                    return true;
            }

            return false;
        },

        selectionHandler: function selectionHandler(e) {
            var me = this,
                offset = me.coordinateTransformer.getMouseOffset(e),
                field = me.editor.getFieldAtPos(offset.x, offset.y),
                fieldEl = me.getFieldEl(e.target);

            if (!fieldEl && !field) {
                if (!e.shiftKey) {
                    me.selectFields([]);
                }
                me.editTextBlock(null);
                me.cropImage(null);
                me.startSelection(offset.x, offset.y);
                return true;
            }

            if (e.shiftKey || e.ctrlKey) {
                me.selectFields([field], true);
                if (me.transformingEnabled()) {
                    me.startTranslation(offset.x, offset.y);
                }
                return true;
            }

            return false;
        },

        pickCoordinates: function pickCoordinates() {
            this.handlerChain = this.pickCoordidatesHandlerLink;
        },

        resetHandlerChain: function resetHandlerChain() {
            this.handlerChain = this.panHandlerLink;
        },

        pickCoordinatesHandler: function pickCoordinatesHandler(e) {
            var me = this,
                offset = me.coordinateTransformer.getMouseOffset(e),
                fieldEl = me.getFieldEl(e.target),
                matrix = me.editor.clientToCanvasMatrix(),
                canvasX = matrix.x(offset.x, offset.y),
                canvasY = matrix.y(offset.x, offset.y),
                field = null,
                fieldX = null,
                fieldY = null,
                canvasToFieldMatrix;
            if (fieldEl) {
                var markupId = fieldEl.id;
                field = me.editor.getFieldByMarkupId(markupId);
                canvasToFieldMatrix = me.editor.canvasToFieldMatrix(field);
                fieldX = canvasToFieldMatrix.x(canvasX, canvasY);
                fieldY = canvasToFieldMatrix.y(canvasX, canvasY);
            }

            me.handlerChain = me.panHandlerLink;
            me.fire('coordinates:picked', [me, {
                canvasX: canvasX,
                canvasY: canvasY,
                field: field,
                fieldX: fieldX,
                fieldY: fieldY
            }]);

            e.stopPropagation();
            e.preventDefault();
            return true;
        },

        processDoubleClickState: function processDoubleClick(first, second) {
            var me = this,
                field = first.field,
                p1 = first.offset,
                p2 = second.offset,
                d = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            if (!field.editable) {
                return false;
            }

            if (me.selectedFields.length !== 1 || field !== second.field || d > 5 || me.disableDoubleClick) {
                return false;
            }

            var ctx = me.editor.context,
                panelIndex = ctx.selector.panelIndex(me.editor.panel),
                index, pos, textEditor;

            switch (field.constructor) {
                case DPO.model.Drawing:
                    me.fire('double-click:drawing', [me, field]);
                    return true;
                case DPO.model.TextPath:
                case DPO.model.TextBlock:
                    pos = me.getTextSelectionPosition(field, p2.x, p2.y);
                    textEditor = new DPO.text.Editor(field, panelIndex, ctx);
                    index = textEditor.combinePosition(pos.paragraphIndex, pos.charIndex);
                    textEditor.destroy();
                    me.editTextBlock(field);
                    me.selectWordAtIndex(index);
                    me.fire('double-click:text-block', [me, field, index]);
                    return true;
                case DPO.model.Image:
                    me.fire('double-click:image', [me, field]);
                    return true;
                case DPO.model.Barcode:
                    me.fire('double-click:barcode', [me, field]);
                    return true;
                case DPO.model.Background:
                    me.fire('double-click:background', [me, field]);
                    return true;
                default:
                    return false;
            }
        },

        labelClickHandler: function labelClickHandler(e) {
            var me = this,
                el = e.target,
                regex = /-(safe|bleed)-label-warning$/,
                id, result;
            while (el != null && !result) {
                id = el.id || '';
                result = regex.exec(id);
                el = el.parentElement;
            }

            var label = result && result[1] || '';
            switch (label) {
                case 'bleed':
                case 'safe':
                    me.fire('click:label', [me, label]);
                    return true;
            }
            return false;
        },

        defaultHandler: function defaultHandler(e) {
            var me = this,
                offset = me.coordinateTransformer.getMouseOffset(e),
                field = me.editor.getFieldAtPos(offset.x, offset.y);
            if (!field) {
                return false;
            }

            me.cropImage(null);

            var skipSelection = !field.editable;
            if (field instanceof DPO.model.TextBlock) {
                skipSelection = skipSelection || !field.movable && !field.editable;
            } else {
                skipSelection = skipSelection || !field.movable;
            }

            if (skipSelection) {
                return false;
            }

            if (me.doubleClickState) {
                var dt = new Date() - me.doubleClickState.clickTimestamp;
                if (dt > 300) {
                    me.doubleClickState = null;
                }
            }

            if (me.doubleClickState) {
                var processed = me.processDoubleClickState(me.doubleClickState, {
                    offset: offset,
                    field: field
                });
                me.doubleClickState = null;
                if (processed) {
                    return true;
                }
            }

            me.doubleClickState = {
                clickTimestamp: +new Date(),
                offset: offset,
                field: field
            };

            me.selectFields([field]);
            if (field instanceof DPO.model.TextBlock && field.editable) {
                me.editTextBlock(field);
                me.startTextSelection(offset);

                // To not allow text area to handle this event
                e.preventDefault();
                e.stopPropagation();
                return true;
            }

            if (me.transformingEnabled()) {
                me.startTranslation(offset.x, offset.y, null);
            } else {
                me.triggerContextMenu(e);
            }

            return true;
        },

        onBeginTextEditing: function onBeginTextEditing() {
            this.onZoomChanged(this.editor, this.editor.zoom);
        },

        onEndTextEditing: function onEndTextEditing() {
            this.onZoomChanged(this.editor, this.editor.zoom);
        },

        adjustTextBlockHeight: function adjustTextBlockHeight() {
            var me = this;
            DPO.render.TextTransformTool.adjustTextBlockHeight.apply(me, arguments);
            me.rebuildTrackingTool();
            me.updateFieldsBounds();
        },

        destroy: function destroy() {
            var me = this;
            me.resetObservable();
            me.cropImage(null);
            me.destroyTextTransformTool();

            if (me.projectTransformer) {
                me.projectTransformer.un('changed:field:geometry', me.onFieldsGeometryChanged, me);
                me.projectTransformer.un('broke:reference', me.onBrokeReference, me);
                me.projectTransformer = null;
            }

            if (me.root) {
                me.boundsGroup.remove();
                me.trackingGroup.remove();
                me.workingArea = null;
                me.editor.un('changed:zoom', me.onZoomChanged, me);
                me.editor = null;
                me.root.node.removeEventListener('contextmenu', me.contextMenuListener, true);
                me.root.node.removeEventListener('dragover', me.dragOverListener);
                me.root.node.removeEventListener('drop', me.dropListener);
                me.root.unmousedown(me.mouseDownListener);
                me.root = null;
            }

            me.defaultHandlerLink = null;
            me.selectionHandlerLink = null;
            me.transformHandlerLink = null;
            me.panHandlerLink = null;
            me.handlerChain = null;

            Snap.unmousemove(me.translationMouseMoveListener)
                .unmouseup(me.translationMouseUpListener)
                .unmousemove(me.selectionMouseMoveListener)
                .unmouseup(me.selectionMouseUpListener)
                .unmousemove(me.rotationMouseMoveListener)
                .unmouseup(me.rotationMouseUpListener)
                .unmousemove(me.resizeMouseMoveListener)
                .unmouseup(me.resizeMouseUpListener);
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Element Resizing
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(MouseTransformTool.prototype, {
        shouldKeepAspectRatio: function shouldKeepAspectRatio() {
            var keep = this.selectedFields.length > 1, field;
            for (var i = 0; i < this.selectedFields.length; i++) {
                field = this.selectedFields[i];
                keep = keep || field instanceof DPO.model.Barcode;
            }

            return keep;
        },

        calculateMinSize: function calculateMinSize() {
            //var me = this,
            //    minWidth = Infinity,
            //    minHeight = Infinity,
            //    fields = me.selectedFields,
            //    ctx = me.context,
            //    lm = ctx.layoutManager,
            //    g;
            //for (var i = 0; i < fields.length; i++) {
            //    var f = fields[i];
            //    switch (f.constructor) {
            //        case DPO.model.TextBlock:
            //            if (f.textStyle.overflow.indexOf('wrap') !== -1) {
            //                f = ctx.binder.bindDataToTextBlock(f, me.recordIndex);
            //                g = lm.calculateTextBlockGeometry(f);
            //                minHeight = Math.min(minHeight, g.height);
            //            }
            //            break;
            //    }
            //}
            return {
                minWidth: 10, //minWidth === Infinity ? 10 : minWidth,
                minHeight: 10 //minHeight === Infinity ? 10 : minHeight
            };
        },

        buildResizingConfig: function buildResizingConfig(direction, keepAspect) {
            var me = this,
                directions = me.transformInfo.directions,
                keepAspectRatio = keepAspect,
                multiplierX = 1,
                multiplierY = 1,
                quadrantAngle, basePoint, sizingPoint, anglePoint;
            switch (direction) {
                case 'north-west':
                    quadrantAngle = 270;
                    basePoint = directions.se;
                    sizingPoint = directions.nw;
                    anglePoint = directions.ne;
                    keepAspectRatio = true;
                    break;
                case 'north':
                    quadrantAngle = 270;
                    basePoint = directions.s;
                    sizingPoint = directions.n;
                    multiplierX = 0;
                    break;
                case 'north-east':
                    quadrantAngle = 0;
                    basePoint = directions.sw;
                    sizingPoint = directions.ne;
                    anglePoint = directions.se;
                    keepAspectRatio = true;
                    break;
                case 'east':
                    quadrantAngle = 0;
                    basePoint = directions.w;
                    sizingPoint = directions.e;
                    multiplierY = 0;
                    break;
                case 'south-east':
                    quadrantAngle = 90;
                    basePoint = directions.nw;
                    sizingPoint = directions.se;
                    anglePoint = directions.sw;
                    keepAspectRatio = true;
                    break;
                case 'south':
                    quadrantAngle = 90;
                    basePoint = directions.n;
                    sizingPoint = directions.s;
                    multiplierX = 0;
                    break;
                case 'south-west':
                    quadrantAngle = 180;
                    basePoint = directions.ne;
                    sizingPoint = directions.sw;
                    anglePoint = directions.nw;
                    keepAspectRatio = true;
                    break;
                case 'west':
                    quadrantAngle = 180;
                    basePoint = directions.e;
                    sizingPoint = directions.w;
                    multiplierY = 0;
                    break;
            }

            function distance(a, b) {
                return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
            }

            var width = distance(directions.ne, directions.nw),
                height = distance(directions.ne, directions.se);

            keepAspectRatio = keepAspectRatio || this.shouldKeepAspectRatio();
            return DPO.mixin({
                multiplierX: keepAspectRatio ? 1 : multiplierX,
                multiplierY: keepAspectRatio ? 1 : multiplierY,
                direction: direction,
                keepAspectRatio: keepAspectRatio,
                width: width,
                height: height,
                quadrantAngle: quadrantAngle,
                basePoint: basePoint,
                sizingPoint: sizingPoint,
                anglePoint: anglePoint || sizingPoint
            }, me.calculateMinSize());
        },

        startResizing: function startResizing(resizer, direction, x, y, keepAspect) {
            var me = this,
                cls = resizer.node.getAttribute('class');
            me.editTextBlock(null);
            me.cropImage(null);
            me.workingArea.style.caret = resizer.node.style.caret;
            me.beginTransforming();
            me.resizingConfig = me.buildResizingConfig(direction, keepAspect);
            me.startPoint = {x: x, y: y};
            me.workingArea.setAttribute('class', cls);
            Snap.mousemove(me.resizeMouseMoveListener).mouseup(me.resizeMouseUpListener);
        },

        stopResizing: function stopResizing() {
            var me = this,
                fields = me.selectedFields,
                update = false;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (f instanceof DPO.model.TextBlock) {
                    update = me.adjustTextBlockGeometry(f) || update;
                }
            }

            me.workingArea.style.caret = 'auto';
            me.endTransforming();
            me.workingArea.setAttribute('class', '');
            Snap.unmousemove(me.resizeMouseMoveListener).unmouseup(me.resizeMouseUpListener);
        },

        resizeField: function resizeField(sx, sy) {
            var me = this,
                cfg = me.resizingConfig,
                field = me.selectedFields[0];
            me.projectEditor.beginUpdates();
            me.projectEditor.scaleField(field, sx, sy, {
                x: cfg.basePoint.x * 20,
                y: cfg.basePoint.y * 20
            });
            me.projectEditor.endUpdates();
            me.fireSizeChanged();
        },

        /**
         * Resize selected fields by specified scale factors
         * @memberof DPO.render.MouseTransformTool#
         * @param {number} sx
         * @param {number} sy
         */
        resizeFields: function resizeFields(sx, sy) {
            var me = this,
                cfg = me.resizingConfig,
                bx = cfg.basePoint.x,
                by = cfg.basePoint.y;
            me.projectEditor.beginUpdates();
            me.projectEditor.scaleFields(me.selectedFields, sx, sy, {
                x: bx * 20,
                y: by * 20
            });
            me.projectEditor.endUpdates();
            me.fireSizeChanged();
        },

        /**
         * Handlers resize mouse move event
         * @memberof DPO.render.MouseTransformTool#
         * @param {Event} e
         */
        onResizeMouseMove: function onResizeMouseMove(e) {
            if (!this.isInsideRoot(e.target)) {
                return;
            }

            // Calculating mouse offset in screen coordinates
            var me = this,
                offset = me.coordinateTransformer.getMouseOffset(e),
                cfg = me.resizingConfig,
                startPoint = me.startPoint,
                dx = offset.x - startPoint.x,
                dy = offset.y - startPoint.y;

            // Converting mouse offset from screen coordinates to canvas coordinates
            var matrix = me.editor.clientToCanvasMatrix(true),
                x = matrix.x(dx, dy),
                y = matrix.y(dx, dy);

            // Absolute position in canvas coordinates
            var cursorX = cfg.sizingPoint.x + x,
                cursorY = cfg.sizingPoint.y + y;

            // We're working in canvas coordinates now
            // Distance between base point & cursor position
            var bx = cfg.basePoint.x,
                by = cfg.basePoint.y,
                hypotenuse = Math.sqrt(Math.pow(bx - cursorX, 2) + Math.pow(by - cursorY, 2));

            // Calculating rectangle's diagonal angle
            var angle = (Snap.angle(cfg.anglePoint.x, cfg.anglePoint.y, cursorX, cursorY, bx, by) + 360) % 360,
                diagonalAngle = cfg.quadrantAngle - angle,
                rad = Math.PI / 180 * diagonalAngle,
                offsetX = Math.cos(rad) * hypotenuse,
                offsetY = Math.sin(rad) * hypotenuse;

            // Apply constraint for minimal values
            offsetX = Math.max(Math.abs(offsetX), cfg.minWidth);
            offsetY = Math.max(Math.abs(offsetY), cfg.minHeight);

            // Correct offsets for aspect ratio if needed
            if (cfg.keepAspectRatio) {
                var ratio = Math.max(offsetX / cfg.width, offsetY / cfg.height);
                offsetX = cfg.width * ratio;
                offsetY = cfg.height * ratio;
            } else {
                offsetX = Math.abs(offsetX * cfg.multiplierX) || cfg.width;
                offsetY = Math.abs(offsetY * cfg.multiplierY) || cfg.height;
            }

            var sx = Math.abs(offsetX / cfg.width),
                sy = Math.abs(offsetY / cfg.height);

            cfg.width *= sx;
            cfg.height *= sy;

            if (me.selectedFields.length === 1) {
                me.resizeField(sx, sy);
            } else {
                me.resizeFields(sx, sy);
            }

            var m = Snap.matrix().scale(sx, sy, bx, by),
                unrotate = Snap.matrix().rotate(me.transformInfo.rotation, bx, by),
                rotate = Snap.matrix().rotate(-me.transformInfo.rotation, bx, by),
                d = me.transformInfo.directions;

            d = me.transformDirections(d, unrotate);
            d = me.transformDirections(d, m);
            d = me.transformDirections(d, rotate);

            me.makeTransformInfoFromDirections(d);
            me.updateTrackingTool();
        },

        onResizeMouseUp: function onResizeMouseUp() {
            this.stopResizing();
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Element Rotation
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(MouseTransformTool.prototype, {
        rotationStep: 5, // Degrees

        rotateTrackingTool: function rotateTrackingTool(deg, box) {
            if (this.disabled) {
                return;
            }
            var me = this;
            box = box || me.trackingPolygon.getBBox();
            var m = Snap.matrix().rotate(-deg, box.cx, box.cy),
                directions = me.transformInfo.directions;

            directions = me.transformDirections(directions, m);
            me.transformInfo.rotation += deg;

            me.makeTransformInfoFromDirections(directions);
            me.updateTrackingTool();
        },

        startRotation: function startRotation() {
            var me = this,
                startBox = me.rotationControl.node.getBoundingClientRect(),
                centerBox = me.trackingPolygon.node.getBoundingClientRect();
            me.editTextBlock(null);
            me.cropImage(null);
            me.rotationStart = {
                x: (startBox.left + startBox.right) / 2,
                y: (startBox.top + startBox.bottom) / 2
            };
            me.rotataionCenter = {
                x: (centerBox.left + centerBox.right) / 2,
                y: (centerBox.top + centerBox.bottom) / 2
            };
            me.rotataionPoint = me.trackingPolygon.getBBox();
            me.workingArea.setAttribute('class', 'rotation-control');
            me.beginTransforming();
            Snap.mousemove(me.rotationMouseMoveListener).mouseup(me.rotationMouseUpListener);
        },

        endRotation: function endRotation() {
            var me = this;
            me.endTransforming();
            me.workingArea.setAttribute('class', '');
            Snap.unmousemove(me.rotationMouseMoveListener).unmouseup(me.rotationMouseUpListener);
        },

        /**
         * Handlers rotation mouse move event
         * @memberof DPO.render.MouseTransformTool#
         * @param {Event} e
         */
        onRotationMouseMove: function onRotationMouseUp(e) {
            var me = this,
                rs = me.rotationStart,
                rc = me.rotataionCenter,
                rotation = Snap.angle(rs.x, rs.y, e.clientX, e.clientY, rc.x, rc.y);
            if (Math.abs(rotation) > me.rotationStep) {
                rotation = Math.round(rotation / me.rotationStep) * me.rotationStep;
            } else {
                return;
            }

            var box = me.rotataionPoint;
            me.projectEditor.beginUpdates();
            me.projectEditor.rotateField(me.selectedFields, rotation, {
                x: box.cx * 20,
                y: box.cy * 20
            });
            me.projectEditor.endUpdates();
            me.fire('fields:rotated', [me, me.selectedFields]);

            var center = me.transformInfo.center,
                m = Snap.matrix().rotate(360 - rotation, center.x, center.y),
                d = me.transformDirections(me.transformInfo.directions, m);
            me.transformInfo.rotation = (me.transformInfo.rotation + rotation) % 360;
            me.makeTransformInfoFromDirections(d);
            me.updateResizeControl();
            me.updateTrackingTool();
            me.firePositionChanged();

            var clientBox = me.rotationControl.node.getBoundingClientRect();
            me.rotationStart = {
                x: (clientBox.left + clientBox.right) / 2,
                y: (clientBox.top + clientBox.bottom) / 2
            };
        },

        onRotationMouseUp: function onRotationMouseUp(e) {
            this.endRotation();
        },

        /**
         * Rotates selected fields by specified angle in degrees
         * @memberof DPO.render.MouseTransformTool#
         * @param {number} deg
         */
        rotate: function rotate(deg) {
            var me = this,
                fields = me.selectedFields,
                canMove = true;
            for (var i = 0; i < fields.length; i++) {
                var f = me.selectedFields[i];
                canMove = canMove && f.movable;
            }

            if (fields.length && canMove) {
                var box = me.trackingPolygon.getBBox(),
                    m = Snap.matrix().rotate(-deg, box.cx, box.cy),
                    directions = me.transformInfo.directions;
                directions = me.transformDirections(directions, m);
                me.beginTransforming();
                me.transformInfo.rotation += deg;
                me.projectEditor.beginUpdates();
                me.projectEditor.rotateField(me.selectedFields, deg, {
                    x: box.cx * 20,
                    y: box.cy * 20
                });
                me.projectEditor.endUpdates();
                me.makeTransformInfoFromDirections(directions);
                me.updateTrackingTool();
                me.endTransforming();
                me.firePositionChanged();
            }

            // if (fields.length && canMove){
            //     var box = me.trackingPolygon.getBBox();
            //     me.beginTransforming();
            //     me.projectEditor.beginUpdates();
            //     me.rotateTrackingTool(deg, box);
            //     me.projectEditor.rotateField(me.selectedFields, deg, {
            //         x: box.cx * 20,
            //         y: box.cy * 20
            //     });
            //     me.projectEditor.endUpdates();
            //     me.endTransforming();
            //     me.firePositionChanged();
            // }
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Element Translation
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(MouseTransformTool.prototype, {
        translateTackingTool: function translateTackingTool(dx, dy) {
            if (this.disabled) {
                return;
            }
            var me = this,
                m = Snap.matrix().translate(dx, dy),
                d = me.transformInfo.directions;
            d = this.transformDirections(d, m);
            me.makeTransformInfoFromDirections(d);
            me.updateTrackingTool();
        },

        startTranslation: function startTranslation(x, y) {
            var me = this,
                field = me.selectedFields[0],
                movable = field && field.movable;
            if (movable) {
                me.editTextBlock(null);
                me.cropImage(null);
                me.startPoint = {x: x, y: y};
                me.beginTransforming();
                Snap.mousemove(me.translationMouseMoveListener).mouseup(me.translationMouseUpListener);
            }
        },

        stopTranslation: function stopTranslation() {
            var me = this,
                verticalId = me.id + '-vertical-snap',
                verticalEl = me.el.select('#' + verticalId),
                horizontalId = me.id + '-horizontal-snap',
                horizontalEl = me.el.select('#' + horizontalId);
            if (verticalEl) {
                verticalEl.remove();
            }
            if (horizontalEl) {
                horizontalEl.remove();
            }
            me.endTransforming();
            Snap.unmousemove(me.translationMouseMoveListener).unmouseup(me.translationMouseUpListener);
        },

        displaySnapLines: function displaySnapLines(vertical, horizontal) {
            var me = this,
                mp = me.editor.masterPanel,
                zoom = me.editor.zoom,
                strokeWidth = 1 / zoom,
                w = mp.width / 20,
                h = mp.height / 20,
                verticalId = me.id + '-vertical-snap',
                verticalEl = me.el.select('#' + verticalId),
                horizontalId = me.id + '-horizontal-snap',
                horizontalEl = me.el.select('#' + horizontalId);
            if (!verticalEl) {
                verticalEl = me.el.line(0, 0, 5, 5).attr({
                    'id': verticalId,
                    'stroke': '#1a4c6e',
                    'stroke-opacity': 0.8
                });
            }

            verticalEl.attr({
                'x1': w / 2,
                'y1': -20,
                'x2': w / 2,
                'y2': h + 20,
                'stroke-width': strokeWidth,
                'display': vertical ? 'inline' : 'none'
            });

            if (!horizontalEl) {
                horizontalEl = me.el.line(0, 0, 5, 5).attr({
                    'id': horizontalId,
                    'stroke': '#1a4c6e',
                    'stroke-opacity': 0.8
                });
            }

            horizontalEl.attr({
                'x1': -20,
                'y1': h / 2,
                'x2': w + 20,
                'y2': h / 2,
                'stroke-width': strokeWidth,
                'display': horizontal ? 'inline' : 'none'
            });
        },

        /**
         * Snaps field position to panel edge
         * @memberof DPO.render.MouseTransformTool#
         * @param {number} dx
         * @param {number} dy
         * @returns {{dx: number, dy: number}}
         */
        snapToEdge: function snapToEdge(dx, dy) {
            var me = this,
                fields = me.selectedFields,
                f = fields[0],
                snapAllowing = me.snapToEdgeEnabled;
            snapAllowing = snapAllowing && (f instanceof DPO.model.Drawing || f instanceof DPO.model.Image);

            if (fields.length !== 1 || !snapAllowing) {
                return {
                    dx: dx,
                    dy: dy
                };
            }

            function snapToRectEdge(fr, pr, bounds, dx, dy, delta) {
                if (Math.abs(fr.x1 - pr.x1) <= delta) {
                    dx = (pr.x1 - bounds.left) / 20;
                }

                if (Math.abs(fr.x2 - pr.x2) <= delta) {
                    dx = (pr.x2 - bounds.right) / 20;
                }

                if (Math.abs(fr.y1 - pr.y1) <= delta) {
                    dy = (pr.y1 - bounds.top) / 20;
                }

                if (Math.abs(fr.y2 - pr.y2) <= delta) {
                    dy = (pr.y2 - bounds.bottom) / 20;
                }

                return {
                    dx: dx,
                    dy: dy
                };
            }

            var selector = me.editor.context.selector,
                panel = me.editor.panel,
                mp = selector.selectMasterPanel(panel),
                bounds = selector.getBounds(me.selectedFields),
                safe = new DPO.math.Rect(0, 0, mp.width, mp.height),
                rect = new DPO.math.Rect(bounds.left, bounds.top, bounds.right, bounds.bottom);

            safe.inflate(-90, -90);
            rect.translate(dx * 20, dy * 20);

            var d = snapToRectEdge(rect, safe, bounds, dx, dy, 45);
            if (mp.bleed) {
                var bleed = new DPO.math.Rect(0, 0, mp.width, mp.height);
                bleed.inflate(90, 90);
                d = snapToRectEdge(rect, bleed, bounds, d.dx, d.dy, 45);
            }

            return d;
        },

        /**
         * Handlers translation mouse move event
         * @memberof DPO.render.MouseTransformTool#
         * @param {Event} e
         */
        onTranslationMouseMove: function onTranslationMouseMove(e) {
            if (!this.isInsideRoot(e.target)) {
                return;
            }

            var me = this,
                startPoint = me.startPoint,
                toCanvas = me.editor.clientToCanvasMatrix(true),
                toClient = me.editor.canvasToClientMatrix(true),
                offset = me.coordinateTransformer.getMouseOffset(e),
                offsetX = offset.x - startPoint.x,
                offsetY = offset.y - startPoint.y,
                dx = toCanvas.x(offsetX, offsetY),
                dy = toCanvas.y(offsetX, offsetY),
                bounds = me.editor.context.selector.getBounds(me.selectedFields),
                cx = me.editor.masterPanel.width / 2,
                cy = me.editor.masterPanel.height / 2,
                ncx = bounds.cx + dx * 20,
                ncy = bounds.cy + dy * 20,
                snapH = false,
                snapV = false;
            if (Math.abs(cx - ncx) <= 50) {
                dx = (cx - bounds.cx) / 20;
                snapV = true;
            }

            if (Math.abs(cy - ncy) <= 50) {
                dy = (cy - bounds.cy) / 20;
                snapH = true;
            }

            if (!snapV && !snapH && me.snapStep) {
                ncx = Math.round((bounds.x + dx * 20) / me.snapStep) * me.snapStep;
                ncy = Math.round((bounds.y + dy * 20) / me.snapStep) * me.snapStep;
                dx = (ncx - bounds.x) / 20;
                dy = (ncy - bounds.y) / 20;
            }

            var d = me.snapToEdge(dx, dy);
            dx = d.dx;
            dy = d.dy;

            me.startPoint.x += toClient.x(dx, dy);
            me.startPoint.y += toClient.y(dx, dy);
            me.projectEditor.beginUpdates();
            me.projectEditor.translateFields(me.selectedFields, dx * 20, dy * 20);
            me.projectEditor.endUpdates();
            me.fire('fields:translated', [me, me.selectedFields]);
            me.displaySnapLines(snapV, snapH);
            me.translateTackingTool(dx, dy);
            me.firePositionChanged();
        },

        onTranslationMouseUp: function onTranslationMouseUp(e) {
            this.stopTranslation();
            this.triggerContextMenu(e);
        },

        /**
         * Translates selected fields
         * @memberof DPO.render.MouseTransformTool#
         * @param {number} dx
         * @param {number} dy
         */
        translate: function translate(dx, dy) {
            var me = this,
                fields = me.selectedFields,
                canMove = true;
            for (var i = 0; i < fields.length; i++) {
                var f = me.selectedFields[i];
                canMove = canMove && f.movable;
            }

            if (fields.length && canMove) {
                me.beginTransforming();
                me.projectEditor.beginUpdates();
                me.projectEditor.translateFields(me.selectedFields, dx, dy);
                me.projectEditor.endUpdates();
                me.translateTackingTool(dx / 20, dy / 20);
                me.endTransforming();
                me.firePositionChanged();
            }
        }
    });


    Object.defineProperty(MouseTransformTool.prototype, 'disabled', {
        get: function get() {
            return this._disabled;
        },

        set: function set(value) {
            this._disabled = value;
            this.handlerChain = value ? this.noopHandlerLink : me.panHandlerLink;
        }
    });

    return MouseTransformTool;
});

DPO.def('render.RenderComponent', function () {
    /**
     * @class DPO.render.RenderComponent
     * @extends DPO.mixins.Observable
     * @extends DPO.render.Renderer
     * @memberof DPO.render
     * @param {object} cfg
     * @constructor
     */
    function RenderComponent(cfg) {
        var me = this;
        me.resetObservable();
        DPO.render.Renderer.apply(me, [cfg]);
        me.hiddenFields = [];
    }

    DPO.inherit(RenderComponent, DPO.render.Renderer);

    DPO.mixin(RenderComponent.prototype, DPO.mixins.Observable);
    DPO.mixin(RenderComponent.prototype, {
        isBleedVisible: false,
        safeLineText: 'SAFE LINE',
        bleedLineText: 'BLEED LINE',

        /**
         * Returns panel's visible fields
         * @memberof DPO.render.RenderComponent#
         * @param {DPO.model.Panel} panel
         * @returns {DPO.model.Field[]}
         */
        getVisibleFields: function getVisibleFields(panel) {
            var order = this.context.selector.getFieldOrder(panel),
                hidden = this.hiddenFields,
                fields = order.getFields();
            for (var i = 0; i < hidden.length; i++) {
                var index = fields.indexOf(hidden[i]);
                fields.splice(index, 1);
            }
            return fields;
        },

        /**
         * Returns array of hidden fields
         * @memberof DPO.render.RenderComponent#
         * @returns {DPO.model.Field[]}
         */
        getHiddenFields: function getHiddenFields() {
            return [].concat(this.hiddenFields);
        },

        /**
         * Hides fields
         * @memberof DPO.render.RenderComponent#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         */
        hideFields: function hideFields(fields) {
            fields = fields instanceof Array ? fields : [fields];

            var me = this,
                array = me.hiddenFields;
            for (var i = 0; i < fields.length; i++) {
                var index = array.indexOf(fields[i]);
                if (index === -1) {
                    array.push(fields[i]);
                }
            }

            if (me.transformTool) {
                me.transformTool.deselectFields(array);
            }
            me.updateContent();
        },

        /**
         * Shows fields
         * @memberof DPO.render.RenderComponent#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         */
        showFields: function showFields(fields) {
            fields = fields instanceof Array ? fields : [fields];

            var array = this.hiddenFields;
            for (var i = 0; i < fields.length; i++) {
                var index = array.indexOf(fields[i]);
                if (index !== -1) {
                    array.splice(index, 1);
                }
            }

            this.updateContent();
        },

        /**
         * @memberof DPO.render.RenderComponent#
         */
        updateContent: function updateContent() {
            var me = this;
            me.content.clear();
            me.updateFields(me.getVisibleFields(me.panel));
        },

        /**
         * Updates fields
         * @memberof DPO.render.RenderComponent#
         * @param {DPO.model.Field[]} fields
         * @param {string} [method]
         */
        updateFields: function updateFields(fields, method) {
            var me = this,
                content = me.content;
            method = method || 'dpoUpdate';
            for (var i = 0; i < fields.length; i++) {
                var index = me.context.selector.panelIndex(me.panel),
                    f = fields[i],
                    markup = me.fieldMarkup(f, null, index),
                    el = content.select('#' + me.fieldMarkupId(f));
                content[el ? method : 'dpoRender'](markup);
            }
        },

        /**
         * Sets style for bleed & safe areas
         * @memberof DPO.render.RenderComponent#
         * @param {object} safeLineStyle
         * @param {object} bleedLineStyle
         */
        setSafeAndBleedStyle: function setSafeAndBleedStyle(safeLineStyle, bleedLineStyle) {
            var me = this,
                el = Snap('#' + me.id + '-safe-line');
            el.attr(safeLineStyle);

            el = Snap('#' + me.id + '-bleed-line');
            el.attr(bleedLineStyle);
        },

        /**
         * Return offset value for safe line
         * @memberof DPO.render.RenderComponent#
         * @param {Snap} box
         * @return {number} offset
         */
        getSafeLineOffset: function getSafeLineOffset(box) {
            var me = this,
                fc = me.context.flowConfig,
                boxMinSide = Math.min(DPO.pointsToTwips(box.width), DPO.pointsToTwips(box.height)),
                offset = 9;

            if (fc && boxMinSide <= fc.productGeometryCharacteristic.panelSafelineRenderLimit) {
                offset = 0;
            }

            return offset;
        },

        /**
         * Return safe line path
         * @memberof DPO.render.RenderComponent#
         * @param {DPO.model.Panel} panel
         * @return {Snap} path
         */
        getSafeLinePath: function getSafeLinePath(panel) {
            var me = this,
                shape = me.toPath(me.shapeMarkup(panel)),
                safePath = shape.geometry.d,
                box = Snap.path.getBBox(safePath),
                offset = me.getSafeLineOffset(box),
                deflateScaleX = (box.width - offset) / box.width,
                deflateScaleY = (box.height - offset) / box.height,
                deflateMatrix = Snap.matrix().scale(deflateScaleX, deflateScaleY, box.cx, box.cy);
            safePath = Snap.path.map(safePath, deflateMatrix);
            return safePath;
        },

        /**
         * Return bleed line path
         * @memberof DPO.render.RenderComponent#
         * @param {DPO.model.Panel} panel
         * @return {Snap} path
         */
        getBleedLinePath: function getBleedLinePath(panel) {
            var me = this,
                shape = me.toPath(me.shapeMarkup(panel)),
                bleedPath = shape.geometry.d,
                box = Snap.path.getBBox(bleedPath),
                inflateScaleX = (box.width + 9) / box.width,
                inflateScaleY = (box.height + 9) / box.height,
                inflateMatrix = Snap.matrix().scale(inflateScaleX, inflateScaleY, box.cx, box.cy);
            bleedPath = Snap.path.map(bleedPath, inflateMatrix);
            return bleedPath;
        },

        /**
         * Renders bleed & safe ares to specified SVG element
         * @memberof DPO.render.RenderComponent#
         * @param {Snap} canvas
         * @param {DPO.model.Panel} panel
         * @param {string} [vectorEffect]
         */
        renderBleedAndSafeAreas: function renderBleedAndSafeAreas(canvas, panel, vectorEffect) {
            vectorEffect = vectorEffect || 'none';

            var me = this,
                mp = me.context.selector.selectMasterPanel(panel),
                bleedPath = me.getBleedLinePath(panel),
                safePath = me.getSafeLinePath(panel);
            me.isBleedVisible = mp.bleed;

            canvas.path(bleedPath).attr({
                'id': me.id + '-bleed-line',
                'stroke': '#B0B0B0',
                'class': 'bleed-line',
                'stroke-dasharray': '3,3',
                'fill': 'none',
                'display': me.isBleedVisible ? 'inline' : 'none',
                'pointer-events': 'none',
                'vector-effect': vectorEffect
            });

            canvas.path(safePath).attr({
                'id': me.id + '-safe-line',
                'stroke': '#B0B0B0',
                'class': 'safe-line',
                'fill': 'none',
                'stroke-dasharray': '3,3',
                'display': 'inline',
                'pointer-events': 'none',
                'vector-effect': vectorEffect
            });
        },

        drawLabel: function drawLabel(canvas, panel, fontSize, text, safe, vectorEffect) {
            function p(x, y) {
                return x + ' ' + y + ' ';
            }

            function safeRoundRect(x, y, w, h, r) {
                var path = 'M' + p(x, y + h);
                path += 'L ' + p(x, y + r) + 'Q' + p(x, y) + p(x + r, y);
                path += 'L ' + p(x + w - r, y) + 'Q' + p(x + w, y) + p(x + w, y + r);
                path += 'L ' + p(x + w, y + h);
                return path;
            }

            function bleedRoundRect(x, y, w, h, r) {
                var path = 'M' + p(x, y);
                path += 'L ' + p(x, y + h - r) + 'Q' + p(x, y + h) + p(x + r, y + h);
                path += 'L ' + p(x + w - r, y + h) + 'Q' + p(x + w, y + h) + p(x + w, y + h - r);
                path += 'L ' + p(x + w, y);
                return path;
            }

            var me = this,
                ctx = me.context,
                mp = ctx.selector.selectMasterPanel(panel),
                path = safe ? me.getSafeLinePath(panel) : me.getBleedLinePath(panel),
                box = Snap.path.getBBox(path),
                lm = ctx.layoutManager,
                ellipse = mp.shape === 'ellipse',
                markup, textEl, textBlock, textBox;
            if (ellipse) {
                textBlock = ctx.projectTransformer.createTextPath(mp.textDefaults[0]);
            } else {
                textBlock = ctx.projectTransformer.createTextBlock(mp.textDefaults[0]);
            }

            var paragraph = textBlock.text.textFlow.paragraphs[0],
                span = paragraph.spans[0];
            span.value = text;
            span.color = '#b8c2c9';
            span.fontSize = fontSize;
            paragraph.textAlign = 'center';
            textBlock.textStyle.overflow = 'wrap';
            textBlock.text.textFlow.verticalAlign = 'top';

            if (ellipse) {
                var m = lm.getMetricsForSpan(span),
                    dm = lm.fontMetrics,
                    offset = safe ? dm.getAscender(m, span.fontSize) : dm.getDescender(m, span.fontSize),
                    rect = new DPO.math.Rect(box.x, box.y, box.x2, box.y2);
                rect.inflate(-offset, -offset);

                textBlock.position.x = rect.x * 20;
                textBlock.position.y = rect.y * 20;
                textBlock.height = rect.height * 20;
                textBlock.width = rect.width * 20;
                textBlock.textAngle = 90;
                textBlock.rotateSense = 'ccw';

                markup = me.fieldMarkup(textBlock, me.id + '-bleed-line-label', 0, true);
                canvas.dpoRender(markup);
            } else {
                textBlock.position.x = box.x * 20;
                textBlock.position.y = box.y2 * 20;
                textBlock.height = fontSize * 20;
                textBlock.width = box.width * 20;

                var containers = lm.layoutTextBlock(textBlock),
                    container = containers[0],
                    line = container.lines[0];
                if (safe) {
                    textBlock.position.y = (box.y2 - line.height) * 20;
                } else {
                    textBlock.position.y = box.y2 * 20;
                }

                markup = me.fieldMarkup(textBlock, me.id + '-bleed-line-label', 0, true);
                textEl = canvas.dpoRender(markup);
                textBox = textEl.getBBox();

                var w = textBox.width - 2 * line.descender,
                    h = textBox.height - line.descender,
                    x = textBox.cx - w / 2,
                    y = safe ? box.y2 - h : box.y2,
                    fn = safe ? safeRoundRect : bleedRoundRect,
                    borderPath = fn(x, y, w, h, 5, 5, 0, 0);
                canvas.path({
                    'd': borderPath,
                    'stroke-dasharray': '3px, 3px',
                    'stroke': '#B0B0B0',
                    'fill': 'none',
                    'vector-effect': vectorEffect
                });
            }
        },

        /**
         * Renders bleed & safe labels to specified SVG element
         * @memberof DPO.render.RenderComponent#
         * @param {Snap} canvas
         * @param {DPO.model.Panel} panel
         * @param {string} [vectorEffect]
         */
        renderBleedAndSafeLabels: function renderBleedAndSafeLabels(canvas, panel, vectorEffect) {
            vectorEffect = vectorEffect || 'none';

            var me = this,
                ctx = me.context,
                lm = ctx.layoutManager,
                mp = ctx.selector.selectMasterPanel(panel),
                path = me.getSafeLinePath(panel),
                box = Snap.path.getBBox(path),
                texts = [me.safeLineText, me.bleedLineText],
                fontSize = Infinity,
                labelWidth;
            if (mp.shape === 'ellipse') {
                labelWidth = Snap.path.getTotalLength(path) / 6;
            } else {
                labelWidth = box.width / 4;
            }

            for (var i = 0; i < texts.length; i++) {
                var containers = lm.layoutPlainText(DPO.text.FitLayout, texts[i], labelWidth, box.height),
                    span = containers[0].lines[0].spans[0];
                fontSize = Math.min(fontSize, span.fontSize);
            }

            if (mp.shape === 'ellipse') {
                fontSize = Math.min(fontSize, 8);
            }

            me.drawLabel(canvas, panel, fontSize, texts[0], true, vectorEffect);

            if (mp.bleed) {
                me.drawLabel(canvas, panel, fontSize, texts[1], false, vectorEffect);
            }
        }
    });

    return RenderComponent;
});

DPO.def('render.PanelPreview', function (ns) {
    /**
     * Creates a new panel preview component.
     * @class DPO.render.PanelPreview
     * @memberof DPO.render
     * @extends DPO.render.RenderComponent
     * @property {DPO.model.Panel} panel
     * @property {DPO.model.MasterPanel} masterPanel
     * @property {DPO.project.Transformer} projectTransformer
     * @param {Element} el
     * @param {object} context
     * @param {object} [cfg]
     * @constructor
     */
    function PanelPreview(el, context, cfg) {
        cfg = cfg || {};

        var me = this;
        me._context = null;
        me._panel = null;
        me.projectTransformer = null;
        me.el = el;
        me.hiddenFields = [];
        me.id = me.id || DPO.id();

        DPO.mixin(me, cfg);
        DPO.render.RenderComponent.apply(this, [null]);

        me.render();
        me.context = context;
        me.setZoomLevel(1);
    }

    DPO.inherit(PanelPreview, ns.RenderComponent);

    Object.defineProperty(PanelPreview.prototype, 'zoom', {
        get: function get() {
            return this._zoom;
        },

        set: function set(value) {
            this.setZoomLevel(value);
        }
    });

    DPO.mixin(PanelPreview.prototype, {
        minZoom: 0.05,
        maxZoom: 5,
        enableZoom: false,
        useClip: true,
        displayBleedAndSafeAreas: false,
        displayBleedAndSafeLabels: true,

        update: function update() {
            var me = this;
            me.content.clear();
            me.content.selectAll('defs').remove();
            me.grid.clear();
            if (!me.panel) {
                return;
            }

            me.updateContent();
            if (me.displayBleedAndSafeAreas) {
                var ve = me.enableZoom ? 'none' : 'non-scaling-stroke';
                me.renderBleedAndSafeAreas(me.grid, me.panel, ve);

                if (me.displayBleedAndSafeLabels) {
                    me.renderBleedAndSafeLabels(me.grid, me.panel, ve);
                }
            }
            if (me.useClip) {
                me.updateClipPath();
            }
            me.updateViewPort();
        },

        onColorSpaceChanged: function onColorSpaceChanged(sender, colorSpace) {
            var me = this;
            if (!colorSpace || colorSpace.ready) {
                this.update();
            } else {
                colorSpace.on('gamut:loaded', me.update, me);
            }
        },

        updateClipPath: function updateClipPath() {
            var me = this,
                clipPath = me.definePanelClipPath(me.panel);
            me.content.node.setAttribute('clip-path', Snap.url(clipPath));
        },

        updateViewPort: function updateViewPort() {
            var me = this,
                mp = me.masterPanel,
                wpt = mp.width / 20,
                hpt = mp.height / 20,
                attributes = {
                    preserveAspectRatio: 'xMidYMid meet',
                    viewBox: [-1, -1, wpt + 2, hpt + 2].join(',')
                };

            if (mp.bleed) {
                var bleedBox = Snap.path.getBBox(me.getBleedLinePath(me.panel)),
                    bleedOffset = me.context.project.bleedOffset / 20;

                attributes.viewBox = [-bleedOffset - 1, -bleedOffset - 1, bleedBox.width + 2, bleedBox.height + 2].join(',');
            }

            me.root.attr(attributes);
        },

        updateContent: function updateContent() {
            var me = this;
            me.$super.updateContent.apply(me, arguments);
            me.content.dpoRender(me.shapeMarkup(me.panel)).attr({
                fill: 'none'
            });
        },

        hideAllFields: function hideAllFields() {
            var me = this,
                order = me.context.selector.getFieldOrder(me.panel),
                fields = order.getFields();
            me.hideFields(fields);
            me.update();
        },

        showAllFields: function showAllFields() {
            var me = this,
                order = me.context.selector.getFieldOrder(me.panel),
                fields = order.getFields();
            me.showFields(fields);
            me.update();
        },

        calculatePreferredZoom: function calculatePreferredZoom() {
            var me = this,
                mp = me.context.selector.selectMasterPanel(me.panel),
                box = me.viewEl.getBoundingClientRect(),
                w = mp.width / 20,
                h = mp.height / 20,
                zw = box.width / w * 0.75,
                zh = box.height / h * 0.75,
                z = Math.min(zw, zh) - 0.05;
            z = Math.floor(z / 0.05) * 0.05;
            z = Math.min(z, me.maxZoom);
            z = Math.max(z, me.minZoom);
            return z;
        },

        setZoomLevel: function setZoomLevel(zoom, scroll) {
            var me = this;
            zoom = Math.min(zoom, me.maxZoom);
            zoom = Math.max(zoom, me.minZoom);

            if (zoom === me._zoom) {
                return;
            }

            me._zoom = zoom;

            var mp = me.context.selector.selectMasterPanel(me.panel),
                box = me.viewEl.getBoundingClientRect(),
                w = mp.width * zoom / 20,
                h = mp.height * zoom / 20;

            DPO.render.applyStyles(me.root.node, {
                margin: [Math.max((box.height * 0.75 - h) / 2, 0) + 'pt', 0, 0, 0].join(' ')
            });

            me.root.attr({
                width: w + 'pt',
                height: h + 'pt'
            });

            me.grid.attr({
                strokeWidth: 1 / zoom
            });

            var el = me.viewEl;
            if (scroll) {
                el.scrollLeft = scroll.x;
                el.scrollTop = scroll.y;
            } else {
                var sw = el.scrollWidth,
                    sh = el.scrollHeight;
                el.scrollLeft = Math.max(0, (sw - box.width) / 2);
                el.scrollTop = Math.max(0, (sh - box.height) / 2);
            }

            me.fire('changed:zoom', [me, zoom]);
        },

        render: function render() {
            var me = this,
                svgNS = 'http://www.w3.org/2000/svg',
                rootEl, viewEl;

            if (me.enableZoom) {
                rootEl = document.createElementNS(svgNS, 'svg');
                rootEl.id = me.id + '-root';
                viewEl = document.createElement('div');
                viewEl.id = me.id;
                viewEl.appendChild(rootEl);
                DPO.render.applyStyles(viewEl, {
                    'text-align': 'center',
                    'overflow': 'auto',
                    'background': 'white'
                });
                me.root = Snap(rootEl);
                me.viewEl = viewEl;
                me.el.appendChild(viewEl || rootEl);
            } else {
                me.root = Snap(me.el);
                me.setZoomLevel = DPO.emptyFn;
            }

            DPO.render.applyStyles(me.root.node, {
                'overflow': 'hidden'
            });

            me.content = me.root.g();
            me.grid = me.root.g().attr({
                'pointer-events': 'none',
                'overflow': 'visible'
            });
        },

        destroy: function destroy() {
            var me = this;
            me.context = null;
        },

        definePanelClipPath: function definePanelClipPath(panel) {
            var me = this,
                master = me.context.selector.selectMasterPanel(panel),
                id = me.id + '-clip-path-' + master.id,
                clipPath = me.root.select('#' + id);
            if (!clipPath) {
                var defs = me.root.select('defs'),
                    doc = me.root.node.ownerDocument;
                clipPath = Snap(doc.createElementNS('http://www.w3.org/2000/svg', 'clipPath'));
                defs.append(clipPath);
                clipPath.attr({id: id});
                clipPath.append(me.root.path({
                    d: me.getBleedLinePath(panel)
                }));
            }
            return id;
        },

        onImageGenerated: function onImageGenerated(sender, name) {
            var me = this,
                content = me.content,
                selector = me.context.selector,
                fields = selector.selectFields(function (f) {
                    return f.source === name;
                }),
                index = selector.panelIndex(me.panel);
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    markup = me.fieldMarkup(f, null, index);
                markup.overrideChildren = true;
                content.dpoUpdate(markup);
            }
        },

        onImageProgress: function onImageProgress(name, current, total) {
            var me = this,
                selector = me.context.selector,
                fields = selector.selectFields(function (f) {
                    return f.source === name;
                });

            for (var i = 0; i < fields.length; i++) {
                var id = me.fieldMarkupId(fields[i]),
                    indicatorWrapper = me.content.select('#' + id + '-indicator-wrapper'),
                    indicator = me.content.select('#' + id + '-indicator');

                if (indicatorWrapper && indicator) {
                    indicatorWrapper.attr('display', 'block');
                    indicator.node.textContent = (current / (total || 1) * 100).toFixed(0) + '%';
                }
            }
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Properties
    // -----------------------------------------------------------------------------------------------------------------

    Object.defineProperty(PanelPreview.prototype, 'context', {
        get: function get() {
            return this._context;
        },

        set: function set(value) {
            var me = this, pt;
            if (me._context === value) {
                return;
            }

            if (me._context) {
                pt = me._context.projectTransformer;
                pt.un(/.*/, me.update, me);
                me._context.un('changed:color-space', me.onColorSpaceChanged, me);
                me._context.storage.un('image:generated', me.onImageGenerated, me);
                me._context.storage.un('image:progress', me.onImageProgress, me);
            }

            me._context = value;

            if (value) {
                value.storage.on('image:generated', me.onImageGenerated, me);
                value.storage.on('image:progress', me.onImageProgress, me);
                value.projectTransformer.on(/.*/, me.update, me);
                value.on('changed:color-space', me.onColorSpaceChanged, me);
                me.panel = value.project.pages[0].panels[0];
            } else {
                me.panel = null;
            }
        }
    });

    Object.defineProperty(PanelPreview.prototype, 'panel', {
        get: function get() {
            return this._panel;
        },

        set: function set(value) {
            var me = this;
            if (me._panel === value) {
                return;
            }

            me.masterPanel = value ? me.context.selector.selectMasterPanel(value.master) : null;
            me._panel = value;
            me.update();
        }
    });

    return PanelPreview;
});

DPO.def('render.Editor', function (ns) {
    function animateReorder(el, d) {
        var box = el.getBBox(true),
            local = el.transform().localMatrix;

        function BackAnimation() {
            Snap.animate(1, 0, function (value) {
                var m = local.clone().scale(1.0 + d * value, 1.0 + d * value, box.cx, box.cy);
                el.attr({
                    transform: m
                });
            }, 100, mina.linear);
        }

        Snap.animate(0, 1, function (value) {
            var m = local.clone().scale(1.0 + d * value, 1.0 + d * value, box.cx, box.cy);
            el.attr({
                transform: m
            });
        }, 100, mina.linear, BackAnimation);
    }

    /**
     * Creates a new editor object.
     * @class DPO.render.Editor
     * @memberof DPO.render
     * @extends DPO.render.RenderComponent
     * @extends DPO.mixins.Observable
     * @property {DPO.model.Page} page
     * @property {number} pageIndex
     * @property {DPO.model.Panel} panel
     * @property {number} panelIndex
     * @property {DPO.model.Field[]} selectedFields
     * @property {DPO.model.MasterPanel} masterPanel
     * @property {DPO.project.Editor} projectEditor
     * @property {object} bleedLabelCfg
     * @property {object} safeLabelCfg
     * @param {Element} el
     * @param {DPO.render.Context} context
     * @param {object} [cfg]
     * @constructor
     */
    function Editor(el, context, cfg) {
        cfg = cfg || {};

        var me = this;
        me.id = DPO.id();
        me.isField = new RegExp(me.id + '-field-[^-]+$');
        me._zoom = 1;
        me._context = null;
        me._page = null;
        me._panel = null;
        me._bleedLabelCfg = null;
        me._safeLabelCfg = null;
        me.projectEditor = null;
        me.transformTool = null;
        me.enableAutoZoom = !!cfg.enableAutoZoom;
        me.zoomPadding = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        };

        me.el = el;
        me.isDangerousAreaVisible = false;
        me.isGridVisible = true;
        me.isItemNumberVisible = false;
        me.isBleedVisible = true;
        me.hiddenFields = [];
        me.rotation = 0;
        me.workingAreaId = me.id + '-working-area';
        me.rootId = me.id + '-root';
        me.canvasId = me.id + '-canvas';
        me.canvasTransformId = me.id + '-canvas-transform';
        me.gridId = me.id + '-grid';
        me.labelsId = me.id + '-labels';
        me.contentId = me.id + '-content';
        me.transformToolId = me.id + '-transform-tool';
        me.gridMode = me.gridModes[cfg.gridMode || 'inches'];
        me.windowResizeListener = me.onResize.bind(me);
        me.mouseWheelListener = me.onMouseWheel.bind(me);

        me.resetObservable();
        me.initialize();

        me.context = context;
    }

    DPO.inherit(Editor, ns.RenderComponent);

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Methods
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(Editor.prototype, DPO.mixins.Observable);

    DPO.mixin(Editor.prototype, {
        getScale: function getScale() {
            return this.zoom;
        },

        getMouseOffset: function getMouseOffset(e) {
            var me = this,
                box = me.viewPortCfg.areaBox,
                x = me.workingArea.scrollLeft + e.clientX - box.left,
                y = me.workingArea.scrollTop + e.clientY - box.top;
            return {
                x: x,
                y: y
            };
        },

        /**
         * Creates matrix for conversion from canvas coordinate system to client coordinate system
         * @memberof DPO.render.Editor#
         * @returns {*}
         */
        canvasToClientMatrix: function canvasToClientMatrix(omitTranslation) {
            var me = this,
                deg = me.rotation,
                viewPort = me.viewPortCfg,
                box = viewPort.areaBox,
                scale = 1 / 0.75 * me.zoom,// 1px == 0.75pt and multiply by zoom factor
                rotation = Snap.matrix().rotate(deg, viewPort.cx, viewPort.cy),
                matrix = Snap.matrix().rotate(deg).scale(scale),
                canvasOrigin = {x: box.width, y: box.height};
            if (!omitTranslation) {
                matrix.e = rotation.x(canvasOrigin.x, canvasOrigin.y);
                matrix.f = rotation.y(canvasOrigin.x, canvasOrigin.y);
            }
            return matrix;
        },

        /**
         * Creates matrix for conversion from canvas coordinate system to field coordinate system
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field} field
         * @returns {*}
         */
        canvasToFieldMatrix: function canvasToFieldMatrix(field) {
            var p = field.position,
                r = field.rotation;
            return Snap.matrix().translate(p.x / 20, p.y / 20).rotate(360 - r, 0, 0).invert();
        },

        /**
         * Creates matrix for conversion from client coordinate system to canvas coordinate system
         * @memberof DPO.render.Editor#
         * @returns {*}
         */
        clientToCanvasMatrix: function clientToCanvasMatrix(omitTranslation) {
            var m = this.canvasToClientMatrix().invert();
            if (omitTranslation) {
                m.e = 0;
                m.f = 0;
            }
            return m;
        }
    });

    DPO.mixin(Editor.prototype, {
        minZoom: 0.05,
        maxZoom: 5,
        gridModes: {
            inches: {
                unitName: 'inch',
                pointsPerUnit: 72,
                pixelsPerDivider: 25,
                gradation: [1, 1, 2, 4, 5],
                dividers: [1, 2, 4, 5, 10, 20]
            },
            centimeters: {
                unitName: 'cm',
                pixelsPerDivider: 20,
                pointsPerUnit: 28.34645669291,
                gradation: [1, 2, 4, 5, 10],
                dividers: [1, 2, 4, 5, 10, 20]
            }
        },

        /**
         * Center view port to specified fields
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         * @param {boolean} [animated]
         */
        navigateToFields: function navigateToFields(fields, animated) {
            if (!fields || !fields.length) {
                return;
            }

            var me = this,
                cfg = me.viewPortCfg,
                box = cfg.areaBox,
                selector = me.context.selector,
                bounds = selector.getBounds(fields),
                m = me.canvasToClientMatrix(),
                x = m.x(bounds.cx / 20, bounds.cy / 20),
                y = m.y(bounds.cx / 20, bounds.cy / 20),
                osl = me.workingArea.scrollLeft,
                ost = me.workingArea.scrollTop,
                nsl = x - box.width / 2,
                nst = y - box.height / 2;
            if (animated) {
                Snap.animate(0, 1, function (value) {
                    me.workingArea.scrollLeft = osl + (nsl - osl) * value;
                    me.workingArea.scrollTop = ost + (nst - ost) * value;
                }, 300, mina.easein, function () {
                    me.fire('animation:finished');
                });
            } else {
                me.workingArea.scrollLeft = nsl;
                me.workingArea.scrollTop = nst;
            }
        },

        getColor: function getColor(field, x, y, callback) {
            var me = this,
                url;

            switch (field.constructor) {
                case DPO.model.Image:
                case DPO.model.Background:
                case DPO.model.Barcode:
                    url = me.context.storage.urlForField(field, 'high');
                    break;
                case DPO.model.TextBlock:
                case DPO.model.TextPath:
                    callback([0, 0, 0, 0]);
                    return;
                default:
                    var index = me.context.selector.panelIndex(me.panel),
                        svgNS = 'http://www.w3.org/2000/svg',
                        svg = document.createElementNS(svgNS, 'svg'),
                        renderer = new DPO.render.Renderer(me.context),
                        s = Snap(svg),
                        markup;
                    markup = renderer.fieldMarkup(field, null, index);
                    renderer.proofColor = function proofColor(color) {
                        return color.replace('0x', '#');
                    };

                    delete markup.geometry.transform;
                    s.attr({
                        xmlns: 'http://www.w3.org/2000/svg',
                        version: '1.1',
                        width: field.width / 10,
                        height: field.height / 10,
                        viewBox: [0, 0, field.width / 20, field.height / 20].join(' ')
                    });
                    s.dpoRender(markup);

                    var svgText = s.outerSVG().replace(/&nbsp;/gm, '&#160;');
                    url = 'data:image/svg+xml,' + encodeURIComponent(svgText);
                    break;

            }

            function imageLoaded() {
                var img = /** @type Image*/this,
                    canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                var w = field.width / 20,
                    h = field.height / 20,
                    dx = x / w * img.naturalWidth,
                    dy = y / h * img.naturalHeight;

                ctx.drawImage(img, dx, dy, 4, 4, 0, 0, img.naturalWidth, img.naturalHeight);
                var data = ctx.getImageData(0, 0, 1, 1).data;
                callback(data, [Math.ceil(dx), Math.ceil(dy)]);
            }

            var regexp = /^data:image/,
                img = new Image();
            if (!regexp.test(url)) {
                img.crossOrigin = 'Anonymous';
            }
            img.addEventListener('load', imageLoaded);
            img.src = url;
        },

        /**
         * Gets or sets bleed area visibility
         * @memberof DPO.render.Editor#
         * @param {boolean} [visible]
         * @returns boolean
         */
        dangerousAreaVisible: function dangerousAreaVisible(visible) {
            var me = this;
            if (me.isDangerousAreaVisible === visible || visible === undefined) {
                return me.isDangerousAreaVisible;
            }

            var el = Snap('#' + me.id + '-dangerous-area');
            el.attr({
                display: visible ? 'inline' : 'none'
            });

            me.isDangerousAreaVisible = !!visible;
            return !!visible;
        },

        /**
         * Gets or sets grid visibility
         * @memberof DPO.render.Editor#
         * @param {boolean} [visible]
         * @returns boolean
         */
        gridVisible: function gridVisible(visible) {
            if (visible === undefined) {
                return this.isGridVisible;
            }

            var el = Snap('#' + this.id + '-grid-pattern-rect');
            el.attr({
                display: visible ? 'inline' : 'none'
            });

            this.isGridVisible = !!visible;
            return !!visible;
        },

        /**
         * Gets or set item number visibility
         * @memberof DPO.render.Editor#
         * @param {boolean} [visible]
         * @returns boolean
         */
        itemNumberVisible: function itemNumberVisible(visible) {
            var me = this;
            if (visible === undefined) {
                return this.isItemNumberVisible;
            }

            var panelIndex = me.context.selector.panelIndex(me.panel),
                el = Snap('#' + me.id + '-item-number-' + panelIndex);
            el.attr({
                display: visible ? 'inline' : 'none'
            });

            me.isItemNumberVisible = !!visible;
            return !!visible;
        },

        /**
         * Set new panel with flip animation
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Page} page
         * @param {DPO.model.Panel} panel
         */
        flip: function flip(page, panel) {
            var me = this,
                cfg = this.viewPortCfg,
                cx = cfg.cx,
                cy = cfg.cy,
                el = me.canvasTransform;

            function f1() {
                me.changePanel(panel, true);
                Snap.animate(0.999, 0, function (value) {
                    var m = Snap.matrix().scale(1 - value, 1, cx, cy);
                    m.rotate(me.rotation, cx, cy);
                    el.attr({transform: m});
                }, 250, mina.easeinout, function () {
                    me.fire('animation:finished');
                });
            }

            Snap.animate(0, 0.999, function (value) {
                var m = Snap.matrix().scale(1 - value, 1, cx, cy);
                m.rotate(me.rotation, cx, cy);
                el.attr({transform: m});
            }, 250, mina.easeinout, f1);
        },

        /**
         * Rotates canvas by specified angle
         * @memberof DPO.render.Editor#
         * @param {number} angle
         * @param {boolean} [animated]
         * @param {function} [callback]
         */
        rotate: function rotate(angle, animated, callback) {
            var me = this,
                cfg = this.viewPortCfg,
                el = me.canvasTransform;
            if (animated) {
                Snap.animate(this.rotation, angle, function (value) {
                    el.attr({transform: Snap.matrix().rotate(value, cfg.cx, cfg.cy)});
                }, 300, mina.easeinout, callback);
            } else {
                el.attr({
                    transform: Snap.matrix().rotate(angle, cfg.cx, cfg.cy)
                });
            }
            this.transformTool.canvasRotationMatrix = Snap.matrix().rotate(360 - angle);
            this.rotation = angle;
        },

        /**
         * Returns field at specified position
         * @memberof DPO.render.Editor#
         * @param {number} x
         * @param {number} y
         * @returns {DPO.model.Field}
         */
        getFieldAtPos: function getFieldAtPos(x, y) {
            var me = this,
                m = me.clientToCanvasMatrix(),
                px = m.x(x, y) * 20,
                py = m.y(x, y) * 20,
                fields = me.context.selector.getFieldsAtPos(px, py, me.panel),
                lockedFields = me.getLockedFields();
            for (var i = fields.length - 1; i >= 0; i--) {
                var field = fields[i];
                if (lockedFields.indexOf(field) === -1) {
                    return field;
                }
            }
            return null;
        },

        destroy: function destroy() {
            var me = this;
            me.resetObservable();
            me.context = null;
            me.windowResizeListener = null;
            me.mouseDownListener = null;
            me.mouseMoveListener = null;
            me.mouseUpListener = null;
            me.transformToolCfg = null;
            me.workingArea = null;
            me.root = null;
            me.canvas = null;
            me.canvasTransform = null;
            me.content = null;
            me.grid = null;

            if (me.workingArea) {
                me.el.removeChild(me.workingArea);
                me.workingArea = null;
            }
        },

        /**
         * Centers fields in master panel
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         * @param {boolean} middle
         * @param {boolean} center
         * @param {boolean} [animated]
         */
        centerFields: function centerFields(fields, middle, center, animated) {
            var me = this,
                mp = me.masterPanel,
                pt = me.projectEditor;
            if (animated) {
                me.scheduleAnimation(me.animateTranslation, 'changed:field:geometry');
                pt.suspendEvents(me, /changed:field:geometry/);
            }

            pt.beginUpdates();
            pt.centerFields(fields, middle, center, {
                x: 0,
                y: 0,
                width: mp.width,
                height: mp.height
            });
            pt.endUpdates();
            me.transformTool.update();

            if (animated) {
                pt.resumeEvents(me);
            }
        },

        /**
         * Align fields by specified direction to first field.
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         * @param {string} direction
         * @param {boolean} [animated]
         */
        alignFields: function alignFields(fields, direction, animated) {
            var me = this,
                pt = me.projectEditor;
            if (animated) {
                me.scheduleAnimation(me.animateTranslation, 'changed:field:geometry');
                pt.suspendEvents(me, /changed:field:geometry/);
            }

            pt.beginUpdates();
            pt.alignFields(fields, direction);
            pt.endUpdates();

            me.transformTool.update();

            if (animated) {
                pt.resumeEvents(me);
            }
        },

        /**
         * @param {DPO.model.Field} field
         * @param {number} [x]
         * @param {number} [y]
         * @param {number} width
         * @param {number} height
         */
        alignFieldToPos: function alignFieldToPos(field, x, y, width, height) {
            var me = this,
                m = me.clientToCanvasMatrix(),
                box = me.viewPortCfg.areaBox,
                pt = me.projectEditor;
            if (x == null) {
                pt.centerFields([field], true, true, {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height
                });
            } else {
                x = me.workingArea.scrollLeft + x - box.left;
                y = me.workingArea.scrollTop + y - box.top;

                field.position.x = m.x(x, y) * 20 - field.width / 2;
                field.position.y = m.y(x, y) * 20 - field.height / 2;
                me.updateFields([field]);
            }
        },

        /**
         * Add shape to canvas and select it
         * @memberof DPO.render.Editor#
         * @param {string} path
         * @param {number} [x]
         * @param {number} [y]
         * @returns {DPO.model.Drawing}
         */
        createDrawing: function createDrawing(path, x, y) {
            var me = this,
                pt = me.projectEditor,
                mp = me.masterPanel,
                b = new DPO.math.Rect(0, 0, mp.width / 2, mp.height / 2),
                stroke, strokeWidth, fill, opacity, fillSpot, strokeSpot;
            if (path.match(/\s*<\s*path/i)) {
                var el = Snap.parse(path).select('path');
                fill = el.node.getAttribute('fill');
                fillSpot = el.node.getAttribute('dpo8:fill-spot');
                stroke = el.node.getAttribute('stroke');
                strokeSpot = el.node.getAttribute('dpo8:stroke-spot');
                strokeWidth = el.node.style.strokeWidth;
                opacity = el.node.style.opacity;
                path = el.attr('path');
            }

            var drawing = pt.createDrawing(path, b);
            if (stroke) {
                drawing.outline.color = stroke.replace('#', '0x');
            }
            if (strokeSpot) {
                drawing.outline.spotColor = strokeSpot;
            }
            if (strokeWidth) {
                drawing.outline.width = (strokeWidth.replace(/[a-zA-Z]+/, '') - 0) * 20;
            }
            if (opacity) {
                drawing.opacity = opacity - 0;
                drawing.outline.opacity = opacity - 0;

            }
            if (fill && fill !== 'none') {
                drawing.color = fill.replace('#', '0x');
            }
            if (fillSpot) {
                drawing.spotColor = fillSpot;
            }

            if (fill && fill === 'none') {
                drawing.opacity = 0;
            }

            me.transformTool.editTextBlock(null);
            pt.beginUpdates();

            pt.addFieldToPanel(drawing, this.panel);
            me.alignFieldToPos(drawing, x, y, mp.width, mp.height);
            drawing.position = pt.findBestPlace(drawing, me.panel);

            pt.endUpdates();
            me.transformTool.selectFields([drawing]);
            return drawing;
        },

        createImage: function createImage(source, x, y, width, height, preventSizeProcessing) {
            var me = this,
                pt = me.projectEditor,
                mp = me.masterPanel,
                w = mp.width / 2,
                h = mp.height / 2,
                aspect = width / height,
                img;

            if (w > h) {
                w = h * aspect;
            } else {
                h = w / aspect;
            }

            me.transformTool.editTextBlock(null);
            pt.beginUpdates();

            if (preventSizeProcessing) {
                img = pt.createImage(source, width, height);
                img.position.x = x;
                img.position.y = y;
            } else {
                img = pt.createImage(source, w, h);
                me.alignFieldToPos(img, x, y, mp.width, mp.height);
            }
            pt.addFieldToPanel(img, me.panel);

            if (!preventSizeProcessing) {
                img.position = pt.findBestPlace(img, me.panel);
            }

            pt.endUpdates();
            me.transformTool.selectFields([img]);
            return img;
        },

        createBackground: function createBackground(sourse, width, height, keepAspect) {
            var me = this,
                pt = me.projectEditor,
                result;
            pt.beginUpdates();
            result = pt.createBackground(sourse, width, height, me.panel, keepAspect);
            pt.endUpdates();
            return result;
        },

        /**
         * Add barcode to canvas
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Barcode} barcode
         * @param {number} [x]
         * @param {number} [y]
         */
        createBarcode: function createBarcode(barcode, x, y) {
            var me = this,
                pt = me.projectEditor,
                mp = me.masterPanel;
            me.transformTool.editTextBlock(null);
            pt.beginUpdates();
            pt.addFieldToPanel(barcode, this.panel);
            me.alignFieldToPos(barcode, x, y, mp.width, mp.height);
            barcode.position = pt.findBestPlace(barcode, me.panel);

            pt.endUpdates();
            me.transformTool.selectFields([barcode]);
        },

        /**
         * Add Serial Number to canvas
         * @memberof DPO.render.Editor#
         * @param {DPO.model.SerialNumber} serialNumber
         * @param {number} [x]
         * @param {number} [y]
         */
        createSerialNumber: function createSerialNumber(serialNumber, x, y) {
            var me = this,
                pt = me.projectEditor,
                tt = me.transformTool,
                fields = me.selectedFields,
                mp = me.masterPanel,
                count = me.context.selector.serialNumbersCount(serialNumber),
                textEditor = tt.textEditCfg.textEditor,
                textBlock;

            pt.beginUpdates();
            pt.adjustSheetForDataBinding(me.panel, count);
            if (fields.length && textEditor) {
                tt.insertSerialNumber(serialNumber);
            } else {
                textBlock = pt.addSerialNumber(null, serialNumber);
                textBlock.height = me.preferredTextBlockHeight(textBlock);
                pt.addFieldToPanel(textBlock, me.panel);
                me.alignFieldToPos(textBlock, x, y, mp.width, mp.height);
                pt.fireAccumulativeEvent('changed:field:content', [textBlock]);
            }
            pt.fireAccumulativeEvent('changed:field-order', [me.panel]);
            pt.endUpdates();

            if (!fields.length) {
                tt.selectFields([textBlock]);
            }
        },

        /**
         * Updates serial number
         * @memberof DPO.render.Editor#
         * @param {string} id serial number id
         * @param {DPO.model.SerialNumber|object} sn
         * @returns {DPO.model.SerialNumber}
         */
        updateSerialNumber: function updateSerialNumber(id, sn) {
            var me = this,
                pt = me.projectEditor,
                selector = pt.selector,
                tt = me.transformTool,
                cfg = tt.textEditCfg,
                textBlock = cfg.originalTextBlock,
                original = selector.getSerialNumber(id),
                fields;
            if (original) {
                pt.beginUpdates();
                fields = pt.selector.selectFields(function (f) {
                    return f instanceof DPO.model.TextBlock || f instanceof DPO.model.Barcode;
                });
                DPO.mixin(original, sn);
                pt.adjustSheetForDataBinding(me.panel, selector.serialNumbersCount(original));
                pt.fireContentChanged(fields);
                pt.endUpdates();
                tt.editTextBlock(null);
                tt.editTextBlock(textBlock);
            }
            return original;
        },

        /**
         * Add text block to canvas and select it
         * @memberof DPO.render.Editor#
         * @param {number} [x]
         * @param {number} [y]
         * @returns {DPO.model.TextBlock}
         */
        createTextBlock: function createTextBlock(x, y) {
            var me = this,
                pt = me.projectEditor,
                mp = this.masterPanel,
                textDefaults = mp.textDefaults[0],
                textBlock = pt.createTextBlock(textDefaults);
            me.transformTool.editTextBlock(null);
            pt.beginUpdates();
            textBlock.height = me.preferredTextBlockHeight(textBlock);
            pt.addFieldToPanel(textBlock, this.panel);
            if (x != null) {
                me.alignFieldToPos(textBlock, x, y, mp.width, mp.height);
            }

            textBlock.position = pt.findBestPlace(textBlock, me.panel);

            pt.endUpdates();

            me.transformTool.selectFields([textBlock]);
            me.transformTool.editTextBlock(textBlock);
            me.transformTool.selectAllText();
            return textBlock;
        },

        /**
         * Add text path to canvas and select it
         * @memberof DPO.render.Editor#
         * @param {number} [x]
         * @param {number} [y]
         * @returns {DPO.model.TextPath}
         */
        createTextPath: function createTextPath(x, y) {
            var me = this,
                pt = me.projectEditor,
                mp = this.masterPanel,
                textDefaults = mp.textDefaults[0],
                textPath = pt.createTextPath(textDefaults);

            me.transformTool.editTextBlock(null);
            pt.beginUpdates();
            pt.addFieldToPanel(textPath, this.panel);
            me.alignFieldToPos(textPath, x, y, mp.width, mp.height);
            textPath.position = pt.findBestPlace(textPath, me.panel);
            pt.endUpdates();
            me.transformTool.selectFields([textPath]);
            me.transformTool.editTextBlock(textPath);
            me.transformTool.selectAllText();
            return textPath;
        },

        /**
         * Change outline properties of drawing
         * @memberof DPO.render.Editor#
         * @param {number} width
         * @param {boolean} [animated]
         */
        changeDrawingOutlineWidth: function changeDrawingOutlineWidth(width, animated) {
            var me = this,
                pt = me.projectEditor,
                selectedFields = me.selectedFields,
                field;
            if (!selectedFields.length) {
                return;
            }

            if (animated) {
                me.scheduleAnimation(me.animateOutlineWidth, 'changed:field:style');
                pt.suspendEvents(me, /changed:field:style/);
            }

            pt.beginUpdates();
            pt.setOutlineWidth(selectedFields, width);
            pt.endUpdates();

            if (animated) {
                pt.resumeEvents(me);
                me.transformTool.update();
            }
        },

        /**
         * Transforms background field to image field
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Background} background
         */
        transformBackgroundToImage: function transformBackgroundToImage(background) {
            var me = this,
                pt = me.projectEditor,
                mp = me.masterPanel;
            me.loadOriginalSizes([background], function (res) {
                pt.beginUpdates();
                var img = pt.transformBackgroundToImage(/** @type DPO.model.Background */ background, me.panel),
                    obj = res[0],
                    aspect = obj.img.naturalWidth / obj.img.naturalHeight;
                me.updateFields([img]);
                me.adjustFieldSizeToMasterPanel(img, mp, aspect);
                pt.centerFields([img], true, true, {x: 0, y: 0, width: mp.width, height: mp.height});
                pt.endUpdates();

                me.transformTool.selectFields([img]);
            });
        },

        transformImageToBackground: function transformImageToBackground(image, keepAspect) {
            var me = this,
                pt = me.projectEditor,
                mp = me.masterPanel,
                selector = pt.selector,
                backgrounds = selector.selectBackgrounds(pt.editOne ? me.panel : mp),
                fieldsToLoad = [].concat(backgrounds);

            if (keepAspect) {
                fieldsToLoad.push(image);
            }

            me.loadOriginalSizes(fieldsToLoad, function (res) {
                function findAspect(source) {
                    for (var i = 0; i < res.length; i++) {
                        var obj = res[i];
                        if (obj.field.source === source) {
                            return obj.img.naturalWidth / obj.img.naturalHeight;
                        }
                    }
                    return 1;
                }

                pt.beginUpdates();
                var result = pt.transformImageToBackground(/** @type DPO.model.Image */ image, me.panel),
                    resultAspect = keepAspect ? findAspect(result.background.source) : null;
                for (var i = 0; i < result.transformBackgrounds.length; i++) {
                    var field = result.transformBackgrounds[i],
                        fieldAspect = findAspect(field.source);
                    me.adjustFieldSizeToMasterPanel(field, mp, fieldAspect);
                    pt.centerFields([field], true, true, {x: 0, y: 0, width: mp.width, height: mp.height});
                    field.position = pt.findBestPlace(field, me.panel);
                }
                pt.placeBackground(result.background, me.panel, resultAspect);
                pt.endUpdates();

                me.transformTool.selectFields([result.background]);
            });
        },

        setBackgroundColor: function setBackgroundColor(color) {
            var me = this,
                pt = me.projectEditor,
                mp = me.masterPanel,
                selector = pt.selector,
                backgrounds = selector.selectBackgrounds(pt.editOne ? me.panel : mp);
            me.loadOriginalSizes(backgrounds, function (res) {
                function findAspect(source) {
                    for (var i = 0; i < res.length; i++) {
                        var obj = res[i];
                        if (obj.field.source === source) {
                            return obj.img.naturalWidth / obj.img.naturalHeight;
                        }
                    }
                    return 1;
                }

                pt.beginUpdates();
                var images = pt.setBackgroundColor(me.masterPanel, color);
                for (var i = 0; i < images.length; i++) {
                    var field = images[i],
                        aspect = findAspect(field.source);
                    me.adjustFieldSizeToMasterPanel(field, mp, aspect);
                    pt.centerFields([field], true, true, {x: 0, y: 0, width: mp.width, height: mp.height});
                    field.position = pt.findBestPlace(field, me.panel);
                }
                pt.endUpdates();

            });
        },

        placeBackground: function placeBackground(background, animated) {
            var me = this,
                pt = me.projectEditor;

            if (animated) {
                me.scheduleAnimation(me.animateImageAndBackgroundPosition, 'changed:field:geometry');
                pt.suspendEvents(me, /changed:field:geometry/);
            }

            pt.beginUpdates();
            pt.placeBackground(background, me.panel);
            pt.endUpdates();

            if (animated) {
                pt.resumeEvents(me);
            }
        },

        restoreBackgroundAspect: function restoreBackgroundAspect(background, animated) {
            var me = this,
                pt = me.projectEditor;
            me.loadOriginalSizes([background], function loaded(res) {
                if (animated) {
                    me.scheduleAnimation(me.animateImageAndBackgroundPosition, 'changed:field:geometry');
                    pt.suspendEvents(me, /changed:field:geometry/);
                }

                var obj = res[0],
                    aspect = obj.img.naturalWidth / obj.img.naturalHeight;
                pt.beginUpdates();
                pt.placeBackground(background, me.panel, aspect);
                pt.endUpdates();
                if (animated) {
                    pt.resumeEvents(me);
                }
            });
        },

        adjustFieldSizeToMasterPanel: function adjustFieldSizeToMasterPanel(field, master, aspect) {
            if (master.width > master.height) {
                field.width = (master.height / 3) * aspect;
                field.height = master.height / 3;
            } else {
                field.width = master.width / 3;
                field.height = (master.width / 3) / aspect;
            }
        },

        loadOriginalSizes: function loadOriginalSizes(fields, callback) {
            var filtered = [],
                urls = [],
                result = [],
                storage = this.context.storage, i, f;
            for (i = 0; i < fields.length; i++) {
                f = fields[i];
                if ((f instanceof DPO.model.Image || f instanceof DPO.model.Background) && f.source) {
                    filtered.push(f);
                }
            }

            if (filtered.length === 0) {
                callback([]);
                return filtered;
            }

            var requestImage = function requestImage(obj) {
                    var img = new Image();
                    obj.img = img;
                    img.addEventListener('load', function () {
                        result.push(obj);
                        if (result.length === filtered.length) {
                            callback(result);
                        }
                    });
                    img.src = obj.url;
                },
                loadImages = function loadImages() {
                    for (var i = 0; i < urls.length; i++) {
                        requestImage(urls[i]);
                    }
                };
            for (i = 0; i < filtered.length; i++) {
                f = filtered[i];
                urls.push({
                    field: f,
                    url: storage.urlForField(f)
                });
            }

            loadImages();

            return filtered;
        },

        pasteFields: function pasteFields(fields) {
            var me = this,
                pt = me.projectEditor,
                content = me.content,
                added;

            fields.forEach(function (field) {
                field.position = pt.findBestPlace(field, me.panel);
            });

            pt.beginUpdates();
            added = pt.pasteFields(fields, me.panel);
            pt.endUpdates();

            me.updateFields(added);
            me.transformTool.selectFields(added);

            for (var i = 0; i < added.length; i++) {
                var el = content.select('#' + me.fieldMarkupId(added[i]));
                el.attr({opacity: 0}).animate({opacity: 1.0}, 300, mina.easein);
            }

            return added;
        },

        /**
         * Sends fields to back.
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         */
        sendToBack: function sendToBack(fields) {
            var me = this,
                order = me.context.selector.getFieldOrder();
            order.sendToBack(fields);
            me.applyOrder(fields, order, -0.1);
        },

        /**
         * Sends fields backward
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         */
        sendBackward: function sendBackward(fields) {
            var me = this,
                order = me.context.selector.getFieldOrder();
            order.sendBackward(fields);
            me.applyOrder(fields, order, -0.05);
        },

        /**
         * Brings fields to front.
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         */
        bringToFront: function bringToFront(fields) {
            var me = this,
                order = me.context.selector.getFieldOrder();
            order.bringToFront(fields);
            me.applyOrder(fields, order, 0.1);
        },

        /**
         * Brings fields forward
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         */
        bringForward: function bringForward(fields) {
            var me = this,
                order = me.context.selector.getFieldOrder();
            order.bringForward(fields);
            me.applyOrder(fields, order);
        },

        applyOrder: function applyOrder(fields, order, d) {
            var me = this,
                content = me.content;
            d = d || 0.05;
            me.projectEditor.beginUpdates();
            me.projectEditor.applyFieldOrder(order);
            me.projectEditor.endUpdates();

            for (var i = 0; i < fields.length; i++) {
                var el = content.select('#' + me.fieldMarkupId(fields[i]));
                animateReorder(el, d);
            }
        },

        /**
         * Returns array of locked fields
         * @memberof DPO.render.Editor#
         * @returns {DPO.model.Field[]}
         */
        getLockedFields: function getLockedFields() {
            return this.transformTool.getLockedFields();
        },

        /**
         * Lock fields (disable selection & editing)
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         */
        lockFields: function lockFields(fields) {
            this.transformTool.lockFields(fields);
        },

        /**
         * Unlock fields (enable selection & editing)
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         */
        unlockFields: function lockFields(fields) {
            this.transformTool.unlockFields(fields);
        },

        /**
         * Sets fill color & opacity
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {DPO.model.Color} color
         */
        setFillColor: function setFillColor(fields, color) {
            var pt = this.projectEditor;
            pt.beginUpdates();
            pt.setFillColor(fields, color);
            pt.endUpdates();
        },

        /**
         * Sets fill color & opacity
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field|DPO.model.Field[]} fields
         * @param {DPO.model.Color} color
         */
        setOutlineColor: function setOutlineColor(fields, color) {
            var pt = this.projectEditor;
            pt.beginUpdates();
            pt.setOutlineColor(fields, color);
            pt.endUpdates();
        },

        /**
         * Sets text angle
         * @memberof DPO.render.Editor#
         * @param {DPO.model.TextPath[]} fields
         * @param {number} angle Text angle in degrees
         * @param {boolean} [animated]
         */
        setTextAngle: function setTextAngle(fields, angle, animated) {
            var me = this,
                pt = me.projectEditor;
            if (animated) {
                me.scheduleAnimation(me.animateTextPathAngle, 'changed:field:geometry');
                pt.suspendEvents(me, /changed:field:geometry/);
            }

            pt.beginUpdates();
            pt.setTextAngle(fields, angle);
            pt.endUpdates();

            if (animated) {
                pt.resumeEvents(me);
            }
        },

        /**
         * Calculate optimal zoom value & scroll offset
         * @memberof DPO.render.Editor#
         * @param {{top: number, right: number, bottom: number, left: number}} [padding]
         */
        autoZoom: function autoZoom(padding) {
            var me = this;
            padding = padding || me.zoomPadding;

            var panelCfg = me.panelCfg,
                el = me.workingArea,
                box = el.getBoundingClientRect(),
                paddingWidth = padding.left + padding.right,
                paddingHeight = padding.top + padding.bottom,
                zw = (box.width - paddingWidth) * 0.75 / panelCfg.width,
                zh = (box.height - paddingHeight) * 0.75 / panelCfg.height,
                z = Math.min(zw, zh) - 0.05;
            z = Math.floor(z / 0.05) * 0.05;
            z = Math.min(z, me.maxZoom);
            z = Math.max(z, me.minZoom);
            me.setZoomLevel(z, true);

            var cfg = me.viewPortCfg,
                w = el.scrollWidth,
                h = el.scrollHeight;
            el.scrollLeft = Math.max(0, (w - cfg.areaBox.width) / 2) + (padding.right - padding.left) / 2;
            el.scrollTop = Math.max(0, (h - cfg.areaBox.height) / 2) - (padding.top - padding.bottom) / 2;
        },

        /**
         * Scrolls to center
         * @memberof DPO.render.Editor#
         */
        scrollToCenter: function scrollToCenter() {
            var me = this,
                el = me.workingArea,
                cfg = me.viewPortCfg,
                w = el.scrollWidth,
                h = el.scrollHeight;
            el.scrollLeft = Math.max(0, (w - cfg.areaBox.width) / 2);
            el.scrollTop = Math.max(0, (h - cfg.areaBox.height) / 2);
        },

        /**
         * Returns panel's visible fields
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Panel} [panel]
         * @returns {DPO.model.Field[]}
         */
        getVisibleFields: function getVisibleFields(panel) {
            panel = panel || this.panel;

            return this.$super.getVisibleFields.call(this, panel);
        },

        /**
         * Change current panel
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Panel} value
         * @param {boolean} [skipAutoZoom]
         * @param {boolean} [keepTextEditing]
         */
        changePanel: function changePanel(value, skipAutoZoom, keepTextEditing) {
            var me = this,
                prevPanel = me._panel;
            if (prevPanel === value) {
                return;
            }

            if (!keepTextEditing) {
                me.transformTool.editTextBlock(null);
            }

            me.transformTool.cropImage(null);

            var ctx = me.context,
                pages = ctx.project.pages,
                pageIndex = null,
                panelIndex = null,
                page = null;
            for (var i = 0; !page && i < pages.length; i++) {
                panelIndex = pages[i].panels.indexOf(value);
                if (panelIndex !== -1) {
                    page = pages[i];
                    pageIndex = i;
                }
            }

            if (!page) {
                throw new DPO.InvalidArgumentException('value', 'panel does not belong to current project');
            }

            var mp = ctx.selector.selectMasterPanel(/** @type string*/value.master),
                wpt = mp.width / 20,
                hpt = mp.height / 20,
                viewBox = '0 0 ' + wpt + ' ' + hpt;
            me.panelCfg = {
                master: mp,
                width: mp.width / 20,
                height: mp.height / 20,
                viewBox: viewBox
            };
            me.canvas.attr('viewBox', viewBox);
            me._page = page;
            me._panel = value;
            me.masterPanel = mp;
            me.pageIndex = pageIndex;
            me.panelIndex = panelIndex;
            me.projectEditor.panel = value;
            me.transformTool.recordIndex = ctx.selector.panelIndex(value);
            me.transformTool.selectFields([]);

            var masterChanged = !prevPanel || prevPanel.master !== value.master;
            me.update();

            if (masterChanged && !skipAutoZoom) {
                me.configureViewPort();
                me.updateViewPort();

                if (me.enableAutoZoom) {
                    me.autoZoom();
                } else {
                    me.scrollToCenter();
                }
            }
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Properties
    // -----------------------------------------------------------------------------------------------------------------
    Object.defineProperty(Editor.prototype, 'page', {
        get: function get() {
            return this._page;
        }
    });

    Object.defineProperty(Editor.prototype, 'panel', {
        get: function get() {
            return this._panel;
        },

        set: function set(value) {
            this.changePanel(value, false);

        }
    });

    Object.defineProperty(Editor.prototype, 'zoom', {
        get: function get() {
            return this._zoom;
        },

        set: function set(value) {
            this.setZoomLevel(value);
        }
    });

    Object.defineProperty(Editor.prototype, 'selectedFields', {
        get: function get() {
            return this.transformTool ? this.transformTool.selectedFields : [];
        }
    });

    Object.defineProperty(Editor.prototype, 'context', {
        get: function get() {
            return this._context;
        },

        set: function set(value) {
            var me = this, pt, cs;
            if (me._context === value) {
                return;
            }

            if (me._context) {
                me._context.un('changed:color-space', me.onColorSpaceChanged, me);
                me._context.layoutManager.un('fonts:loaded', me.updateContent, me);
                me._context.storage.un('image:generated', me.onImageGenerated, me);
                me._context.provider.un(/changed:data-source.*/, me.updateContent, me);
                pt = me.context.projectTransformer;
                cs = me.context.colorSpace;
                if (cs) {
                    cs.un('gamut:loaded', me.updateContent, me);
                }
                if (pt) {
                    pt.un('restored:snapshot', me.onSnapshotRestored, me);
                    pt.un('changed:field-order', me.onFieldOrderChanged, me);
                    pt.un('broke:reference', me.onBrokeReference, me);
                    pt.un(/changed:field:.*/, me.onFieldsChanged, me);
                    pt.un(/added:field.*/, me.onFieldsAdded, me);
                    pt.un(/deleted:field.*/, me.onFieldsDeleted, me);
                    pt.un(/serial-number/, me.updateContent, me);

                    me.context.layoutManager.un('fonts:loaded', me.updateContent, me);
                    me.context.storage.un('image:generated', me.onImageGenerated, me);
                    me.context.storage.un('image:progress', me.onImageProgress, me);
                    me.context.provider.un(/changed:data-source.*/, me.updateContent, me);

                    me.transformTool.destroy();
                    me.transformTool = null;
                }
            }

            me.detachListeners();
            me._context = value;
            pt = value ? value.projectTransformer : null;

            if (value) {
                pt = me._context.projectTransformer;
                cs = me._context.colorSpace;
                me._context.on('changed:color-space', me.onColorSpaceChanged, me);
                me._context.layoutManager.on('fonts:loaded', me.updateContent, me);
                me._context.storage.on('image:generated', me.onImageGenerated, me);
                me._context.storage.on('image:progress', me.onImageProgress, me);
                me._context.provider.on(/changed:data-source.*/, me.updateContent, me);

                if (cs) {
                    cs.on('gamut:loaded', me.updateContent, me);
                }

                if (pt) {
                    pt.on('restored:snapshot', me.onSnapshotRestored, me);
                    pt.on('changed:field-order', me.onFieldOrderChanged, me);
                    pt.on('broke:reference', me.onBrokeReference, me);
                    pt.on(/changed:field:.*/, me.onFieldsChanged, me);
                    pt.on(/added:field.*/, me.onFieldsAdded, me);
                    pt.on(/deleted:field.*/, me.onFieldsDeleted, me);
                    pt.on(/serial-number/, me.updateContent, me);
                    me.projectEditor = value.projectEditor;
                    me.transformTool = new DPO.render.MouseTransformTool({
                        renderer: me,
                        canvas: me.canvas,
                        context: me.context,
                        coordinateTransformer: me,
                        projectEditor: me.projectEditor,

                        //----------------
                        workingArea: me.workingArea,
                        root: me.root,
                        el: me.canvas.g({
                            id: me.id + '-transform-tool'
                        }),
                        editor: me,
                        projectTransformer: me.context.projectTransformer
                    });

                    me.transformTool.on('begin:text:editing', me.onTextEditModeChanged, me);
                    me.transformTool.on('end:text:editing', me.onTextEditModeChanged, me);
                    me.transformTool.on('changed:fields', me.onFieldsChanged, me);
                    me.transformTool.on('changed:position', me.onFieldsPositionChanged, me);
                    me.transformTool.on('changed:size', me.onFieldsSizeChanged, me);
                    me.panel = value.project.pages[0].panels[0];
                    me.initListeners();
                }
            }
        }
    });

    Object.defineProperty(Editor.prototype, 'bleedLabelCfg', {
            get: function get() {
                return this._bleedLabelCfg;
            },
            set: function set(value) {
                if (this._bleedLabelCfg !== value) {
                    this._bleedLabelCfg = value;
                    this.refreshLabels();
                }
            }
        }
    );

    Object.defineProperty(Editor.prototype, 'safeLabelCfg', {
            get: function get() {
                return this._safeLabelCfg;
            },
            set: function set(value) {
                if (this._safeLabelCfg !== value) {
                    this._safeLabelCfg = value;
                    this.refreshLabels();
                }
            }
        }
    );

    // -----------------------------------------------------------------------------------------------------------------
    // -- Private Methods
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(Editor.prototype, {
        onColorSpaceChanged: function onColorSpaceChanged(sender, colorSpace) {
            var me = this;
            if (!colorSpace || colorSpace.ready) {
                this.updateContent();
            } else {
                colorSpace.on('gamut:loaded', me.updateContent, me);
            }
        },

        setZoomLevel: function setZoomLevel(zoom, skipScrollAdjustment) {
            var me = this;
            if (me._zoom !== zoom) {
                var el = me.workingArea,
                    sw = el.scrollWidth,
                    sh = el.scrollHeight;
                me._zoom = zoom;
                me.configureViewPort();
                me.updateViewPort();
                me.refreshGrid();
                me.refreshLabels();
                me.fire('changed:zoom', [me, zoom]);

                if (!skipScrollAdjustment) {
                    el.scrollLeft += (el.scrollWidth - sw) / 2;
                    el.scrollTop += (el.scrollHeight - sh) / 2;
                }
            }
        },

        initialize: function initialize() {
            var me = this;
            me.render();
        },

        refreshGrid: function refreshGrid() {
            var me = this,
                cfg = me.gridMode,
                zoom = me.zoom,
                g = Math.round(1 / zoom),
                step = (cfg.gradation[g] || 10) * cfg.pointsPerUnit,
                pixels = step / 1.5 * zoom,
                divider = pixels / cfg.pixelsPerDivider,
                d = Infinity,
                n = 20;
            for (var i = 0; i < cfg.dividers.length; i++) {
                if (d > Math.abs(divider - cfg.dividers[i])) {
                    d = Math.abs(divider - cfg.dividers[i]);
                    n = cfg.dividers[i];
                }
            }

            var id = me.id,
                outerStep = step,
                innerStep = step / n,
                outerPath = Snap.format('M 0 {step} L {step} {step} {step} 0', {step: outerStep}),
                pathEl = Snap('#' + id + '-outer-path'),
                dividerPattern = Snap('#' + id + '-divider-pattern'),
                gridPatternEl = Snap('#' + id + '-grid-pattern');
            pathEl.attr({
                d: outerPath
            });
            dividerPattern.attr({
                viewBox: [0, 0, innerStep, innerStep].join(' '),
                width: innerStep,
                height: innerStep,
                strokeWidth: 0.7 / zoom
            });
            gridPatternEl.attr({
                viewBox: [0, 0, outerStep, outerStep].join(' '),
                width: outerStep,
                height: outerStep,
                strokeWidth: 1 / zoom
            });

            me.grid.attr({
                strokeWidth: 1 / zoom
            });
        },

        refreshLabels: function refreshLabels() {
            var me = this,
                zoom = me.zoom,
                blc = me.bleedLabelCfg,
                slc = me.safeLabelCfg,
                labels = [
                    blc ? blc.text : '',
                    slc ? slc.text : ''
                ],
                metrics = me.calculateBleedSafeLabelMetric(me.panel, labels, me.zoom),
                markup;
            me.labels.clear();
            me.labels.attr({
                strokeWidth: 0.5 / zoom
            });

            if (blc && me.masterPanel.bleed && !blc.hidden) {
                markup = me.bleedLabelMarkup(me.panel, blc.text, metrics);
                DPO.mixin(markup.getMarkup(/-path$/).style, blc.pathStyle);
                markup.getMarkup(/-warning$/).style.display = blc.displayWarning ? 'inline' : 'none';
                me.labels.dpoRender(markup);
            }

            if (slc && !slc.hidden) {
                markup = me.safeLabelMarkup(me.panel, slc.text, metrics);
                DPO.mixin(markup.getMarkup(/-path$/).style, slc.pathStyle);
                markup.getMarkup(/-warning$/).style.display = slc.displayWarning ? 'inline' : 'none';
                me.labels.dpoRender(markup);
            }
        },

        configureViewPort: function configureViewPort() {
            var me = this,
                panelCfg = me.panelCfg,
                box = me.workingArea.getBoundingClientRect(),
                width = panelCfg.width * me.zoom,
                height = panelCfg.height * me.zoom,
                canvasWidth = width + box.width * 1.5,
                canvasHeight = height + box.height * 1.5;
            me.viewPortCfg = {
                areaBox: box,
                x: (canvasWidth - width) / 2 + 'pt',
                y: (canvasHeight - height) / 2 + 'pt',
                cx: (canvasWidth) / 2 / 0.75,
                cy: (canvasHeight) / 2 / 0.75,
                width: width + 'pt',
                height: height + 'pt',
                canvasWidth: canvasWidth + 'pt',
                canvasHeight: canvasHeight + 'pt'
            };
        },

        updateViewPort: function updateViewPort() {
            var me = this,
                cfg = me.viewPortCfg,
                renderAttr = {
                    x: cfg.x,
                    y: cfg.y,
                    width: cfg.width,
                    height: cfg.height
                };

            me.rotate(me.rotation);
            me.canvas.attr(renderAttr);
            me.root.attr({
                width: cfg.canvasWidth,
                height: cfg.canvasHeight
            });
        },

        update: function update() {
            var me = this;
            me.grid.clear();
            me.content.clear();
            me.canvas.select('defs').node.innerHTML = '';
            me.updateContent();
            me.renderGrid();
            me.renderLabels();
        },

        updateContent: function updateContent() {
            DPO.render.RenderComponent.prototype.updateContent.apply(this, arguments);
            this.transformTool.updateTextSelection();
        },

        /**
         * Updates fields
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         * @param {string} [method]
         */
        updateFields: function updateFields(fields, method) {
            var me = this,
                tt = me.transformTool,
                editableId = tt.textEditCfg.textEditor && tt.textEditCfg.textEditor.textBlockId,
                content = me.content;

            fields = me.filterVisibleFields(fields);
            method = method || 'dpoUpdate';

            for (var i = 0; i < fields.length; i++) {
                var index = me.context.selector.panelIndex(me.panel),
                    f = fields[i],
                    markup = me.fieldMarkup(f, null, index, false, editableId === f.id),
                    el = content.select('#' + me.fieldMarkupId(f));
                content[el ? method : 'dpoRender'](markup);
            }
        },

        renderGrid: function renderGrid() {
            function rebuildGrid(id, canvas, step, n, visible) {
                canvas.clear();

                var outerStep = step,
                    innerStep = step / n,
                    dividerPattern = canvas.rect({
                        width: '100%',
                        height: '100%',
                        fill: 'none',
                        stroke: '#d1d1d1'
                    }).pattern(0, 0, innerStep, innerStep).attr({
                        id: id + '-divider-pattern'
                    }),
                    outerPath = Snap.format('M 0 {step} L {step} {step} {step} 0', {step: outerStep}),
                    outerRect = canvas.path({
                        id: id + '-outer-path',
                        d: outerPath,
                        stroke: '#d1d1d1',
                        fill: 'none'
                    }),
                    outerPattern = canvas.rect({
                        width: '100%',
                        height: '100%',
                        fill: dividerPattern
                    }),
                    gridPattern = canvas.g(outerRect, outerPattern).pattern(0, 0, outerStep, outerStep).attr({
                        id: id + '-grid-pattern'
                    });
                canvas.rect({
                    id: id + '-grid-pattern-rect',
                    x: 0,
                    y: 0,
                    width: '100%',
                    height: '100%',
                    display: visible ? 'inline' : 'none',
                    fill: gridPattern
                });
            }

            this.grid.clear();

            var me = this,
                cfg = me.panelCfg,
                multiplier = 50,
                s = Math.max(cfg.width, cfg.height),
                shape = me.toPath(me.shapeMarkup(me.panel)),
                params = {
                    sx: -s * multiplier,
                    sy: -s * multiplier,
                    ex: s * multiplier + s,
                    ey: s * multiplier + s,
                    p: shape.geometry.d
                },
                trimPath = shape.geometry.d,
                bleedPath = trimPath,
                safePath = trimPath,
                box = Snap.path.getBBox(bleedPath),
                deflateScaleX = (box.width - 9) / box.width,
                deflateScaleY = (box.height - 9) / box.height,
                deflateMatrix = Snap.matrix().scale(deflateScaleX, deflateScaleY, box.cx, box.cy);
            safePath = Snap.path.map(safePath, deflateMatrix);
            me.isBleedVisible = me.masterPanel.bleed;
            if (me.masterPanel.bleed) {
                var inflateScaleX = (box.width + 9) / box.width,
                    inflateScaleY = (box.height + 9) / box.height,
                    inflateMatrix = Snap.matrix().scale(inflateScaleX, inflateScaleY, box.cx, box.cy);
                bleedPath = Snap.path.map(bleedPath, inflateMatrix);
            }

            params.p = bleedPath;

            var outerArea = Snap.format('M {sx},{sy} L {ex},{sy} L {ex},{ey} L {sx},{ey} z {p}', params),
                dangerousArea = Snap.format('{p1} z {p2}', {p1: bleedPath, p2: safePath});

            for (var i = 0; i < me.masterPanel.cutouts.length; i++) {
                var cutout = me.masterPanel.cutouts[i],
                    pos = cutout.position,
                    path = me.toPath(me.shapeMarkup(cutout), pos.x / 20, pos.y / 20);
                outerArea = outerArea + ' ' + path.geometry.d;
                trimPath = trimPath + ' ' + path.geometry.d;
            }

            me.grid.path(outerArea).attr({
                'class': 'outer-area',
                'fill': '#FFFFFF',
                'fill-opacity': 0.8,
                'fill-rule': 'evenodd',
                'pointer-events': 'none'
            });
            me.grid.path(dangerousArea).attr({
                'class': 'dangerous-area',
                'id': me.id + '-dangerous-area',
                'fill': '#FFFFFF',
                'fill-opacity': 0.4,
                'fill-rule': 'evenodd',
                'display': me.isDangerousAreaVisible ? 'inline' : 'none',
                'pointer-events': 'none'
            });
            me.grid.path(trimPath).attr({
                'class': 'trim-path',
                'id': me.id + '-trim-path',
                'stroke': '#B8C2C9',
                'stroke-opacity': 0.5,
                'stroke-width': 2.25,
                'fill': 'none',
                'pointer-events': 'none'
            });

            var group = me.grid.g({
                'clip-path': me.grid.path(trimPath),
                'pointer-events': 'none'
            });
            rebuildGrid(me.id, group, 50, 2, me.isGridVisible);
            me.renderBleedAndSafeAreas(me.grid, me.panel);

            var itemNumberMarkup = me.itemNumberMarkup(me.page, me.panel);
            me.grid.dpoRender(itemNumberMarkup);
            me.itemNumberVisible(me.isItemNumberVisible);
            me.refreshGrid();
        },

        renderLabels: function renderLabels() {
            var me = this;
            me.refreshLabels();
        },

        getScrollOffset: function getScrollOffset(x, y, zoom) {
            var el = this.workingArea,
                box = this.viewPortCfg.areaBox,
                cw = box.width,
                ch = box.height,
                canvasWidth = el.scrollWidth - 2 * cw,
                canvasHeight = el.scrollHeight - 2 * ch,
                canvasOffsetX = x - cw,
                canvasOffsetY = y - ch,
                u = canvasOffsetX / canvasWidth,
                v = canvasOffsetY / canvasHeight;
            canvasWidth = canvasWidth / this.zoom * zoom;
            canvasHeight = canvasHeight / this.zoom * zoom;

            var dx = u * canvasWidth - canvasOffsetX,
                dy = v * canvasHeight - canvasOffsetY;
            return {dx: Math.round(dx), dy: Math.round(dy)};
        },

        render: function render() {
            var me = this,
                svgNS = 'http://www.w3.org/2000/svg',
                workingAreaEl = document.createElement('div'),
                rootEl = document.createElementNS(svgNS, 'svg'),
                canvasEl = document.createElementNS(svgNS, 'svg');

            workingAreaEl.id = me.workingAreaId;
            workingAreaEl.classList.add('working-area');
            me.el.appendChild(workingAreaEl);
            workingAreaEl.appendChild(rootEl);
            rootEl.appendChild(canvasEl);

            me.workingArea = workingAreaEl;
            me.root = Snap(rootEl).attr({id: me.rootId});
            me.canvas = Snap(canvasEl).attr({id: me.canvasId});
            me.canvasTransform = me.root.g(me.canvas).attr({id: me.canvasTransformId});
            me.content = me.canvas.g().attr({id: me.contentId});
            me.grid = me.canvas.g().attr({id: me.gridId});
            me.labels = me.canvas.g().attr({id: me.labelsId, 'pointer-events': 'none'});

            DPO.render.applyStyles(workingAreaEl, {
                'width': '100%',
                'height': '100%',
                'overflow': 'auto',
                'background': 'white'
            });
            DPO.render.applyStyles(canvasEl, {
                'overflow': 'visible'
            });
            DPO.render.applyStyles(rootEl, {
                'overflow': 'hidden'
            });
            DPO.render.applyStyles(me.grid.node, {
                'pointer-events': 'none',
                'overflow': 'visible'
            });
        },

        initListeners: function initListeners() {
            var me = this;
            me.workingArea.addEventListener('mousewheel', me.mouseWheelListener);
            window.addEventListener('resize', me.windowResizeListener);
        },

        detachListeners: function detachListeners() {
            var me = this;
            window.removeEventListener('resize', me.windowResizeListener);
            if (me.workingArea) {
                me.workingArea.removeEventListener('mousewheel', me.mouseWheelListener);
            }
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Event Handlers
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(Editor.prototype, {
        onSnapshotRestored: function onSnapshotRestored() {
            var me = this,
                pages = me.context.project.pages,
                page = pages[me.pageIndex] || pages[0],
                selected = [].concat(me.selectedFields),
                panel = page.panels[me.panelIndex] || page.panels[0];
            me.changePanel(panel, true, !!page.panels[me.panelIndex]);

            var fields = [],
                f;
            for (var i = 0; i < selected.length; i++) {
                f = selected[i];
                f = me.context.selector.getField(f.id);
                if (f) {
                    fields.push(f);
                }
            }

            me.fire('restored:state', [me, me.panel]);
            if (fields.length !== 0) {
                me.transformTool.selectFields(fields);
            } else {
                me.transformTool.editTextBlock(null);
            }
        },

        reorderFields: function reorderFields() {
            var fields = this.getVisibleFields(this.panel),
                content = this.content;
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i],
                    id = this.fieldMarkupId(field),
                    el = content.select('#' + id);
                content.append(el);
            }
        },

        /**
         * Filters visible fields
         * @memberof DPO.render.Editor#
         * @param {DPO.model.Field[]} fields
         * @returns {DPO.model.Field[]}
         */
        filterVisibleFields: function filterVisibleFields(fields) {
            var visible = this.getVisibleFields(),
                result = [];
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (visible.indexOf(f) !== -1) {
                    result.push(f);
                }
            }

            return result;
        },

        onBrokeReference: function onBrokeReference(panel, changes) {
            if (panel !== this.panel) {
                return;
            }

            var me = this,
                content = me.content,
                tt = me.transformTool,
                fields = [];
            for (var i = 0; i < changes.length; i++) {
                var c = changes[i],
                    query = '#' + me.fieldMarkupId(c.masterField),
                    el = content.select(query);
                el.remove();
                fields.push(c.panelField);
            }

            me.updateFields(fields);
            me.reorderFields();
        },

        onFieldOrderChanged: function onFieldOrderChanged(panel) {
            if (this.panel === panel) {
                this.reorderFields();
            }
        },

        onTextEditModeChanged: function onTextEditModeChanged(sender, textBlock) {
            this.updateFields([textBlock]);
        },

        onFieldsChanged: function onFieldsChanged(fields) {
            fields = fields instanceof Array ? fields : [fields];
            fields = this.filterVisibleFields(fields);
            this.updateFields(fields);
            this.transformTool.update();
        },

        onFieldsPositionChanged: function onFieldsPositionChanged(fields) {
            var me = this,
                content = me.content;

            fields = me.filterVisibleFields(fields);
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    id = me.fieldMarkupId(f),
                    el = content.select('#' + id),
                    markup = me.wrapFieldMarkup(f, id, []),
                    m = markup.geometry.transform;
                el.node.setAttribute('transform', m.toString());
            }
        },

        onFieldsSizeChanged: function onFieldsSizeChanged(fields) {
            var me = this,
                content = me.content;

            fields = me.filterVisibleFields(fields);
            for (var i = 0; i < fields.length; i++) {
                var index = me.context.selector.panelIndex(me.panel),
                    f = fields[i],
                    markup = me.fieldMarkup(f, null, index);
                content.dpoUpdateSize(markup);
            }
        },

        onFieldsAdded: function onFieldsAdded(field, panels) {
            if (panels.indexOf(this.panel) !== -1) {
                this.updateFields([field]);
                this.reorderFields();
            }
        },

        onFieldsDeleted: function onFieldsDeleted(fields) {
            this.transformTool.deselectFields(fields);
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    query = '#' + this.fieldMarkupId(f),
                    el = Snap(query);
                if (el) {
                    el.remove();
                }
            }
        },

        onResize: function onResize() {
            var me = this,
                el = me.workingArea,
                prevBox = me.viewPortCfg.areaBox,
                currentBox;

            me.configureViewPort();
            me.updateViewPort();

            currentBox = me.viewPortCfg.areaBox;
            el.scrollLeft -= (prevBox.width - currentBox.width) / 2;
            el.scrollTop -= (prevBox.height - currentBox.height) / 2;
        },

        //
        // Nov 5, 2014
        // Smart zoom doesn't work on FireFox.
        // 1. FireFox doesn't support mousewheel event
        // 2. Wheel+Alt, Wheel+Ctrl and Wheel+MetaKey combinations registered for total page zoom
        // 3. Event DOMMouseScroll + stopPropagation & preventDefault doesn't help
        onMouseWheel: function onMouseWheel(event) {
            if (event.ctrlKey || event.altKey) {
                event.stopPropagation();
                event.preventDefault();

                var me = this,
                    el = this.workingArea,
                    delta = event.wheelDelta / 120 * 0.05,
                    zoom = me.zoom + delta;
                zoom = Math.min(zoom, me.maxZoom);
                zoom = Math.max(zoom, me.minZoom);

                var box = me.viewPortCfg.areaBox,
                    x = me.workingArea.scrollLeft + event.clientX - box.left,
                    y = me.workingArea.scrollTop + event.clientY - box.top,
                    offset = me.getScrollOffset(x, y, zoom);
                me.setZoomLevel(zoom, true);
                el.scrollLeft += offset.dx;
                el.scrollTop += offset.dy;
            }
        },

        onImageGenerated: function onImageGenerated(sender, name) {
            var me = this,
                content = me.content,
                selector = me.context.selector,
                fields = selector.selectFields(function (f) {
                    return f.source === name;
                }),
                index = selector.panelIndex(me.panel);

            fields = me.filterVisibleFields(fields);
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    markup = me.fieldMarkup(f, null, index),
                    id = me.fieldMarkupId(f),
                    indicatorWrapper = me.content.select('#' + id + '-indicator-wrapper');

                if (indicatorWrapper) {
                    indicatorWrapper.attr('display', 'none');
                }

                markup.overrideChildren = true;
                content.dpoUpdate(markup);
            }
        },

        onImageProgress: function onImageProgress(name, current, total) {
            var me = this,
                selector = me.context.selector,
                fields = selector.selectFields(function (f) {
                    return f.source === name;
                });

            fields = me.filterVisibleFields(fields);
            for (var i = 0; i < fields.length; i++) {
                var id = me.fieldMarkupId(fields[i]),
                    indicatorWrapper = me.content.select('#' + id + '-indicator-wrapper'),
                    indicator = me.content.select('#' + id + '-indicator');

                if (indicatorWrapper && indicator) {
                    indicatorWrapper.attr('display', 'block');
                    indicator.node.textContent = (current / (total || 1) * 100).toFixed(0) + '%';
                }
            }
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Animations
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(Editor.prototype, {
        /**
         * Schedule animation
         * @param {function} animation
         * @param {string} trigger
         * @returns {{animation: *, handler: Function}}
         */
        scheduleAnimation: function scheduleAnimation(animation, trigger) {
            var me = this,
                animator = {
                    handler: function handler(fields) {
                        animation.call(me, fields);
                        me.context.projectTransformer.un(trigger, animator.handler, animator);
                    }
                };

            this.context.projectTransformer.on(trigger, animator.handler, animator);
            return animator;
        },

        animateImageAndBackgroundPosition: function animateImageAndBackgroundPosition(fields) {
            var me = this,
                array = [], i;
            fields = me.filterVisibleFields(fields);

            for (i = 0; i < fields.length; i++) {
                var f = fields[i],
                    p = f.position,
                    id = me.fieldMarkupId(f),
                    el = me.content.select('#' + id),
                    img = me.content.select('#' + id + '-image'),
                    m = el.transform().localMatrix;
                array.push({
                    el: el,
                    node: el.node,
                    fromX: m.e,
                    fromY: m.f,
                    toX: p.x / 20,
                    toY: p.y / 20,
                    fromWidth: img.attr('width') - 0,
                    fromHeight: img.attr('height') - 0,
                    toWidth: f.width / 20,
                    toHeight: f.height / 20
                });
            }

            Snap.animate(0, 1, function (value) {
                for (var i = 0; i < array.length; i++) {
                    var obj = array[i],
                        x = obj.fromX + (obj.toX - obj.fromX) * value,
                        y = obj.fromY + (obj.toY - obj.fromY) * value,
                        width = obj.fromWidth + (obj.toWidth - obj.fromWidth) * value,
                        height = obj.fromHeight + (obj.toHeight - obj.fromHeight) * value,
                        m = Snap.matrix(1, 0, 0, 1, x, y);
                    obj.node.setAttribute('transform', m.toString());
                    obj.el.selectAll('rect, image').attr({
                        width: width,
                        height: height
                    });
                }
            }, 300, mina.easeinout, function () {
                me.fire('animation:finished');
            });
        },

        animateOutlineWidth: function animateOutlineWidth(fields) {
            var me = this,
                array = [], i;
            fields = me.filterVisibleFields(fields);
            for (i = 0; i < fields.length; i++) {
                var f = fields[i],
                    id = me.fieldMarkupId(f) + '-shape',
                    markup = me.fieldMarkup(f).getMarkup(id),
                    el = me.content.select('#' + id);
                array.push({
                    el: el,
                    from: el.attr('stroke-width').replace(/[a-zA-Z]+/, '') - 0,
                    to: markup.style['stroke-width']
                });
            }

            Snap.animate(0, 1, function (value) {
                for (var i = 0; i < array.length; i++) {
                    var obj = array[i],
                        v = obj.from + (obj.to - obj.from) * value;
                    obj.el.attr({'stroke-width': v});
                }
            }, 200, mina.easeinout, function () {
                me.fire('animation:finished');
            });
        },

        animateTextPathAngle: function animateTextPathAngle(fields) {
            var me = this,
                array = [], i;
            fields = me.filterVisibleFields(fields);
            for (i = 0; i < fields.length; i++) {
                var index = me.context.selector.panelIndex(me.panel),
                    f = fields[i],
                    id = me.fieldMarkupId(f) + '-text-path',
                    markup = me.fieldMarkup(f, null, index).getMarkup(id),
                    el = me.content.select('#' + id);
                array.push({
                    node: el.node,
                    from: el.attr('startOffset') - 0,
                    to: markup.geometry.startOffset
                });
            }

            Snap.animate(0, 1, function (value) {
                for (var i = 0; i < array.length; i++) {
                    var obj = array[i],
                        v = obj.from + (obj.to - obj.from) * value;
                    obj.node.setAttribute('startOffset', v);

                }
            }, 300, mina.easeinout, function () {
                me.transformTool.clearCharCache();
                me.transformTool.updateTextSelection();
                me.fire('animation:finished');
            });
        },

        animateTranslation: function animateTranslation(fields) {
            var me = this,
                array = [], i;
            fields = me.filterVisibleFields(fields);
            for (i = 0; i < fields.length; i++) {
                var f = fields[i],
                    p = f.position,
                    id = me.fieldMarkupId(f),
                    el = me.content.select('#' + id),
                    m = el.transform().localMatrix;

                array.push({
                    node: el.node,
                    fromX: m.e,
                    fromY: m.f,
                    r: f.rotation,
                    toX: p.x / 20,
                    toY: p.y / 20
                });
            }

            Snap.animate(0, 1, function (value) {
                for (var i = 0; i < array.length; i++) {
                    var obj = array[i],
                        x = obj.fromX + (obj.toX - obj.fromX) * value,
                        y = obj.fromY + (obj.toY - obj.fromY) * value,
                        m = Snap.matrix(1, 0, 0, 1, x, y).rotate(360 - obj.r, 0, 0);
                    obj.node.setAttribute('transform', m.toString());
                }
            }, 300, mina.easeinout, function () {
                me.fire('animation:finished');
            });
        }
    });

    return Editor;
});

DPO.def('render.TextMergeEditor', function (ns) {
    /**
     * Creates a new text merge editor object.
     * @class DPO.render.TextMergeEditor
     * @param {Element} el
     * @param {DPO.render.Context} context
     * @constructor
     */
    function TextMergeEditor(el, context) {
        var me = this,
            project, ctx;
        me.id = DPO.id();
        me.el = el;
        me.zoom = 1;
        me.originalContext = context;
        me._recordIndex = 0;

        project = me.createEmptyProject();
        project.serialNumbers = context.projectTransformer.clone(context.project.serialNumbers);
        ctx = new DPO.render.Context(project, context.layoutManager, context.storage, context.provider);
        ctx.projectTransformer.on(/changed:field:.*/, me.onFieldsChanged, me);
        ns.RenderComponent.apply(me, [ctx]);

        me.initialize();
    }

    DPO.inherit(TextMergeEditor, ns.RenderComponent);

    Object.defineProperty(TextMergeEditor.prototype, 'recordIndex', {
        get: function get() {
            return this._recordIndex;
        },

        set: function set(value) {
            this._recordIndex = value;
            this.tool.editTextBlock(null);
            this.editTextBlock(this.textBlock);
        }
    });

    // Coordinate Transformer Implementation
    DPO.mixin(TextMergeEditor.prototype, {
        getMouseOffset: function getMouseOffset(e) {
            var me = this,
                box = me.el.getBoundingClientRect(),
                x = me.el.scrollLeft + e.clientX - box.left,
                y = me.el.scrollTop + e.clientY - box.top;

            return {
                x: x,
                y: y
            };
        },

        getScale: function getScale() {
            return this.zoom;
        },

        /**
         * Creates matrix for conversion from canvas coordinate system to dmd coordinate system
         * @memberof DPO.render.TextMergeEditor#
         * @param {DPO.model.Field} field
         * @returns {*}
         */
        canvasToFieldMatrix: function canvasToFieldMatrix(field) {
            DPO.emptyFn(field);
            return Snap.matrix();
        },

        /**
         * Creates matrix for conversion from canvas coordinate system to client coordinate system
         * @memberof DPO.render.TextMergeEditor#
         * @param {boolean} [omitTranslation]
         * @returns {*}
         */
        canvasToClientMatrix: function canvasToClientMatrix(omitTranslation) {
            var me = this,
                box = me.fieldBox,
                scale = 1 / 0.75 * me.zoom,
                matrix = Snap.matrix().scale(scale);
            if (!omitTranslation) {
                matrix.translate(-box.x, -box.y);
            }
            return matrix;
        },

        /**
         * Creates matrix for conversion from client coordinate system to canvas coordinate system
         * @memberof DPO.render.TextMergeEditor#
         * @returns {*}
         */
        clientToCanvasMatrix: function clientToCanvasMatrix(omitTranslation) {
            var m = this.canvasToClientMatrix().invert();
            if (omitTranslation) {
                m.e = 0;
                m.f = 0;
            }
            return m;
        }
    });

    function Tool(cfg) {
        DPO.mixin(this, cfg);
    }

    DPO.mixin(Tool.prototype, DPO.render.TextTransformTool);

    DPO.mixin(TextMergeEditor.prototype, {
        initialize: function initialize() {
            var me = this,
                svgNS = 'http://www.w3.org/2000/svg',
                canvasEl = document.createElementNS(svgNS, 'svg');
            me.el.appendChild(canvasEl);
            me.canvas = Snap(canvasEl);
            me.canvas.attr({
                id: me.id + '-root'
            });
            me.textViewPort = me.canvas.g();
            me.mouseDownListener = me.onMouseDown.bind(me);
            me.dragOverListener = me.onDragOver.bind(me);
            me.dropListener = me.onDrop.bind(me);

            me.tool = new Tool({
                renderer: me,
                canvas: me.canvas,
                context: me.context,
                coordinateTransformer: me,
                projectTransformer: me.context.projectTransformer,
                projectEditor: me.context.projectEditor
            });
            me.tool.initTextTransformTool(me.el, {
                disableMailMergeEditing: true
            });
            me.canvas.mousedown(me.mouseDownListener);
            me.el.addEventListener('dragover', me.dragOverListener);
            me.el.addEventListener('drop', me.dropListener);
        },

        updateViewPort: function updateViewPort() {
            var me = this,
                id = me.fieldMarkupId(me.textBlock),
                textField = Snap('#' + id),
                b = me.el.getBoundingClientRect(),
                box = textField.getBBox(),
                z = Math.min((b.width * 0.75) / box.width, (b.height * 0.75) / box.height),
                zoom = Math.min(z, 1),
                s = z / zoom;
            box.width *= s;
            box.height *= s;
            me.zoom = zoom;
            me.fire('changed:zoom', [me, me.zoom]);

            me.fieldBox = {
                x: 0,
                y: 0,
                width: box.width,
                height: box.height
            };

            var viewBox = [0, 0, box.width, box.height];
            me.canvas.attr({
                viewBox: viewBox,
                width: b.width,
                height: b.height,
                preserveAspectRatio: 'xMinYMin meet'
            });
        },

        createTextBlock: function createTextBlock(field) {
            var me = this,
                ctx = me.context,
                pt = ctx.projectTransformer,
                panel = ctx.project.masterPanels[0],
                textBlock = pt.instantiate('TextBlock');
            pt.beginUpdates();
            pt.setProperties(textBlock, {
                position: new DPO.model.Position(0, 0),
                rotation: 0,
                textStyle: field.textStyle,
                text: field.text,
                width: field.width,
                height: panel.height
            });
            textBlock.text.textFlow.verticalAlign = 'top';

            if (textBlock.containsDefaultText()) {
                var paragraphs = textBlock.text.textFlow.paragraphs;
                paragraphs.splice(1, Infinity);
                paragraphs[0].spans.splice(1, Infinity);
                paragraphs[0].spans[0].value = '';
            }
            pt.addFieldToPanel(textBlock, panel);
            pt.endUpdates();

            me.originalField = field;
            me.textBlock = textBlock;
        },

        editTextBlock: function editTextBlock(textBlock) {
            var me = this;
            me.textViewPort.clear();
            me.createTextBlock(textBlock);

            me.tool.recordIndex = me.recordIndex;
            me.tool.editTextBlock(null);
            me.tool.editTextBlock(me.textBlock);
            me.updateViewPort();

            var textEditor = me.tool.textEditCfg.textEditor;
            textEditor.on('text:changed', me.recalculateTextBounds, me);
            me.recalculateTextBounds();
        },

        appendMergeField: function appendMergeField(fieldName) {
            var me = this,
                cfg = me.tool.textEditCfg,
                textEditor = me.tool.textEditCfg.textEditor,
                paragraphs = textEditor.textBlock.text.textFlow.paragraphs,
                protoParagraph = paragraphs[paragraphs.length - 1],
                protoSpan = protoParagraph.spans[protoParagraph.spans.length - 1],
                paragraph = me.clone(protoParagraph),
                span = me.clone(protoSpan);
            delete span.serialNumberField;
            delete span.mailMergeId;
            span.mailMergeField = fieldName;
            me.context.binder.bindDataToSpans(span, me.recordIndex);

            var start = cfg.textArea.selectionStart,
                positions = textEditor.getBindingPositions();

            for (var i = 0; i < positions.length; i++) {
                var pos = positions[i];
                if (pos.start < start && start < pos.end) {
                    start = pos.end;
                }
            }

            var p = textEditor.getParagraphs(start, start)[0],
                text = p.getPlainText(),
                space = me.clone(protoSpan);
            space.value = ' ';
            delete space.serialNumberField;
            delete space.mailMergeId;
            delete space.mailMergeField;

            if (text === '') {
                textEditor.spliceText(start, 0, [span, space]);

                span = me.clone(protoSpan);
                span.value = '';
                delete span.serialNumberField;
                delete span.mailMergeId;
                delete span.mailMergeField;
                paragraph.spans = [span];
                textEditor.appendParagraph([paragraph]);
                start = textEditor.getPlainText().length;
            } else {
                textEditor.insertSpans(start, [span, space]);
                start += span.value.length + 1;
            }

            cfg.textArea.setSelectionRange(start, start);
            cfg.textArea.focus();
        },

        getParagraphs: function getParagraphs() {
            var me = this,
                textEditor = me.tool.textEditCfg.textEditor,
                paragraphs = textEditor.textBlock.text.textFlow.paragraphs;
            if (me.originalField instanceof DPO.model.TextPath) {
                var p = me.clone(paragraphs[0]),
                    spans = p.spans;
                for (var i = 1; i < paragraphs.length; i++) {
                    spans = spans.concat(paragraphs[i].spans);
                }
                p.spans = spans;
                return [p];
            }
            return me.clone(paragraphs);
        },

        recalculateTextBounds: function recalculateTextBounds() {
            this.updateViewPort();
        },

        onFieldsChanged: function onFieldsChanged(fields) {
            var me = this,
                content = me.textViewPort;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i],
                    markup = me.fieldMarkup(f, null, me.recordIndex, false, true),
                    el = content.select('#' + me.fieldMarkupId(f));
                content[el ? 'dpoUpdate' : 'dpoRender'](markup);
            }
        },

        onMouseDown: function onMouseDown(event) {
            var me = this,
                offset = me.getMouseOffset(event);
            me.tool.startTextSelection(offset);
            me.tool.textEditCfg.textArea.focus();
            event.preventDefault();
            event.stopPropagation();
        },

        onDrop: function onDrop(event) {
            var me = this,
                mailMergeField = event.dataTransfer.getData('text'),
                offset = me.getMouseOffset(event),
                cfg = me.tool.textEditCfg,
                textEditor = cfg.textEditor,
                position = me.tool.getTextSelectionPosition(textEditor.textBlock, offset.x, offset.y),
                index = textEditor.combinePosition(position.paragraphIndex, position.charIndex),
                protoSpan = textEditor.getSpans(index, index)[0],
                fieldSpan = textEditor.cloneSpan(protoSpan, '«' + mailMergeField + '»'),
                suffix = textEditor.cloneSpan(protoSpan, ' '),
                spans = [fieldSpan, suffix],
                textGeometry = me.context.layoutManager.calculateTextBlockGeometry(textEditor.textBlock, null, true),
                matrix = me.clientToCanvasMatrix(),
                y = matrix.y(offset.x, offset.y),
                bottom = textGeometry.position.x / 20 + textGeometry.height / 20;

            fieldSpan.mailMergeField = mailMergeField;
            me.context.binder.bindDataToSpans(spans, me.recordIndex);

            if (y > bottom && textEditor.getPlainText().length > 0) {
                var paragraph = textEditor.getParagraphs(index, index)[0];
                paragraph = textEditor.clone(paragraph);
                paragraph.spans = spans;
                textEditor.appendParagraph([paragraph]);

                index = textEditor.getPlainText().length;
            }
            else {
                index = textEditor.insertSpans(index, spans);
            }

            me.tool.setTextSelectionRange(index, index);
            cfg.textArea.focus();
        },

        onDragOver: function onDragOver(event) {
            var me = this,
                textEditor = me.tool.textEditCfg.textEditor,
                offset = me.getMouseOffset(event),
                pos = me.tool.getTextSelectionPosition(textEditor.textBlock, offset.x, offset.y);
            me.tool.moveCaret(pos);
            event.preventDefault();
            event.stopPropagation();
        },

        createEmptyProject: function createEmptyProject() {
            var introspector = new DPO.model.Introspector(),
                project = introspector.instantiate('Project'),
                page = introspector.instantiate('Page'),
                mp = introspector.instantiate('MasterPanel'),
                panel = introspector.instantiate('Panel');
            mp.id = 'MP0';
            mp.width = 12240;
            mp.height = 15840;

            panel.master = mp.id;
            panel.position = new DPO.model.Position(0, 0);

            page.width = 12240;
            page.height = 15840;
            page.paperSize = 'Letter';
            page.viewOrientation = 'portrait';
            page.panels.push(panel);

            project.masterPanels.push(mp);
            project.pages.push(page);

            return project;
        },

        destroy: function destroy() {
            var me = this;
            if (me.tool) {
                me.tool.destroyTextTransformTool();
                me.tool = null;
            }

            me.context.projectTransformer.resetObservable();
            me.el.removeEventListener('dragover', me.dragOverListener);
            me.el.removeEventListener('drop', me.dropListener);
            me.canvas.mousedown(me.mouseDownListener);
        }
    });

    return TextMergeEditor;
});
DPO.def('render.Preview', function (ns) {
    /**
     * Creates a new Preview object.
     * @class DPO.render.Preview
     * @extends DPO.render.Renderer
     * @extends DPO.mixins.Observable
     * @memberof DPO.render
     * @property {string} id
     * @property {object} sheet
     * @property {DPO.model.Panel} selectedPanel
     * @property {boolean} animating
     * @property {number} sheetsPerScreen
     * @param {Element} el
     * @param {DPO.render.Context} context
     * @param {object} [cfg]
     * @fires animation:finished
     * @fires changed:zoom
     * @fires changed:panel:selected
     * @constructor
     */
    function Preview(el, context, cfg) {
        cfg = cfg || {};

        var me = this;
        me.roots = [];
        me._sheet = null;
        me._mode = 'front';
        me._page = null;
        me._provider = null;
        me._zoom = cfg.enableZoom ? 1 : null;
        me._sheetsPerScreen = 1;
        me.filter = cfg.filter || context && context.filter || DPO.project.Filter.MatchAll;
        me.panelOffsetX = cfg.panelOffsetX || 0;
        me.panelOffsetY = cfg.panelOffsetY || 0;
        me.pageFillMode = cfg.pageFillMode || 'None';
        me.animating = false;
        me.visiblePages = [];
        me.el = el;
        me.targets = cfg.targets || [];

        DPO.mixin(me, cfg);
        DPO.render.Renderer.apply(me, [context]);

        me.itemsNumbers = [];
        me.isItemNumberVisible = false;
        me.panelDescriptions = [];
        me.isPanelDescriptionVisible = false;
        me.resetObservable();
        if (me.targets.length) {
            me.sheetsPerScreen = me.targets.length;
            me.initCanvases();
            me.setZoomLevel = DPO.emptyFn;
        } else {
            me.render();
        }
        me.styles = JSON.parse(JSON.stringify(me.$super.styles));
        me.changedStyles = cfg.changedStyles || {};

        me.editOneMode(false);
    }

    DPO.inherit(Preview, ns.Renderer);

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Properties
    // -----------------------------------------------------------------------------------------------------------------
    Object.defineProperty(Preview.prototype, 'context', {
        get: function get() {
            return this._context;
        },

        set: function set(value) {
            var me = this, pt, cs;
            if (me._context === value) {
                return;
            }

            if (me._context) {
                me._context.un('changed:color-space', me.onColorSpaceChanged, me);
                me._context.provider.un(/changed:data-source.*/, me.onDataChanged, me);
                me._context.layoutManager.un('fonts:loaded', me.onFontsLoaded, me);
                me._context.storage.un('image:generated', me.onImageGenerated, me);

                pt = me.context.projectTransformer;
                if (pt) {
                    pt.un('changed:field-order', me.onFieldOrderChanged, me);
                    pt.un('restored:snapshot', me.onSnapshotRestored, me);
                    pt.un('broke:reference', me.onBrokeReference, me);
                    pt.un(/changed:field:.*/, me.onFieldsChanged, me);
                    pt.un('added:field', me.onFieldAdded, me);
                    pt.un('deleted:field', me.onFieldsDeleted, me);
                    pt.un(/sheet/, me.updateVisiblePages, me);
                }

                cs = me._context.colorSpace;
                if (cs) {
                    cs.un('gamut:loaded', me.updateVisiblePages, me);
                }
            }

            me._context = value;

            if (value) {
                value.on('changed:color-space', me.onColorSpaceChanged, me);
                value.provider.on(/changed:data-source.*/, me.onDataChanged, me);
                value.layoutManager.on('fonts:loaded', me.onFontsLoaded, me);
                value.storage.on('image:generated', me.onImageGenerated, me);

                pt = value.projectTransformer;
                if (pt) {
                    pt.on('changed:field-order', me.onFieldOrderChanged, me);
                    pt.on('restored:snapshot', me.onSnapshotRestored, me);
                    pt.on('broke:reference', me.onBrokeReference, me);
                    pt.on(/changed:field:.*/, me.onFieldsChanged, me);
                    pt.on('added:field', me.onFieldAdded, me);
                    pt.on('deleted:field', me.onFieldsDeleted, me);
                    pt.on(/sheet/, me.updateVisiblePages, me);
                }

                cs = me._context.colorSpace;
                if (cs) {
                    cs.on('gamut:loaded', me.updateVisiblePages, me);
                }

                if (value.project) {
                    this.sheet = value.selector.selectSheets()[0];
                }
            }
        }
    });

    Object.defineProperty(Preview.prototype, 'mode', {
        get: function get() {
            return this._mode;
        },

        set: function set(value) {
            if (this._mode !== value) {
                this._mode = value;
                this.updateVisiblePages();
            }
        }
    });

    Object.defineProperty(Preview.prototype, 'sheetsPerScreen', {
        get: function get() {
            return this._sheetsPerScreen;
        },

        set: function set(value) {
            if (this._sheetsPerScreen === value) {
                return;
            }

            this._sheetsPerScreen = value;
            this.updateVisiblePages();
        }
    });

    Object.defineProperty(Preview.prototype, 'sheet', {
        get: function get() {
            return this._sheet;
        },

        set: function set(value) {
            var me = this;
            me._sheet = value;

            var page = me._sheet[me._mode],
                index = this.visiblePages.indexOf(page);
            me.selectedPanel = page.panels[0];
            if (index === -1) {
                me.updateVisiblePages();
            }
        }
    });

    Object.defineProperty(Preview.prototype, 'zoom', {
        get: function get() {
            return this._zoom;
        },

        set: function set(value) {
            this.setZoomLevel(value);
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Methods
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(Preview.prototype, DPO.mixins.Observable);
    DPO.mixin(Preview.prototype, {
        editOne: null,
        viewPortPadding: 5,
        pagesMarginTop: 10,
        pagesMarginBottom: 10,
        pagesHorizontalMargin: 20,

        minZoom: 0.25,
        maxZoom: 4,
        enableZoom: false,
        enablePanelSelection: true,
        descriptionFontSize: 5,
        displayEditable: true,
        displayPreviewable: true,
        displayPageBorder: true,

        selectedPanelEditAllStyle: {
            'fill': '#ffde96',
            'fill-opacity': '0.5',
            'vector-effect' : 'non-scaling-stroke'
        },

        selectedPanelEditOneStyleStyle: {
            'fill': 'none',
            'stroke': '#F47900',
            'vector-effect' : 'non-scaling-stroke',
            'stroke-width': 5
        },

        defaultPanelEditAllStyle: {
            'fill': 'none',
            'stroke': '#B8C2C9',
            'vector-effect' : 'non-scaling-stroke',
            'stroke-width': 1
        },

        defaultPanelEditOneStyle: {
            'fill': '#bbb',
            'fill-opacity': '0.25',
            'stroke': '#B8C2C9',
            'vector-effect' : 'non-scaling-stroke',
            'stroke-width': 1
        },

        onColorSpaceChanged: function onColorSpaceChanged(sender, colorSpace) {
            var me = this;
            if (!colorSpace || colorSpace.ready) {
                this.updateVisiblePages();
            } else {
                colorSpace.on('gamut:loaded', me.updateVisiblePages, me);
            }
        },

        updateVisiblePages: function updateVisiblePages() {
            var me = this;

            if (!me.context || !me.context.project) {
                return;
            }
            var pages = me.context.project.pages,
                doubleSided = me._sheet.front.doubleSided,
                page = me._sheet[me._mode],
                index = pages.indexOf(page);
            me.visiblePages = [page];

            var d = doubleSided ? 2 : 1,
                np = pages[index + d],
                pp = pages[index - d];
            while ((np || pp) && me.visiblePages.length < me.sheetsPerScreen) {
                if (np) {
                    me.visiblePages.push(np);
                }

                if (me.visiblePages.length >= me.sheetsPerScreen) {
                    break;
                }

                if (pp) {
                    me.visiblePages.unshift(pp);
                }

                d += doubleSided ? 2 : 1;
                np = pages[index + d];
                pp = pages[index - d];
            }

            me.calculateDescriptionFontSize();
            if (me.roots.length) {
                me.update();
                me.fire('sheets:rendered', [me]);
            }
        },

        /**
         * Set new page with flip animation
         * @memberof DPO.render.Preview#
         * @param {DPO.model.Page} page
         * @param {DPO.model.Panel} panel
         */
        flip: function flip(page, panel) {
            var me = this,
                sheet = me.context.selector.getSheet(page);
            me._sheet = sheet;
            me._mode = sheet.front === page ? 'front' : 'back';
            me.selectedPanel = panel;
            me.animating = true;

            function flipElement(element) {
                var box = element.getBBox();

                function f1() {
                    me.updateVisiblePages();
                    me.updateSelectedPanel();
                    Snap.animate(0.999, 0, function (value) {
                        var m = Snap.matrix().scale(1 - value, 1, box.cx, box.cy);
                        element.attr({transform: m});
                    }, 250, mina.easeinout, function () {
                        element.attr({transform: Snap.matrix()});
                        me.animating = false;
                        me.fire('animation:finished');
                    });
                }

                Snap.animate(0, 0.999, function (value) {
                    var m = Snap.matrix().scale(1 - value, 1, box.cx, box.cy);
                    element.attr({transform: m});
                }, 250, mina.easeinout, f1);
            }

            for (var i = 0; i < me.canvases.length; i++) {
                flipElement(me.canvases[i]);
            }
        },

        /**
         * Gets or set item number visibility
         * @memberof DPO.render.Preview#
         * @param {boolean} [visible]
         * @returns boolean
         */
        itemNumberVisible: function itemNumberVisible(visible) {
            if (visible === undefined) {
                return this.isItemNumberVisible;
            }

            var attr = {
                display: visible ? 'inline' : 'none'
            };

            for (var i = 0; i < this.itemsNumbers.length; i++) {
                var el = this.itemsNumbers[i];
                el.attr(attr);
            }

            this.isItemNumberVisible = !!visible;
            return !!visible;
        },

        panelDescriptionVisible: function panelDescriptionVisible(visible) {
            if (visible === undefined) {
                return this.isPanelDescriptionVisible;
            }

            var attr = {
                display: visible ? 'block' : 'none'
            };

            for (var i = 0; i < this.panelDescriptions.length; i++) {
                var el = this.panelDescriptions[i];
                el.attr(attr);
            }

            this.isPanelDescriptionVisible = !!visible;
            return !!visible;
        },

        /**
         * Gets or set edit one mode
         * @memberof DPO.render.Preview#
         * @param {boolean} [editOne]
         * @returns {boolean}
         */
        editOneMode: function editOneMode(editOne) {
            var me = this,
                styleKeys, i, key;
            if (editOne === undefined || me.editOne === editOne) {
                return me.editOne;
            }

            me.editOne = editOne;
            me.defaultPanelStyle = editOne ? me.defaultPanelEditOneStyle : me.defaultPanelEditAllStyle;
            me.defaultSelectedPanelStyle = editOne ? me.selectedPanelEditOneStyleStyle : me.selectedPanelEditAllStyle;
            
            me.styles = JSON.parse(JSON.stringify(me.$super.styles));
            if (editOne) {
                styleKeys = Object.keys(me.changedStyles.editOne || {});
                for (i = 0; i < styleKeys.length; i++) {
                    key = styleKeys[i];
                    DPO.mixin(me.styles[key], me.$super.styles[key], me.changedStyles.editOne[key]);
                }
            } else {
                styleKeys = Object.keys(me.changedStyles.editAll || {});
                for (i = 0; i < styleKeys.length; i++) {
                    key = styleKeys[i];
                    DPO.mixin(me.styles[key], me.$super.styles[key], me.changedStyles.editAll[key]);
                }
            }

            me.update();
            return me.editOne;
        },

        /**
         * Generates field reuse identifier
         * @memberof DPO.render.Preview#
         * @param {object} item
         * @returns {string}
         */
        fieldReuseId: function fieldReuseId(item) {
            return this.id + '-ref-' + item.ref.id;
        },

        getViewPort: function getViewPort() {
            var me = this,
                visiblePages = me.visiblePages,
                p, ph, pw;
            p = visiblePages[0];
            if (p.getOrientation() === 0) {
                pw = p.width / 20;
                ph = p.height / 20;
            } else {
                ph = p.width / 20;
                pw = p.height / 20;
            }

            var w = pw,
                h = ph;

            return {
                width: w,
                height: h,
                viewBox: [-1, -1, w + 2, h + 2].join(',')
            };
        },

        calculatePreferredZoom: function calculatePreferredZoom(hp, vp) {
            hp = hp || 0;
            vp = vp || 0;
            var me = this,
                viewPort = me.getViewPort(),
                box = me.viewEl.getBoundingClientRect(),
                zw = (box.width - hp) / viewPort.width * 0.75,
                zh = (box.height - vp) / viewPort.height * 0.75,
                z = Math.min(zw, zh) - 0.05;
            z = Math.floor(z / 0.05) * 0.05;
            z = Math.min(z, me.maxZoom);
            z = Math.max(z, me.minZoom);
            return z;
        },

        setZoomLevel: function setZoomLevel(zoom, scroll) {
            var me = this;
            zoom = Math.min(zoom, me.maxZoom);
            zoom = Math.max(zoom, me.minZoom);

            if (zoom === me._zoom) {
                return;
            }

            me._zoom = zoom;

            var viewPort = me.getViewPort(),
                box = me.viewEl.getBoundingClientRect(),
                w = viewPort.width * zoom,
                h = viewPort.height * zoom;

            DPO.render.applyStyles(me.roots[0].node, {
                margin: [Math.max((box.height * 0.75 - h) / 2, 0) + 'pt', 0, 0, 0].join(' ')
            });

            me.roots[0].attr({
                width: w + 'pt',
                height: h + 'pt'
            });

            var el = me.viewEl;
            if (scroll) {
                el.scrollLeft = scroll.x;
                el.scrollTop = scroll.y;
            } else {
                var sw = el.scrollWidth,
                    sh = el.scrollHeight;
                el.scrollLeft = Math.max(0, (sw - box.width) / 2);
                el.scrollTop = Math.max(0, (sh - box.height) / 2);
            }

            me.fire('changed:zoom', [me, zoom]);
        },

        initCanvases: function initCanvases() {
            var me = this;
            me.roots = [];
            me.canvases = [];
            for (var i = 0; i < me.targets.length; i++) {
                var root = Snap(me.targets[i]);
                root.clear();
                root.attr({
                    'pointer-events': 'none',
                    'preserveAspectRatio': 'xMidYMid meet'
                });

                me.roots.push(root);
                me.canvases.push(root.g());
            }
        },

        /**
         * Render page with index inside el container
         * @memberof DPO.render.Preview#
         */
        render: function render() {
            var me = this,
                svgNS = 'http://www.w3.org/2000/svg',
                rootEl = document.createElementNS(svgNS, 'svg'),
                root = Snap(rootEl),
                viewEl;

            if (me.enableZoom) {
                rootEl.id = me.id + '-root';
                viewEl = document.createElement('div');
                viewEl.id = me.id;
                viewEl.appendChild(rootEl);
                DPO.render.applyStyles(viewEl, {
                    'text-align': 'center',
                    'overflow': 'auto',
                    'background': 'white'
                });
                me.viewEl = viewEl;
                me.viewEl.addEventListener('mousewheel', me.onMouseWheel.bind(me));
            } else {
                rootEl.id = me.id;
                me.setZoomLevel = DPO.emptyFn;
            }

            me.roots = [root];
            me.canvases = [root.g()];
            root.attr({
                'pointer-events': 'none',
                'preserveAspectRatio': 'xMidYMid meet'
            });

            if (me.el) {
                DPO.render.clearContainer(me.el);
                me.el.appendChild(viewEl || rootEl);
            }
        },

        //
        // Nov 5, 2014
        // Smart zoom doesn't work on FireFox.
        // 1. FireFox doesn't support mousewheel event
        // 2. Wheel+Alt, Wheel+Ctrl and Wheel+MetaKey combinations registered for total page zoom
        // 3. Event DOMMouseScroll + stopPropagation & preventDefault doesn't help
        onMouseWheel: function onMouseWheel(event) {
            if (event.ctrlKey || event.altKey) {
                event.stopPropagation();
                event.preventDefault();

                var me = this,
                    delta = event.wheelDelta / 120 * 0.05,
                    zoom = me.zoom + delta;
                zoom = Math.min(zoom, me.maxZoom);
                zoom = Math.max(zoom, me.minZoom);

                var el = me.viewEl,
                    box = el.getBoundingClientRect(),
                    canvasOffsetX = event.offsetX,
                    canvasOffsetY = event.offsetY,
                    canvasWidth = box.width,
                    canvasHeight = box.height,
                    u = canvasOffsetX / canvasWidth,
                    v = canvasOffsetY / canvasHeight;
                canvasWidth = canvasWidth / me._zoom * zoom;
                canvasHeight = canvasHeight / me._zoom * zoom;

                var dx = u * canvasWidth - canvasOffsetX,
                    dy = v * canvasHeight - canvasOffsetY;
                me.setZoomLevel(zoom, {
                    x: el.scrollLeft + dx,
                    y: el.scrollTop + dy
                });
            }
        },

        /**
         * Defines fields element in defs sections
         * @memberof DPO.render.Preview#
         * @param {*} canvas
         * @param {DPO.render.Markup} markup
         * @returns {*}
         */
        defineReusableField: function defineReusableField(canvas, markup) {
            var root = Snap(canvas.node.ownerSVGElement),
                el = root.select('#' + markup.geometry.id);
            if (!el) {
                el = root.dpoRender(markup).toDefs();
            }
            return el;
        },

        /**
         * Defines panels clip path
         * @memberof DPO.render.Preview#
         * @param {*} canvas
         * @param {DPO.model.Panel} panel
         * @returns {string}
         */
        definePanelClipPath: function definePanelClipPath(canvas, panel) {
            var master = this.context.selector.selectMasterPanel(panel),
                id = this.id + '-clip-path-' + master.id,
                root = Snap(canvas.node.ownerSVGElement),
                clipPath = root.select('#' + id);
            if (!clipPath) {
                var markup = this.shapeMarkup(master),
                    defs = root.select('defs'),
                    doc = root.node.ownerDocument;
                clipPath = Snap(doc.createElementNS('http://www.w3.org/2000/svg', 'clipPath'));
                defs.append(clipPath);
                clipPath.attr({id: id});
                clipPath.append(root[markup.type](markup.geometry));
            }
            return id;
        },

        /**
         * Checks if field can be reused
         * @memberof DPO.render.Preview#
         * @param {DPO.model.Field} field
         */
        isReusable: function isReusable(field) {
            return !(field instanceof DPO.model.TextPath);
        },

        renderItem: function renderField(item, canvas) {
            var me = this,
                ctx = me.context,
                index = ctx.selector.panelIndex(item.panel);

            if (!me.filter.matchField(item.field)) {
                return;
            }

            var f = ctx.binder.bindDataToField(/** @type DPO.model.Field*/item.field, index),
                markup = me.fieldMarkup(f, null, index, true);
            if (f === item.field && item.ref && me.isReusable(f)) {
                var use = me.defineReusableField(canvas, markup).use().attr({
                    id: me.fieldReuseId(item)
                });
                canvas.append(use);
                return;
            }

            if (item.ref) {
                markup = me.fieldMarkup(f, me.fieldReuseId(item), index);
            }

            canvas.dpoRender(markup);
        },

        updateItem: function updateItem(item, canvas) {
            var me = this,
                ctx = me.context,
                root = Snap(canvas.node.ownerSVGElement),
                index = ctx.selector.panelIndex(item.panel);
            if (!me.filter.matchField(item.field)) {
                return;
            }

            var f = item.binded,
                markup = me.fieldMarkup(f, null, index, true),
                id;
            if (f === item.field && item.ref && !me.isReusable(f)) {
                markup = me.fieldMarkup(f, me.fieldReuseId(item), index, true);
            } else if (f !== item.field && item.ref) {
                id = me.fieldReuseId(item);
                Snap('#' + id).remove();
                markup = me.fieldMarkup(f, me.fieldReuseId(item), index, true);
            }

            if (!root.dpoUpdate(markup)) {
                canvas.dpoRender(markup);
            }
            
            me.updateVisiblePages();
        },

        applyPageFillMode: function applyPageFillMode(options) {
            function acrossSort(a, b) {
                var c = a.position.x - b.position.x;
                return c === 0 ? (a.position.y - b.position.y) : c;
            }

            function downSort(a, b) {
                var c = a.position.y - b.position.y;
                return c === 0 ? (a.position.x - b.position.x) : c;
            }

            var me = this,
                order = [],
                i;
            for (i = 0; i < options.length; i++) {
                order.push({
                    position: options[i].position
                });
            }
            switch (me.pageFillMode) {
                case 'FillAcross':
                    order.sort(downSort);
                    break;
                case 'FillDown':
                    order.sort(acrossSort);
                    break;
            }

            for (i = 0; i < order.length; i++) {
                var pos = order[i].position;
                options[i].position = new DPO.model.Position(pos.x, pos.y);
            }

            return options;
        },

        renderPage: function renderPage(canvas, page, pageIndex) {
            var me = this,
                pageCanvasMarkup = me.pageCanvasMarkup(page, 0, 0),
                pageCanvas = canvas.dpoRender(pageCanvasMarkup);
            if (me.displayPageBorder) {
                var pageMarkup = me.pageMarkup(page);
                pageCanvas.dpoRender(pageMarkup);
            }

            var panelsOptions = [], panel, master, i, p;
            for (i = 0; i < page.panels.length; i++) {
                panel = page.panels[i];
                p = panel.position;
                master = me.context.selector.selectMasterPanel(panel);
                panelsOptions.push({
                    panel: panel,
                    master: master,
                    position: new DPO.model.Position(p.x + me.panelOffsetX, p.y + me.panelOffsetY)
                });
            }

            panelsOptions = me.applyPageFillMode(panelsOptions);

            for (i = 0; i < panelsOptions.length; i++) {
                var option = panelsOptions[i];
                panel = option.panel;
                master = option.master;

                var orderedFields = me.context.selector.getFieldOrder(panel),
                    clipPath = me.definePanelClipPath(canvas, panel),
                    panelCanvas = pageCanvas.g({
                        id: me.id + '-panel-canvas-' + pageIndex + '-' + i,
                        transform: me.panelCanvasTransform(panel, option.position)
                    });
                panelCanvas.node.setAttribute('clip-path', Snap.url(clipPath));

                if (!master.editable && !me.displayEditable) {
                    continue;
                }

                if (!master.previewable && !me.displayPreviewable) {
                    continue;
                }

                for (var j = 0; j < orderedFields.items.length; j++) {
                    var item = orderedFields.items[j];
                    item.panel = panel;
                    me.renderItem(item, panelCanvas);
                }

                var panelMarkup = me.shapeMarkup(panel),
                    shape = me.toPath(panelMarkup);

                for (var k = 0; k < master.cutouts.length; k++) {
                    var cutout = master.cutouts[k],
                        pos = cutout.position,
                        path = me.toPath(me.shapeMarkup(cutout), pos.x / 20, pos.y / 20);
                    shape.geometry.d += ' ' + path.geometry.d;
                }

                shape.geometry['fill-rule'] = 'evenodd';

                var panelEl = panelCanvas.dpoRender(shape).attr({
                    id: me.id + '-panel-' + pageIndex + '-' + i
                }).attr(me.defaultPanelStyle);

                var itemNumberMarkup = me.itemNumberMarkup(page, panel);
                me.itemsNumbers.push(panelCanvas.dpoRender(itemNumberMarkup));

                if (me.enablePanelSelection) {
                    me.addPanelListener(panelEl, panel);
                    if (panel === me.selectedPanel) {
                        me.selectDefaultPanel(panelEl, panel);
                    }
                }

                var description = panel.description;
                if (description) {
                    var descriptionText = description.value;
                    switch (descriptionText) {
                        case 'Left':
                        case 'Back':
                            me.renderPanelDescription(pageCanvas, page, panel, 'bottom');
                            break;
                        case 'Front':
                        case 'Right':
                            me.renderPanelDescription(pageCanvas, page, panel, 'top');
                            break;
                    }
                }
            }

            me.setZoomLevel(me._zoom);
        },

        calculateDescriptionFontSize: function calculateDescriptionFontSize() {
            var me = this,
                ctx = me.context,
                lm = ctx.layoutManager;
            if (!lm.fallbackFont) {
                me.descriptionFontSize = 5;
                me.pagesMarginTop = 10;
                me.pagesHorizontalMargin = 20;
                me.pagesMarginBottom = 10;
                return;
            }

            function getPanelDescriptionLength(panel) {
                var description = panel.description;
                if (!description || !description.value) {
                    return 0;
                }

                var font = lm.fallbackFont,
                    text = description.value,
                    fontScale = 1 / font.unitsPerEm,
                    glyphs = font.stringToGlyphs(text),
                    width = 0;
                for (var i = 0; i < glyphs.length; i++) {
                    var glyph = glyphs[i];
                    width += glyph.advanceWidth * fontScale;

                    if (i < glyphs.length - 1) {
                        width += font.getKerningValue(glyph, glyphs[i + 1]) * fontScale;
                    }
                }

                return width;
            }

            var fontSize = Infinity,
                pages = [me._sheet.front, me._sheet.back],
                page = pages.shift();
            while (page) {
                for (var j = 0; j < page.panels.length; j++) {
                    var panel = page.panels[j],
                        mp = ctx.selector.selectMasterPanel(panel),
                        descriptionWidth = getPanelDescriptionLength(panel),
                        size = mp.width / 20 / descriptionWidth;
                    fontSize = Math.min(size, fontSize);
                }

                page = pages.shift();
            }

            me.descriptionFontSize = fontSize * 0.9;
        },

        renderPanelDescription: function renderPanelDescription(pageCanvas, page, panel, pos) {
            var me = this,
                text = panel.description.value,
                ctx = me.context,
                selector = ctx.selector,
                lm = ctx.layoutManager,
                fm = lm.fontMetrics,
                metrics = lm.fontMetrics.fallbackFontFamily.Regular,
                mp = selector.selectMasterPanel(panel),
                w = mp.width / 20,
                h = mp.height / 20,
                x = panel.position.x / 20 + w / 2,
                y = panel.position.y / 20,
                textAnchor = 'middle';
            switch (pos) {
                case 'bottom':
                    y += h + fm.getDescender(metrics, me.descriptionFontSize);
                    break;
                case 'top':
                    y += fm.getAscender(metrics, me.descriptionFontSize);
                    break;
            }

            var el = pageCanvas.text(x, y, text).attr({
                'id': me.id + '-description-' + selector.panelIndex(panel),
                'fill': '#465F67',
                'stroke': 'white',
                'stroke-width': me.descriptionFontSize * 0.02,
                'font-family': fm.getCSSFontFamily('Arial'),
                'font-size': me.descriptionFontSize,
                'text-anchor': textAnchor
            });

            me.panelDescriptions.push(el);
        },

        clear: function clear() {
            var me = this;
            for (var i = 0; i < me.canvases.length; i++) {
                me.canvases[i].clear();
                DPO.render.clearContainer(me.roots[i].select('defs').node);
            }
        },

        updateViewPort: function updateViewPort() {
            var me = this,
                viewPort = me.getViewPort();
            for (var i = 0; i < me.roots.length; i++) {
                me.roots[i].attr({viewBox: viewPort.viewBox});
            }
        },

        update: function update() {
            var me = this,
                visiblePages = me.visiblePages;

            me.itemsNumbers = [];
            me.panelDescriptions = [];
            me.clear();

            if (!visiblePages.length) {
                return;
            }

            me.updateViewPort();

            var pages = me.context.project.pages;
            for (var i = 0; i < visiblePages.length; i++) {
                var canvas = me.canvases[i],
                    page = visiblePages[i];
                if (canvas) {
                    me.renderPage(canvas, page, pages.indexOf(page));
                }
            }

            me.itemNumberVisible(me.isItemNumberVisible);
            me.panelDescriptionVisible(me.isPanelDescriptionVisible);
        },

        updateSelectedPanel: function updateSelectedPanel() {
            var me = this,
                panel = me.selectedPanel,
                pageIndex = null,
                panelIndex = null,
                pages = me.context.project.pages,
                page, panels;
            for (var i = 0; pageIndex === null && i < pages.length; i++) {
                page = pages[i];
                panels = page.panels;

                for (var j = 0; panelIndex === null && j < panels.length; j++) {
                    if (panels[j] === panel) {
                        pageIndex = i;
                        panelIndex = j;
                    }
                }
            }

            var panelId = me.id + '-panel-' + pageIndex + '-' + panelIndex,
                el = Snap('#' + panelId);
            el.attr(me.defaultSelectedPanelStyle);
            me.selectedPanelEl = el;
        },

        /**
         * Set selected panel
         * @memberof DPO.render.Preview#
         * @param {DPO.model.Panel} panel
         * @param {Boolean} [fireEvent]
         */
        selectPanel: function selectPanel(panel, fireEvent) {
            if (this.selectedPanel === panel) {
                return;
            }

            var me = this,
                pageIndex = null,
                panelIndex = null,
                pages = me.context.project.pages,
                page, panels;
            for (var i = 0; pageIndex === null && i < pages.length; i++) {
                page = pages[i];
                panels = page.panels;

                for (var j = 0; panelIndex === null && j < panels.length; j++) {
                    if (panels[j] === panel) {
                        pageIndex = i;
                        panelIndex = j;
                    }
                }
            }

            if (pageIndex === null || panelIndex === null) {
                return;
            }

            var sheet = me.context.selector.getSheet(page);
            me._mode = sheet.front === page ? 'front' : 'back';
            me.sheet = sheet;
            me.selectedPanelEl.attr(me.defaultPanelStyle);
            me.selectedPanel = panel;
            me.updateSelectedPanel();

            if (fireEvent) {
                me.fire('changed:panel:selected', [me, panel, pages[pageIndex]]);
            }
        },

        /**
         * Initialize 'click' event listener for each panel
         * @memberof DPO.render.Preview#
         * @param el
         * @param {DPO.model.Panel} panel
         */
        addPanelListener: function addPanelListener(el, panel) {
            var me = this;
            el.click(function onPanelClick() {
                me.onPanelSelected(el, panel);
            });
        },

        /**
         * Panel event listener handler
         * @memberof DPO.render.Preview#
         * @param el
         * @param {DPO.model.Panel} panel
         */
        onPanelSelected: function onPanelSelected(el, panel) {
            this.selectPanel(panel, true);
        },

        onSnapshotRestored: function onSnapshotRestored() {
            var me = this;
            me._sheet = me.context.selector.selectSheets()[0];
            me.updateVisiblePages();
        },

        onBrokeReference: function onBrokeReference() {
            var me = this;
            me.update();
        },

        forEachOrderItem: function forEachOrderItem(fields, fn, scope) {
            var me = this,
                ctx = me.context,
                selector = ctx.selector,
                pages = me.visiblePages,
                items = [],
                filtered = [],
                mp, add, index, i, j, k, item, canvas;
            for (k = 0; k < pages.length; k++) {
                var page = pages[k];
                for (i = 0; i < page.panels.length; i++) {
                    var panel = page.panels[i],
                        orderedFields = selector.getFieldOrder(panel),
                        pageIndex = ctx.project.pages.indexOf(page);
                    canvas = Snap('#' + me.id + '-panel-canvas-' + pageIndex + '-' + i);
                    for (j = 0; j < orderedFields.items.length; j++) {
                        item = orderedFields.items[j];
                        if (fields.indexOf(item.field) !== -1) {
                            index = selector.panelIndex(panel);
                            item.panel = panel;
                            item.canvas = canvas;
                            item.binded = ctx.binder.bindDataToField(/** @type DPO.model.Field*/item.field, index);
                            items.push(item);
                        }
                    }
                }
            }

            for (i = 0; i < items.length; i++) {
                item = items[i];
                mp = selector.selectMasterPanel(/** @type DPO.model.Panel*/item.panel);
                add = mp.editable || me.displayEditable;
                add = add && (mp.previewable || me.displayPreviewable);

                for (j = 0; add && j < filtered.length; j++) {
                    add = add && item.binded !== filtered[j].binded || item.binded instanceof DPO.model.TextPath;
                }

                if (add) {
                    filtered.push(item);
                }
            }

            for (i = 0; i < filtered.length; i++) {
                item = filtered[i];
                fn.call(scope, item, item.canvas);
            }
        },

        updateFields: function updateFields(fields) {
            var me = this;
            fields = (fields instanceof Array) ? fields : [fields];
            me.forEachOrderItem(fields, me.updateItem, me);
        },

        onFieldsChanged: function onFieldsChanged(fields) {
            this.updateFields(fields);
        },

        getPageFieldsInfo: function getPageFieldsInfo(panels) {
            var me = this,
                result = [],
                visiblePanels = [],
                i, j, k, page, pageIndex;
            for (k = 0; k < me.visiblePages.length; k++) {
                page = me.visiblePages[k];
                visiblePanels = visiblePanels.concat(page.panels);
            }

            for (k = 0; k < me.visiblePages.length; k++) {
                page = me.visiblePages[k];
                pageIndex = me.context.project.pages.indexOf(page);

                for (i = 0; i < panels.length; i++) {
                    var panel = panels[i],
                        panelIndex = page.panels.indexOf(panel);
                    if (panelIndex === -1) {
                        continue;
                    }

                    var items = this.context.selector.getFieldOrder(panel).items;
                    for (j = 0; j < items.length; j++) {
                        var item = items[j];
                        item.page = page;
                        item.pageIndex = pageIndex;
                        item.panel = panel;
                        item.panelIndex = panelIndex;
                        result.push(item);
                    }
                }
            }

            return result;
        },

        filterFieldsInfo: function filterFieldsInfo(refsInfo, field) {
            var items = [];
            for (var i = 0; i < refsInfo.length; i++) {
                var info = refsInfo[i];
                if (info.field === field) {
                    items.push(info);
                }
            }

            return items;
        },

        onFieldOrderChanged: function onFieldOrderChanged() {
            var me = this;
            for (var i = 0; i < me.visiblePages.length; i++) {
                var page = me.visiblePages[i];
                for (var j = 0; j < page.panels.length; j++) {
                    this.reorderFields(page, page.panels[j]);
                }
            }
        },

        getPanelCanvas: function getPanelCanvas(pageIndex, panelIndex) {
            var me = this,
                query = '#' + me.id + '-panel-canvas-' + pageIndex + '-' + panelIndex,
                canvas = null;
            for (var i = 0; !canvas && i < me.roots.length; i++) {
                canvas = me.roots[i].select(query);
            }

            return canvas;
        },

        onFieldAdded: function onFieldAdded(field, panels) {
            var me = this,
                items = me.getPageFieldsInfo(panels),
                i, info, canvas;

            items = me.filterFieldsInfo(items, field);
            for (i = 0; i < items.length; i++) {
                info = items[i];
                canvas = me.getPanelCanvas(info.pageIndex, info.panelIndex);
                if (canvas) {
                    me.renderItem(info, canvas);
                }
            }

            for (i = 0; i < items.length; i++) {
                info = items[i];
                me.reorderFields(info.page, info.panel);
            }
        },

        reorderFields: function reorderFields(page, panel) {
            var me = this,
                pageIndex = me.context.project.pages.indexOf(page),
                panelIndex = page.panels.indexOf(panel),
                canvas = me.getPanelCanvas(pageIndex, panelIndex),
                orderedFields = me.context.selector.getFieldOrder(panel);
            for (var j = 0; canvas && j < orderedFields.items.length; j++) {
                var item = orderedFields.items[j],
                    f = item.field,
                    id = me.fieldMarkupId(f);
                if (item.ref) {
                    id = me.fieldReuseId(item);
                }

                var el = canvas.select('#' + id);
                canvas.append(el);
            }
        },

        onFieldsDeleted: function onFieldsDeleted(fields, refs) {
            var me = this,
                i, query, el, uses;
            for (var k = 0; k < me.roots.length; k++) {
                var root = me.roots[k];
                for (i = 0; i < fields.length; i++) {
                    query = '#' + me.fieldMarkupId(fields[i]);
                    el = root.select(query);
                    uses = root.selectAll('use');

                    for (var j = 0; j < uses.length; j++) {
                        if (uses[j].attr('href') === query) {
                            uses[j].remove();
                        }
                    }

                    if (el) {
                        el.remove();
                    }
                }

                for (i = 0; i < refs.length; i++) {
                    query = '#' + me.id + '-ref-' + refs[i].id;
                    el = root.select(query);
                    if (el) {
                        el.remove();
                    }
                }
            }
        },

        onDataChanged: function onDataChanged() {
            this.update();
        },

        /**
         * Select first panel of page by default
         * @memberof DPO.render.Preview#
         * @param {Element} el
         * @param {DPO.model.Panel} panel
         */
        selectDefaultPanel: function selectDefaultPanel(el, panel) {
            var me = this;
            el.attr(me.defaultSelectedPanelStyle);
            me.selectedPanel = panel;
            me.selectedPanelEl = el;
        },

        onFontsLoaded: function onFontsLoaded() {
            this.updateVisiblePages();
        },

        onImageGenerated: function onImageGenerated(sender, name) {
            var me = this,
                selector = me.context.selector,
                fields = selector.selectFields(function (f) {
                    return f.source === name;
                });
            me.updateFields(fields);
        },

        hidePanels: function visiblePanels(hiddenPanel) {
            var me = this,
                pages = me.context.project.pages,
                vps = me.visiblePages;
            for (var i = 0; i < vps.length; i++) {
                var page = vps[i],
                    pageIndex = pages.indexOf(page);
                for (var j = 0; j < page.panels.length; j++) {
                    var panelId = me.id + '-panel-canvas-' + pageIndex + '-' + j,
                        el = Snap('#' + panelId),
                        hidden = !!hiddenPanel[j];
                    el.attr({
                        display: hidden ? 'none' : 'inline'
                    });
                }
            }
        },

        /**
         * Destroys component
         * @memberof DPO.render.Preview#
         */
        destroy: function destroy() {
            var me = this;
            me.resetObservable();
            if (me.el) {
                me.el.innerHTML = '';
            }
            me.context = null;
        }
    });

    return Preview;
});

DPO.def('render.PreviewPanelSelector', function (ns) {
    /**
     * Creates new PreviewPanelSelector
     * @class DPO.render.PreviewPanelSelector
     * @extends DPO.render.Renderer
     * @extends DPO.mixins.Observable
     */
    function PreviewPanelSelector(el, context, cfg) {
        cfg = cfg || {};

        var me = this;
        me.el = el;
        me._sheet = null;
        me.visiblePages = [];
        me._mode = 'front';
        me._page = null;
        me.selectedPanels = [];
        me._provider = null;
        me.panelDisalbeMap = {};
        me.selectable = false;
        me.hiddenPanels = [];
        me.pageFillMode = cfg.pageFillMode || 'None';

        DPO.mixin(me, cfg);
        DPO.render.Renderer.apply(me, [context]);

        me.resetObservable();
        me.render();
        me.update();
    }

    DPO.inherit(PreviewPanelSelector, ns.Renderer);

    Object.defineProperty(PreviewPanelSelector.prototype, 'sheet', {
        get: function get() {
            return this._sheet;
        },

        set: function set(value) {
            var me = this;
            me._sheet = value;
            var page = me._sheet[me._mode],
                index = this.visiblePages.indexOf(page);
            me.selectedPanel = page.panels[0];
            if (index === -1) {
                me.updateVisiblePages();
            }
        }
    });

    Object.defineProperty(PreviewPanelSelector.prototype, 'mode', {
        get: function get() {
            return this._mode;
        },

        set: function set(value) {
            if (this._mode !== value) {
                this._mode = value;
                this.updateVisiblePages();
            }
        }
    });

    Object.defineProperty(PreviewPanelSelector.prototype, 'context', {
        get: function get() {
            return this._context;
        },

        set: function set(value) {
            var me = this, pt;
            if (me._context === value) {
                return;
            }

            if (me._context) {
                me._context.provider.un(/changed:data-source.*/, me.update, me);

                pt = me.context.projectTransformer;
                if (pt) {
                    pt.un(/sheet/, me.updateVisiblePages, me);
                }
            }

            me._context = value;

            if (value) {
                value.provider.on(/changed:data-source.*/, me.update, me);

                pt = value.projectTransformer;
                if (pt) {
                    pt.on(/sheet/, me.updateVisiblePages, me);
                }

                if (value.project) {
                    this.sheet = value.selector.selectSheets()[0];
                    me.updateVisiblePages();
                }
            }
        }
    });

    DPO.mixin(PreviewPanelSelector.prototype, DPO.mixins.Observable);
    DPO.mixin(PreviewPanelSelector.prototype, {
        viewPortPadding: 5,
        pagesMarginTop: 10,
        pagesMarginBottom: 10,
        pagesHorizontalMargin: 20,

        enablePanelSelection: true,
        descriptionFontSize: 5,
        selectedPanelStyle: {
            'fill': '#ffd700',
            'fill-opacity': '0.1',
            'stroke': '#F47900',
            'stroke-width': 2
        },
        defaultPanelStyle: {
            'fill': 'none',
            'stroke': '#B8C2C9',
            'stroke-width': 1
        },

        /**
         * Render page with index inside el container
         * @memberof DPO.render.PreviewPanelSelector#
         */
        render: function render() {
            var me = this,
                svgNS = 'http://www.w3.org/2000/svg',
                rootEl = document.createElementNS(svgNS, 'svg');

            me.rootEl = rootEl;
            me.root = Snap(me.rootEl);
            me.canvas = me.root.g();

            rootEl.id = me.id;

            me.root.attr({
                'pointer-events': 'none',
                'preserveAspectRatio': 'xMidYMid meet'
            });

            if (me.el) {
                DPO.render.clearContainer(me.el);
                me.el.appendChild(rootEl);
            }
        },

        update: function update() {
            var me = this,
                visiblePages = me.visiblePages;

            me.itemsNumbers = [];
            me.panelDescriptions = [];
            me.canvas.clear();
            DPO.render.clearContainer(me.root.select('defs').node);

            if (!visiblePages.length) {
                return;
            }

            var viewPort = me.getViewPort(),
                pages = me.context.project.pages,
                i, p;

            me.root.attr({viewBox: viewPort.viewBox});

            var grid = viewPort.grid,
                dx = 0,
                dy = me.pagesMarginTop,
                pageWidth = visiblePages[0].width / 20;
            for (i = 0; i < grid.length; i++, dy = me.pagesMarginTop) {
                var column = grid[i];
                for (var j = 0; j < column.length; j++) {
                    p = column[j];
                    me.renderPage(p, pages.indexOf(p), dx, dy);
                    dy += p.height / 20 + me.pagesMarginTop + me.pagesMarginBottom;
                }

                dx += pageWidth + me.pagesHorizontalMargin;
            }

            me.itemNumberVisible(me.isItemNumberVisible);
        },

        /**
         * Gets or set item number visibility
         * @memberof DPO.render.DividersPreview#
         * @param {boolean} [visible]
         * @returns boolean
         */
        itemNumberVisible: function itemNumberVisible(visible) {
            if (visible === undefined) {
                return this.isItemNumberVisible;
            }

            var attr = {
                display: visible ? 'inline' : 'none'
            };

            for (var i = 0; i < this.itemsNumbers.length; i++) {
                var el = this.itemsNumbers[i];
                el.attr(attr);
            }

            this.isItemNumberVisible = !!visible;
            return !!visible;
        },

        selectDefaultPanel: function selectDefaultPanel(el) {
            el.attr(this.selectedPanelStyle);
        },

        updateVisiblePages: function updateVisiblePages() {
            var me = this;

            if (!me.context || !me.context.project) {
                return;
            }
            var page = me._sheet[me._mode];
            me.visiblePages = [page];

            if (me.root) {
                me.update();
                me.fire('sheets:rendered', [me]);
            }
        },

        applyPageFillMode: function applyPageFillMode(options) {
            function acrossSort(a, b) {
                var c = a.position.x - b.position.x;
                return c === 0 ? (a.position.y - b.position.y) : c;
            }

            function downSort(a, b) {
                var c = a.position.y - b.position.y;
                return c === 0 ? (a.position.x - b.position.x) : c;
            }

            var me = this,
                order = [],
                i;
            for (i = 0; i < options.length; i++) {
                order.push({
                    position: options[i].position
                });
            }
            switch (me.pageFillMode) {
                case 'FillAcross':
                    order.sort(downSort);
                    break;
                case 'FillDown':
                    order.sort(acrossSort);
                    break;
            }

            for (i = 0; i < order.length; i++) {
                var pos = order[i].position;
                options[i].position = new DPO.model.Position(pos.x, pos.y);
            }

            return options;
        },

        renderPage: function renderPage(page, pageIndex, dx, dy) {
            function selectPanels(panelEl, panel) {
                me.selectDefaultPanel(panelEl, panel);
                me.selectedPanels.push([panel, panelEl]);
            }

            var me = this,
                pageCanvasMarkup = me.pageCanvasMarkup(page, dx, dy),
                pageMarkup = me.pageMarkup(page),
                pageCanvas = me.canvas.dpoRender(pageCanvasMarkup),
                panelsOptions = [],
                option, panel, p, i;

            pageCanvas.dpoRender(pageMarkup);
            me.selectedPanels = [];

            for (i = 0; i < page.panels.length; i++) {
                panel = page.panels[i];
                p = panel.position || {};

                panelsOptions.push({
                    panel: panel,
                    position: new DPO.model.Position(p.x, p.y)
                });
            }

            panelsOptions = me.applyPageFillMode(panelsOptions);

            for (i = 0; i < panelsOptions.length; i++) {
                option = panelsOptions[i];
                panel = option.panel;

                var clipPath = me.definePanelClipPath(panel),
                    panelCanvas = pageCanvas.g({
                        id: me.id + '-panel-canvas-' + pageIndex + '-' + i,
                        transform: me.panelCanvasTransform(panel, option.position)
                    });
                panelCanvas.node.setAttribute('clip-path', Snap.url(clipPath));

                var panelMarkup = me.shapeMarkup(panel),
                    shape = me.toPath(panelMarkup);

                shape.geometry['fill-rule'] = 'evenodd';

                var panelEl = panelCanvas.dpoRender(shape).attr({
                    id: me.id + '-panel-' + pageIndex + '-' + i
                }).attr(me.defaultPanelStyle);

                me.addPanelListener(panelEl, panel);
                if (me.hiddenPanels.length === page.panels.length) {
                    if (!me.hiddenPanels[i]) {
                        selectPanels(panelEl, panel);
                    }
                } else {
                    selectPanels(panelEl, panel);
                }
            }
        },

        getViewPort: function getViewPort() {
            var me = this,
                visiblePages = me.visiblePages,
                vpp = me.viewPortPadding,
                p = visiblePages[0],
                grid, i, ph, pw;
            if (p.getOrientation() === 0) {
                pw = p.width / 20;
                ph = p.height / 20;
            } else {
                ph = p.width / 20;
                pw = p.height / 20;
            }

            grid = [visiblePages];

            var maxRows = 0;
            for (i = 0; i < grid.length; i++) {
                var column = grid[0];
                maxRows = Math.max(maxRows, column.length);
            }

            var w = grid.length * pw + me.pagesHorizontalMargin * (grid.length - 1),
                h = maxRows * (ph + me.pagesMarginTop + me.pagesMarginBottom);

            return {
                width: w,
                height: h,
                grid: grid,
                viewBox: [-1, -1, w + vpp + 2, h + 2].join(',')
            };
        },

        /**
         * Defines panels clip path
         * @memberof DPO.render.PreviewPanelSelector#
         * @param {DPO.model.Panel} panel
         * @returns {string}
         */
        definePanelClipPath: function definePanelClipPath(panel) {
            var master = this.context.selector.selectMasterPanel(panel),
                id = this.id + '-clip-path-' + master.id,
                clipPath = this.root.select('#' + id);
            if (!clipPath) {
                var markup = this.shapeMarkup(master),
                    defs = this.root.select('defs'),
                    doc = this.root.node.ownerDocument;
                clipPath = Snap(doc.createElementNS('http://www.w3.org/2000/svg', 'clipPath'));
                defs.append(clipPath);
                clipPath.attr({id: id});
                clipPath.append(this.root[markup.type](markup.geometry));
            }
            return id;
        },

        addPanelListener: function addPanelListener(el, panel) {
            var me = this;
            el.click(function onPanelClick() {
                me.onPanelSelected(el, panel);
            });
        },

        /**
         * Panel event listener handler
         * @memberof DPO.render.PreviewPanelSelector#
         * @param el
         * @param {DPO.model.Panel} panel
         */
        onPanelSelected: function onPanelSelected(el, panel) {
            this.selectPanel(panel, el, true);
        },

        selectPanel: function selectPanel(panel, panelEl, fireEvent) {
            var me = this,
                pageIndex = null,
                panelIndex = null,
                pages = me.context.project.pages,
                selectedPanelIndex = me.selectedPanels.map(function (selectedPanelsList) {
                    return selectedPanelsList[0];
                }).indexOf(panel),
                page, panels, selectedPanelData, selectedPanelEl, selection;

            if (!me.selectable) {
                return;
            }

            for (var i = 0; pageIndex === null && i < pages.length; i++) {
                page = pages[i];
                panels = page.panels;

                for (var j = 0; panelIndex === null && j < panels.length; j++) {
                    if (panels[j] === panel) {
                        pageIndex = i;
                        panelIndex = j;
                    }
                }
            }

            if (pageIndex === null || panelIndex === null) {
                return;
            }

            var sheet = me.context.selector.getSheet(page);
            me._mode = sheet.front === page ? 'front' : 'back';
            me.sheet = sheet;
            if (selectedPanelIndex !== -1) {
                selectedPanelData = me.selectedPanels[selectedPanelIndex];
                selectedPanelEl = selectedPanelData[1];
                selectedPanelEl.attr(me.defaultPanelStyle);
                me.selectedPanels.splice(selectedPanelIndex, 1);
                selection = false;
            } else {
                me.selectedPanels.push([panel, panelEl]);
                me.selectedPanelEl = panelEl;
                me.selectedPanel = panel;
                me.updateSelectedPanel();
                selection = true;
            }

            if (fireEvent) {
                me.fire('changed:panel:selected', [panelEl, selection]);
            }
        },

        updateSelectedPanel: function updateSelectedPanel() {
            var me = this,
                panel = me.selectedPanel,
                pageIndex = null,
                panelIndex = null,
                pages = me.context.project.pages,
                page, panels;
            for (var i = 0; pageIndex === null && i < pages.length; i++) {
                page = pages[i];
                panels = page.panels;

                for (var j = 0; panelIndex === null && j < panels.length; j++) {
                    if (panels[j] === panel) {
                        pageIndex = i;
                        panelIndex = j;
                    }
                }
            }

            var panelId = me.id + '-panel-' + pageIndex + '-' + panelIndex,
                el = Snap('#' + panelId);
            el.attr(me.selectedPanelStyle);
            me.selectedPanelEl = el;
        },

        /**
         * Destroys component
         * @memberof DPO.render.Preview#
         */
        destroy: function destroy() {
            var me = this;
            me.resetObservable();
            me.context = null;
        }
    });

    return PreviewPanelSelector;
});
DPO.def('render.PreviewCss3D', function () {
    function cssPrefix(css) {
        var keys = Object.keys(css);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            css['-webkit-' + key] = css[key];
            css['-moz-' + key] = css[key];
            css['-o-' + key] = css[key];
        }
        return css;
    }

    var cssMatrix = window.CSSMatrix || window.MSCSSMatrix || window.WebKitCSSMatrix || window.DOMMatrix;

    function Vector() {
    }

    Vector.create = function create(elements) {
        var V = new Vector();
        return V.setElements(elements);
    };
    Vector.prototype = {
        dot: function dot(vector) {
            var V = vector.elements,
                product = 0, n = this.elements.length;
            do {
                product += this.elements[n - 1] * V[n - 1];
            } while (--n);
            return product;
        },

        setElements: function setElements(els) {
            this.elements = (els.elements || els).slice();
            return this;
        }
    };

    /**
     * @class DPO.render.PreviewCss3D
     * @memberof DPO.render
     * @extends DPO.mixins.Observable
     * @param {Element} el
     * @param {DPO.render.Context} context
     * @param {object} [cfg]
     * @constructor
     */
    function PreviewCss3D(el, context, cfg) {
        cfg = cfg || {};
        var me = this;
        me.id = DPO.id();
        me.el = el;
        me.context = context;
        me.animationState = DPO.emptyFn;
        me.filter = cfg.filter || context.filter || DPO.project.Filter.MatchAll;

        me.scale = 1;
        me.PIXELS_PER_ROUND = 50;
        me.resetObservable();
        me.onMouseDown = me.onMouseDown.bind(me);
        me.onMouseMove = me.onMouseMove.bind(me);
        me.onMouseUp = me.onMouseUp.bind(me);
        me.onMouseWheel = me.onMouseWheel.bind(me);
        el.addEventListener('mousedown', me.onMouseDown, false);
        el.addEventListener('mousewheel', me.onMouseWheel, false);
        el.addEventListener('DOMMouseScroll', me.onMouseWheel, false); // firefox
        DPO.mixin(me, cfg);
    }

    DPO.inherit(PreviewCss3D, DPO.render.Renderer);

    DPO.mixin(PreviewCss3D.prototype, DPO.mixins.Observable);
    DPO.mixin(PreviewCss3D.prototype, {
        viewPortStyle: DPO.mixin({
            'margin': '0',
            'padding': '0',
            'position': 'absolute',
            'left': '50%',
            'top': '50%'
        }, cssPrefix({
            'perspective': '1200px',
            'transform': 'translateX(-50%) translateY(-50%)',
            'perspective-origin': '50% 50%'
        })),

        cameraStyle: DPO.mixin({}, cssPrefix({
            'transform-origin': 'center center',
            'transform-style': 'preserve-3d'
        })),

        faceStyle: DPO.mixin({
            'position': 'absolute'
        }, cssPrefix({
            'backface-visibility': 'hidden'
        })),

        planeStyles: DPO.mixin({
            'width': '100%',
            'height': '100%',
            'position': 'absolute'
        }, cssPrefix({
            'transform': 'translate3d(0,0,0)',
            'transform-style': 'preserve-3d',
            'transform-origin': 'center center'
        })),

        clearViewPort: function clearViewPort() {
            var me = this;
            DPO.render.clearContainer(me.el);
            me.viewPort = document.createElement('div');
            me.viewPort.id = me.id + '-view-port';
            DPO.render.applyStyles(me.viewPort, me.viewPortStyle);
            me.el.appendChild(me.viewPort);
            me.planes = [];
            me.createCamera();
        },

        createCamera: function createCamera() {
            var me = this;
            me.camera = document.createElement('div');
            me.camera.id = me.id + '-camera';
            me.cameraRotation = {x: 0, y: 0, z: 0};
            DPO.render.applyStyles(me.camera, me.cameraStyle);
            me.viewPort.appendChild(me.camera);
        },

        createPlane: function createPlane(extraStyle) {
            extraStyle = extraStyle || {};

            var me = this,
                el = document.createElement('div');
            DPO.render.applyStyles(el, me.planeStyles);
            DPO.render.applyStyles(el, extraStyle);

            me.camera.appendChild(el);
            var plane = {
                el: el,
                front: Snap(),
                back: Snap()
            };
            el.id = me.id + '-plane-' + me.planes.length;
            el.appendChild(plane.front.node);
            el.appendChild(plane.back.node);
            DPO.render.applyStyles(plane.front.node, me.faceStyle);
            DPO.render.applyStyles(plane.back.node, me.faceStyle);
            DPO.render.applyStyles(plane.back.node, {
                '-webkit-transform': 'rotateY(180deg)',
                'transform': 'rotateY(180deg)'
            });
            me.planes.push(plane);

            return plane;
        },

        updateViewPortSize: function updateViewPortSize(sheet) {
            var me = this,
                mp = me.context.selector.selectMasterPanel(sheet.front.panels[0]);
            me.viewPortWidth = mp.width / 20;
            me.viewPortHeight = mp.height / 20;
            me.zoom(me.scale, true);
        },

        zoom: function zoom(value, force) {
            var me = this,
                style = {
                    width: me.viewPortWidth * value + 'pt',
                    height: me.viewPortHeight * value + 'pt'
                };
            if (me.scale === value && !force) {
                return;
            }

            me.scale = value;
            if (me.viewPort && me.camera) {
                DPO.render.applyStyles(me.viewPort, style);
                DPO.render.applyStyles(me.camera, style);
                for (var i = 0; i < me.planes.length; i++) {
                    var p = me.planes[i];
                    DPO.render.applyStyles(p.el, DPO.mixin(style, {'backface-visibility': 'hidden'}));
                    DPO.render.applyStyles(p.front.node, style);
                    DPO.render.applyStyles(p.back.node, style);
                }

                me.fire('changed:scale', [value]);
            }
        },

        createScene: function createScene(productType) {
            var me = this,
                ctx = me.context,
                sheet = ctx.selector.selectSheets()[0];
            switch (productType) {
                case 'CardTall':
                case 'Card_NoteCardTall':
                case 'Card_GreetingCardTall':
                case 'BusinessCard_FoldDblSideTall':
                    me.renderVerticalFold(sheet);
                    break;
                case 'CardWide':
                case 'Card_NoteCardWide':
                case 'Card_GreetingCardWide':
                case 'BusinessCard_FoldDblSideWide':
                    me.renderHorizontalFold(sheet);
                    break;
                case 'Card_TentCard':
                    me.renderTentCard(sheet);
                    break;
                default:
                    me.renderCard(sheet, 0);
                    break;
            }
            me.updateViewPortSize(sheet);
            me.animationState(0);
        },

        renderTentCard: function renderTentCard(sheet) {
            var me = this,
                pages = [sheet.front],
                panel,
                plane;

            me.clearViewPort();

            plane = me.createPlane();
            DPO.render.applyStyles(plane.el, cssPrefix({'transform-origin': 'center top'}));

            panel = me.getPanelByDescription(pages, 'Back');
            plane.frontShade = me.render(plane.front, panel, true);

            panel = me.getPanelByDescription(pages, 'Back');
            plane.backShade = me.render(plane.back, panel);

            plane = me.createPlane();
            DPO.render.applyStyles(plane.el, cssPrefix({'transform-origin': 'center top'}));
            panel = me.getPanelByDescription(pages, 'Front');
            plane.frontShade = me.render(plane.front, panel);

            panel = me.getPanelByDescription(pages, 'Front');
            plane.backShade = me.render(plane.back, panel, true);

            DPO.render.applyStyles(plane.back.node, {
                '-webkit-transform': 'rotateX(180deg)',
                'transform': 'rotateX(180deg)'
            });

            me.animationState = function state(value) {
                var deg = 10 + 30 * value,
                    t1 = ' translateZ(1px) rotateX(' + deg + 'deg)',
                    t2 = ' translateZ(1px) rotateX(-' + deg + 'deg)';
                DPO.render.applyStyles(me.planes[1].el, cssPrefix({
                    transform: t1
                }));
                DPO.render.applyStyles(me.planes[0].el, cssPrefix({
                    transform: t2
                }));
                me.updateShades();
            };
        },

        renderCard: function renderCard(sheet) {
            var me = this;
            me.clearViewPort();
            me.createPlane();

            var plane = me.planes[0],
                front = sheet.front.panels[0],
                back = sheet.back ? sheet.back.panels[0] : front;
            plane.frontShade = me.render(plane.front, front);
            plane.backShade = me.render(plane.back, back, front === back);
            me.updateViewPortSize(sheet);
        },

        getPanelByDescription: function getPanelByDescription(pages, description) {
            var descRegEx = new RegExp(description, 'i');
            for (var i = 0; i < pages.length; i++) {
                var page = pages[i];
                for (var j = 0; j < page.panels.length; j++) {
                    var panel = page.panels[j];
                    if (panel.description && descRegEx.test(panel.description.value)) {
                        return panel;
                    }
                }
            }
            return null;
        },

        renderVerticalFold: function renderVerticalFold(sheet) {
            var me = this,
                pages = [sheet.front, sheet.back],
                panel, plane;
            me.clearViewPort();

            plane = me.createPlane();
            panel = me.getPanelByDescription(pages, 'Right');
            plane.frontShade = me.render(plane.front, panel);

            panel = me.getPanelByDescription(pages, 'Back');
            plane.backShade = me.render(plane.back, panel);

            plane = me.createPlane();
            panel = me.getPanelByDescription(pages, 'Front');
            plane.frontShade = me.render(plane.front, panel);

            panel = me.getPanelByDescription(pages, 'Left');
            plane.backShade = me.render(plane.back, panel);

            DPO.render.applyStyles(me.planes[1].el, cssPrefix({'transform-origin': 'left center'}));
            me.animationState = function state(value) {
                var transform = ' translateZ(1px) rotateY(' + (-180 * value) + 'deg)';
                DPO.render.applyStyles(me.viewPort, cssPrefix({
                    transform: 'translateX(-' + (50 - 50 * value) + '%) translateY(-50%)'
                }));
                DPO.render.applyStyles(me.camera, cssPrefix({
                    'transform-origin': (50 - 50 * value) + '% center'
                }));
                DPO.render.applyStyles(me.planes[1].el, cssPrefix({
                    transform: transform
                }));
                me.updateShades();
            };
        },

        renderHorizontalFold: function renderHorizontalFold(sheet) {
            var me = this,
                pages = [sheet.front, sheet.back],
                panel, plane;
            me.clearViewPort();
            plane = me.createPlane();
            panel = me.getPanelByDescription(pages, 'Bottom');
            plane.frontShade = me.render(plane.front, panel);

            panel = me.getPanelByDescription(pages, 'Back');
            plane.backShade = me.render(plane.back, panel);

            plane = me.createPlane();
            panel = me.getPanelByDescription(pages, 'Front');
            plane.frontShade = me.render(plane.front, panel);

            panel = me.getPanelByDescription(pages, 'Top');
            plane.backShade = me.render(plane.back, panel);

            DPO.render.applyStyles(plane.back.node, {
                '-webkit-transform': 'rotateX(180deg)',
                'transform': 'rotateX(180deg)'
            });
            DPO.render.applyStyles(plane.el, cssPrefix({'transform-origin': 'center top'}));

            me.animationState = function state(value) {
                var transform = ' translateZ(1px) rotateX(' + 180 * value + 'deg)';
                DPO.render.applyStyles(me.viewPort, cssPrefix({
                    transform: 'translateX(-50%) translateY(-' + (50 - 50 * value) + '%)'
                }));
                DPO.render.applyStyles(me.camera, cssPrefix({
                    'transform-origin': 'center ' + (50 - 50 * value) + '%'
                }));
                DPO.render.applyStyles(me.planes[1].el, cssPrefix({
                    transform: transform
                }));
                me.updateShades();
            };
        },

        definePanelClipPath: function definePanelClipPath(canvas, panel) {
            var me = this,
                master = me.context.selector.selectMasterPanel(panel),
                id = me.id + '-clip-path-' + master.id,
                markup = me.shapeMarkup(master),
                defs = canvas.select('defs'),
                doc = canvas.node.ownerDocument,
                shape = me.toPath(markup);

            for (var k = 0; k < master.cutouts.length; k++) {
                var cutout = master.cutouts[k],
                    pos = cutout.position,
                    path = me.toPath(me.shapeMarkup(cutout), pos.x / 20, pos.y / 20);
                shape.geometry.d += ' ' + path.geometry.d;
            }
            shape.geometry['clip-rule'] = 'evenodd';

            var clipPath = Snap(doc.createElementNS('http://www.w3.org/2000/svg', 'clipPath'));
            defs.append(clipPath);
            clipPath.attr({id: id});
            clipPath.append(canvas[shape.type](shape.geometry));
            return id;
        },

        renderItem: function renderField(item, canvas) {
            var me = this;
            if (!me.filter.matchField(item.field)) {
                return;
            }

            var index = me.context.selector.panelIndex(item.panel),
                f = me.context.binder.bindDataToField(/** @type DPO.model.Field*/item.field, index),
                markup = me.fieldMarkup(f, null, index, true);
            canvas.dpoRender(markup);
        },

        render: function render(canvas, panel, blank) {
            var me = this,
                mp = me.context.selector.selectMasterPanel(panel),
                viewBox = [0, 0, mp.width / 20, mp.height / 20].join(' ');

            canvas.clear();
            canvas.attr({
                width: mp.width / 20,
                height: mp.height / 20,
                viewBox: viewBox
            });

            var orderedFields = this.context.selector.getFieldOrder(panel),
                clipPath = me.definePanelClipPath(canvas, panel),
                panelCanvas = canvas.g({});

            panelCanvas.node.setAttribute('clip-path', Snap.url(clipPath));
            panelCanvas.rect(0, 0, mp.width / 20, mp.height / 20).attr({
                fill: 'white'
            });

            for (var j = 0; !blank && j < orderedFields.items.length; j++) {
                var item = orderedFields.items[j];
                item.panel = panel;
                me.renderItem(item, panelCanvas);
            }

            return panelCanvas.rect(0, 0, mp.width / 20, mp.height / 20).attr({
                id: me.id + '-shader',
                fill: 'none'
            });
        },

        rotateCamera: function rotateCamera(x, y, z) {
            var me = this;
            me.cameraRotation = {x: x, y: y, z: z};
            me.updateCamera();
        },

        updateCamera: function updateCamera() {
            var me = this,
                r = me.cameraRotation;
            r.x = (r.x + 360) % 360;
            r.y = (r.y + 360) % 360;
            r.z = (r.z + 360) % 360;
            var transform = 'rotateY(' + r.y + 'deg) ' + 'rotateZ(' + r.z + 'deg) ' + 'rotateX(' + r.x + 'deg)';
            DPO.render.applyStyles(me.camera, cssPrefix({transform: transform}));
            me.updateShades();
        },

        getTransformString: function getTransformString() {
            if (this.transformString) {
                return this.transformString;
            }

            var tests = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'],
                element = document.createElement('div'),
                transformString;

            for (var i = 0; i < tests.length; i++) {
                if (element.style[tests[i]] === '') {
                    transformString = tests[i];
                }
            }

            this.transformString = transformString;
            return transformString;
        },

        updateShades: function updateShades() {
            var me = this,
                ts = this.getTransformString(),
                light = Vector.create([0, 0, 1]);

            function transformToFloat32Array(tl) {
                var string = tl.slice(tl.indexOf('(') + 1, -1),
                    arr = string.split(',');
                return new Float32Array(arr);
            }

            function getMatrix(el) {
                var transform = window.getComputedStyle(el)[ts];

                if (!transform || transform === 'none') {
                    transform = 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)';
                }

                //@rtrukh: dirty-hack for Mozilla Firefox
                if (cssMatrix.prototype.constructor.name === 'DOMMatrix') {
                    transform = transformToFloat32Array(transform);
                }

                return new cssMatrix(transform);
            }

            function collectTransform(el) {
                var array = [],
                    m = new cssMatrix();
                while (el && el !== me.viewPort) {
                    array.push(getMatrix(el));
                    el = el.parentElement || /* istanbul ignore next */ el.parentNode;
                }

                for (var i = 0; i < array.length; i++) {
                    m = m.multiply(array[i]);
                }

                return m;
            }

            function shade(el) {
                var m = collectTransform(el),
                    normal = Vector.create([
                        m.m13,
                        m.m23,
                        m.m33
                    ]),
                    intensity = normal.dot(light);
                intensity = Math.min(intensity, 1);
                intensity = Math.max(intensity, 0);
                return {
                    fill: 'black',
                    opacity: 0.25 * (1 - intensity)
                };
            }

            for (var i = 0; i < me.planes.length; i++) {
                var p = me.planes[i],
                    front = shade(p.front.node),
                    back = shade(p.back.node);

                p.frontShade.attr(front);
                p.backShade.attr(back);
            }
        },

        onMouseDown: function onMouseDown(event) {
            var me = this;
            event.stopPropagation();
            event.preventDefault();

            me.rotateStart = {x: event.clientX, y: event.clientY};
            document.addEventListener('mousemove', me.onMouseMove, false);
            document.addEventListener('mouseup', me.onMouseUp, false);
        },

        onMouseMove: function onMouseMove(event) {
            var me = this;
            event.stopPropagation();
            event.preventDefault();

            me.rotateEnd = {x: event.clientX, y: event.clientY};
            me.rotateDelta = {
                x: me.rotateEnd.x - me.rotateStart.x,
                y: me.rotateEnd.y - me.rotateStart.y
            };

            me.cameraRotation.y += 2 * Math.PI * me.rotateDelta.x / me.PIXELS_PER_ROUND;
            me.cameraRotation.x -= 2 * Math.PI * me.rotateDelta.y / me.PIXELS_PER_ROUND;
            me.updateCamera();

            me.rotateStart = me.rotateEnd;
        },

        onMouseUp: function onMouseUp(event) {
            var me = this;
            event.stopPropagation();
            event.preventDefault();
            document.removeEventListener('mousemove', me.onMouseMove, false);
            document.removeEventListener('mouseup', me.onMouseUp, false);
        },

        onMouseWheel: function onMouseWheel(event) {
            var me = this;
            event.stopPropagation();
            event.preventDefault();

            var delta = event.wheelDelta || /* istanbul ignore next */ -event.detail,
                v = me.scale + delta / 120 * 0.05;
            v = Math.max(0.25, v);
            v = Math.min(4, v);
            me.zoom(v);
        },

        destroy: function destroy() {
            var me = this;
            DPO.render.clearContainer(me.el);
            me.el.addEventListener('mousedown', me.onMouseDown, false);
            me.el.addEventListener('mousewheel', me.onMouseWheel, false);
            me.el.addEventListener('DOMMouseScroll', me.onMouseWheel, false); // firefox
        }
    });

    return PreviewCss3D;
})
;

DPO.def('render.DividersPreview', function (ns) {
    /**
     * Creates a new DividersPreview object.
     * @class DPO.render.DividersPreview
     * @extends DPO.render.Renderer
     * @extends DPO.mixins.Observable
     * @memberof DPO.render
     * @property {string} id
     * @property {DPO.project.DividersCreator} dividersCreator
     * @property {object} sheet
     * @property {DPO.model.Panel} selectedPanel
     * @property {boolean} animating
     * @property {number} sheetsPerScreen
     * @param {Element} el
     * @param {DPO.render.Context} context
     * @param {object} [cfg]
     * @fires animation:finished
     * @fires changed:zoom
     * @fires changed:panel:selected
     * @constructor
     */
    function DividersPreview(el, context, cfg) {
        cfg = cfg || {};

        var me = this;
        me._dividersCreator = null;
        me._sheet = null;
        me._mode = 'front';
        me._page = null;
        me._provider = null;

        me._sheetsPerScreen = 1;
        me.animating = false;
        me.visiblePages = [];
        me.el = el;

        DPO.mixin(me, cfg);
        DPO.render.Renderer.apply(me, [context]);

        me.itemsNumbers = [];
        me.isItemNumberVisible = false;
        me.panelDescriptions = [];
        me.resetObservable();
        me.render();
        
        me.update();
    }

    DPO.inherit(DividersPreview, ns.Renderer);

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Properties
    // -----------------------------------------------------------------------------------------------------------------
    Object.defineProperty(DividersPreview.prototype, 'context', {
        get: function get() {
            return this._context;
        },

        set: function set(value) {
            var me = this, pt;
            if (me._context === value) {
                return;
            }

            if (me._context) {
                me._context.provider.un(/changed:data-source.*/, me.updateContent, me);
                pt = me.context.projectTransformer;
                if (pt) {
                    pt.un(/sheet/, me.updateVisiblePages, me);
                }

                me._context.layoutManager.un('fonts:loaded', me.onFontsLoaded, me);
            }

            me._context = value;

            if (value) {
                value.provider.on(/changed:data-source.*/, me.updateContent, me);
                pt = value.projectTransformer;
                if (pt) {
                   pt.on(/sheet/, me.updateVisiblePages, me);
                }

                if (value.project) {
                    this.sheet = value.selector.selectSheets()[0];
                    this.dividersCreator = new DPO.project.DividersCreator(value);
                    this.dividersCreator.createDividersSets();
                    me.updateVisiblePages();
                }

                me.context.layoutManager.on('fonts:loaded', me.onFontsLoaded, me);
            }
        }
    });

    Object.defineProperty(DividersPreview.prototype, 'sheet', {
        get: function get() {
            return this._sheet;
        },

        set: function set(value) {
            var me = this;
            me._sheet = value;
        }
    });

    // -----------------------------------------------------------------------------------------------------------------
    // -- Public Methods
    // -----------------------------------------------------------------------------------------------------------------
    DPO.mixin(DividersPreview.prototype, DPO.mixins.Observable);
    DPO.mixin(DividersPreview.prototype, {
        viewPortPadding: 5,
        pagesMarginTop: 10,
        pagesMarginBottom: 10,
        pagesHorizontalMargin: 20,

        enablePanelSelection: true,
        descriptionFontSize: 5,

        colorStyles: [
            {
                'fill': '#ffd700',
                'fill-opacity': '0.1',
                'stroke': '#ffa500',
                'stroke-width': 2
            },
            {
                'fill': '#86b34d',
                'fill-opacity': '0.1',
                'stroke': '#86b34d',
                'stroke-width': 2
            }
        ],

        selectedPanelStyle: {
            'fill': '#FF1919',
            'fill-opacity': '0.1',
            'stroke': '#B82E00',
            'stroke-width': 2
        },

        defaultPanelStyle: {
            'fill': 'none',
            'stroke': '#B8C2C9',
            'stroke-width': 1
        },

        updateVisiblePages: function updateVisiblePages() {
            var me = this;

            if (!me.context || !me.context.project) {
                return;
            }
            var page = me._sheet[me._mode];
            me.visiblePages = [page];

            if (me.root) {
                me.update();
                me.fire('sheets:rendered', [me]);
            }
        },

        /**
         * Gets or set item number visibility
         * @memberof DPO.render.DividersPreview#
         * @param {boolean} [visible]
         * @returns boolean
         */
        itemNumberVisible: function itemNumberVisible(visible) {
            if (visible === undefined) {
                return this.isItemNumberVisible;
            }

            var attr = {
                display: visible ? 'inline' : 'none'
            };

            for (var i = 0; i < this.itemsNumbers.length; i++) {
                var el = this.itemsNumbers[i];
                el.attr(attr);
            }

            this.isItemNumberVisible = !!visible;
            return !!visible;
        },

        getViewPort: function getViewPort() {
            var me = this,
                visiblePages = me.visiblePages;
            var vpp = me.viewPortPadding,
                grid, i, p, ph, pw;
            p = visiblePages[0];
            if (p.getOrientation() === 0) {
                pw = p.width / 20;
                ph = p.height / 20;
            } else {
                ph = p.width / 20;
                pw = p.height / 20;
            }

            grid = [visiblePages]; // always one page for display

            var maxRows = 0;
            for (i = 0; i < grid.length; i++) {
                var column = grid[0];
                maxRows = Math.max(maxRows, column.length);
            }

            var w = grid.length * pw + me.pagesHorizontalMargin * (grid.length - 1),
                h = maxRows * (ph + me.pagesMarginTop + me.pagesMarginBottom);

            return {
                width: w,
                height: h,
                grid: grid,
                viewBox: [-1, -1, w + vpp + 2, h + 2].join(',')
            };
        },

        /**
         * Render page with index inside el container
         * @memberof DPO.render.DividersPreview#
         */
        render: function render() {
            var me = this,
                svgNS = 'http://www.w3.org/2000/svg',
                rootEl = document.createElementNS(svgNS, 'svg');

            me.rootEl = rootEl;
            me.root = Snap(me.rootEl);
            me.canvas = me.root.g();

            rootEl.id = me.id;

            me.root.attr({
                'pointer-events': 'none',
                'preserveAspectRatio': 'xMidYMid meet'
            });

            if (me.el) {
                DPO.render.clearContainer(me.el);
                me.el.appendChild(rootEl);
            }
        },

        /**
         * Defines panels clip path
         * @memberof DPO.render.DividersPreview#
         * @param {DPO.model.Panel} panel
         * @returns {string}
         */
        definePanelClipPath: function definePanelClipPath(panel) {
            var master = this.context.selector.selectMasterPanel(panel),
                id = this.id + '-clip-path-' + master.id,
                clipPath = this.root.select('#' + id);
            if (!clipPath) {
                var markup = this.shapeMarkup(master),
                    defs = this.root.select('defs'),
                    doc = this.root.node.ownerDocument;
                clipPath = Snap(doc.createElementNS('http://www.w3.org/2000/svg', 'clipPath'));
                defs.append(clipPath);
                clipPath.attr({id: id});
                clipPath.append(this.root[markup.type](markup.geometry));
            }
            return id;
        },

        /**
         * Render Page
         * @memberof DPO.render.DividersPreview#
         * @param {DPO.model.Page} page
         * @param {number} pageIndex
         * @param {number} dx
         * @param {number} dy
         */
        renderPage: function renderPage(page, pageIndex, dx, dy) {
            var me = this,
                pageCanvasMarkup = me.pageCanvasMarkup(page, dx, dy),
                pageMarkup = me.pageMarkup(page),
                pageCanvas = me.canvas.dpoRender(pageCanvasMarkup);
            pageCanvas.dpoRender(pageMarkup);

            var allSets = me.dividersCreator.currentSets;

            for (var i = 0; i < page.panels.length; i++) {
                var panel = page.panels[i];
                var clipPath = me.definePanelClipPath(panel),
                    panelCanvas = pageCanvas.g({
                        id: me.id + '-panel-canvas-' + pageIndex + '-' + i,
                        transform: me.panelCanvasTransform(panel)
                    });
                panelCanvas.node.setAttribute('clip-path', Snap.url(clipPath));

                var panelMarkup = me.shapeMarkup(panel),
                    shape = me.toPath(panelMarkup);

                shape.geometry['fill-rule'] = 'evenodd';

                var panelEl = panelCanvas.dpoRender(shape).attr({
                    id: me.id + '-panel-' + pageIndex + '-' + i
                }).attr(me.defaultPanelStyle);

                var panelDescription = me.dividersCreator.getPanelDescriptionFromSet(allSets, panel);
                if (panelDescription) {
                    var itemNumberMarkup = me.itemNumberCustomMarkup(page, panel, panelDescription.number);
                    me.itemsNumbers.push(panelCanvas.dpoRender(itemNumberMarkup));
                    var index = (me.dividersCreator.autocopyDividers) ? panelDescription.number : panelDescription.indexInSet;
                    me.visualizePanelInSet(panelEl, panel, index);
                }
            }
        },

        /**
         * Create custom markup for panel number
         * @memberof DPO.render.DividersPreview#
         * @param {DPO.model.Page} page
         * @param {DPO.model.Panel} panel
         * @param {number} number
         */
        itemNumberCustomMarkup: function itemNumberCustomMarkup(page, panel, number) {
            function pad(num, size) {
                var s = '' + num;
                return s.substr(s.length - size);
            }

            var selector = this.context.selector,
                index = selector.panelIndex(panel),
                mp = selector.selectMasterPanel(panel),
                min = Math.min(mp.width, mp.height),
                max = Math.max(mp.width, mp.height),
            //r = max / 200, // ToDo: change in here to make text size countable
                aspect = min / max;
            if (aspect < 0.2) {
                //r = min / 10;
            }

            var metrics = DPO.text.DefaultMetrics,
                maxFontMetrics = metrics.getMetrics('Arial'),
                fontSize = 14,
                id = this.id + '-item-number-' + index;
            return new DPO.render.Markup({
                geometry: {
                    id: id
                },
                attributes: {
                    'pointer-events': 'none'
                },
                children: [{
                    type: 'text',
                    geometry: {
                        x: mp.width / 40,
                        y: mp.height / 40,
                        opacity: 0.8,
                        textAnchor: 'middle',
                        id: id + '-text'
                    },
                    overrideChildren: true,
                    children: [{
                        type: 'dpoSpan',
                        geometry: {
                            id: id + '-span',
                            text: pad(number + 1, 2)   ///  here is text to set
                        },
                        style: {
                            'dy': metrics.getCapHeight(maxFontMetrics, fontSize) / 2,
                            'font-size': fontSize,
                            'font-family': 'Arial',
                            'fill': 'black'
                        }
                    }]
                }]
            });
        },

        update: function update() {
            var me = this,
                visiblePages = me.visiblePages;

            me.itemsNumbers = [];
            me.canvas.clear();
            DPO.render.clearContainer(me.root.select('defs').node);

            if (!visiblePages.length) {
                return;
            }

            var viewPort = me.getViewPort(),
                pages = me.context.project.pages,
                i, p;

            me.root.attr({viewBox: viewPort.viewBox});

            var grid = viewPort.grid,
                dx = 0,
                dy = me.pagesMarginTop,
                pageWidth = visiblePages[0].width / 20;
            for (i = 0; i < grid.length; i++, dy = me.pagesMarginTop) {
                var column = grid[i];
                for (var j = 0; j < column.length; j++) {
                    p = column[j];
                    me.renderPage(p, pages.indexOf(p), dx, dy);
                    dy += p.height / 20 + me.pagesMarginTop + me.pagesMarginBottom;
                }

                dx += pageWidth + me.pagesHorizontalMargin;
            }

            me.itemNumberVisible(me.isItemNumberVisible);
        },

        /**
         * Color in red the selected set of panels
         * @memberof DPO.render.DividersPreview#
         * @param {number} index
         */
        updateSelectedSetOfPanels: function updateSelectedSetOfPanels(index) {
            var me = this,
                currentSet = me.dividersCreator.currentSets[index];
            me.update();
            for (var i = 0; i < currentSet.panels.length; i++) {
                var panelId = me.id + '-panel-' + 0 + '-' + currentSet.panels[i].index,
                    el = Snap('#' + panelId);
                el.attr(me.selectedPanelStyle);
            }
        },

        /**
         * Visualize panels due to set's number
         * @memberof DPO.render.DividersPreview#
         * @param {Element} el
         * @param {DPO.model.Panel} panel
         * @param {number} setNumber
         */
        visualizePanelInSet: function visualizePanelInSet(el, panel, setNumber) {
            var me = this;
            el.attr(me.colorStyles[setNumber % 2]);
        },

        onFontsLoaded: function onFontsLoaded() {
            this.updateVisiblePages();
        },

        /**
         * Destroys component
         * @memberof DPO.render.DividersPreview#
         */
        destroy: function destroy() {
            var me = this;
            me.resetObservable();
            me.context = null;
            if (me.root) {
                me.root.remove();
                me.root = null;
            }
        }
    });

    return DividersPreview;
});

DPO.def('render.DeviceColorSpace', function () {
    /**
     * Creates a new DeviceColorSpace object
     * @class DPO.render.DeviceColorSpace
     * @extends DPO.mixins.Observable
     * @memberof DPO.render
     * @param {string} gamutURL
     * @constructor
     */
    function DeviceColorSpace(gamutURL) {
        var me = this;
        me.ready = false;
        me.gamutURL = gamutURL;
        me.canvas = document.createElement('canvas');
        me.canvas.width = 256;
        me.canvas.height = 256;
        me.cache = {};
        me.gamut = new Image();
        me.gamut.crossOrigin = 'Anonymous';
        me.gamut.addEventListener('load', me.gamutLoaded.bind(me));
        me.loadGamutImg(me.gamut, gamutURL);
        me.pendingRequests = [];
        me.resetObservable();
    }

    DPO.mixin(DeviceColorSpace.prototype, DPO.mixins.Observable);
    DPO.mixin(DeviceColorSpace.prototype, {
        parseColor: function parseColor(input) {
            var m = input.match(/^#([0-9a-f]{6})$/i);
            m = m ? m[1] : null;
            return m ? [
                parseInt(m.substr(0, 2), 16),
                parseInt(m.substr(2, 2), 16),
                parseInt(m.substr(4, 2), 16)
            ] : null;
        },

        gamutLoaded: function gamutLoaded() {
            var me = this;

            function setReady() {
                me.ready = true;
                for (var i = 0; i < me.pendingRequests.length; i++) {
                    var r = me.pendingRequests[i];
                    me.lookupColors(r.colors, r.callback);
                }
                me.fire('gamut:loaded', [me]);
            }

            function test() {
                var p = me.getPixel([0, 0, 0]);
                if (p[3]) {
                    setReady();
                } else {
                    setTimeout(test, 10);
                }
            }

            test();
        },

        loadGamutImg: function loadGamutImg (gamut, gamutURL){
            var me = this;

            function detectIE10 (ua){
                return /(msie|trident |rv:).?(10\.\d)/i.test(ua);
            }

            if (detectIE10(navigator.userAgent)){
                var xhr = new XMLHttpRequest(),
                    URL = window.URL;

                xhr.onreadystatechange = function(){
                    if (xhr.readyState === 4 && xhr.status === 200){
                        me.gamut.src = URL.createObjectURL(xhr.response)
                    }
                };

                xhr.open('GET', gamutURL);
                xhr.responseType = 'blob';
                xhr.send();
            } else {
                me.gamut.src = gamutURL;
            }

        },

        getPixel: function getPixel(rgb) {
            var me = this,
                ctx = me.canvas.getContext('2d'),
                x = Math.floor(rgb[1] % 16) * 256,
                y = Math.floor(rgb[1] / 16) * 256;
            ctx.imageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
            ctx.drawImage(me.gamut, x, y, 256, 256, 0, 0, 256, 256);

            return ctx.getImageData(rgb[2], rgb[0], 1, 1).data;
        },

        lookupColors: function lookupColors(colors, callback) {
            var me = this,
                map = {};
            for (var i = 0; i < colors.length; i++) {
                var c = colors[i],
                    rgb = me.parseColor(c.replace('0x', '#'));
                if (me.cache[rgb]) {
                    map[c] = me.cache[rgb];
                    continue;
                }

                var ctx = me.canvas.getContext('2d'),
                    x = Math.floor(rgb[1] % 16) * 256,
                    y = Math.floor(rgb[1] / 16) * 256;
                ctx.imageSmoothingEnabled = false;
                ctx.mozImageSmoothingEnabled = false;
                ctx.msImageSmoothingEnabled = false;
                ctx.drawImage(me.gamut, x, y, 256, 256, 0, 0, 256, 256);

                var d = me.getPixel(rgb),
                    hex = '#';
                hex += ('0' + (d[0]).toString(16)).substr(-2);
                hex += ('0' + (d[1]).toString(16)).substr(-2);
                hex += ('0' + (d[2]).toString(16)).substr(-2);
                map[c] = hex;
                me.cache[rgb] = hex;
            }

            callback(map);
        },

        /**
         * Converts colors
         * @memberof DPO.render.DeviceColorSpace#
         * @param {string[]} colors
         * @param {function} callback
         */
        convertColors: function convertColors(colors, callback) {
            var me = this;
            if (this.ready) {
                me.lookupColors(colors, callback);
                return;
            }

            me.pendingRequests.push({
                colors: colors,
                callback: callback
            });
        }
    });

    return DeviceColorSpace;
});

DPO.def('bll.ActionChain', function () {
    /**
     * Creates base action chain class
     * @class DPO.bll.ActionChain
     * @memberof DPO.bll
     * @property {DPO.bll.ActionChain} nextChain
     * @constructor
     */
    function ActionChain() {
    }

    var sharedData = {};

    //noinspection JSUnusedLocalSymbols
    DPO.mixin(ActionChain.prototype, {
        nextChain: null,

        /**
         * Collects actions
         * @memberof DPO.bll.ActionChain#
         * @protected
         * @abstract
         * @param {object} actions
         * @param {DPO.model.Field[]} fields
         */
        collectActions: function collectActions(actions, fields) {
        },

        /**
         * Returns available action map
         * @memberof DPO.bll.ActionChain#
         * @param {DPO.model.Field[]} fields
         * @returns {object}
         */
        getActions: function getActions(fields) {
            var actions = {},
                array = [],
                c;
            fields = fields || [];

            for (c = this; c && array.indexOf(c) === -1; c = c.nextChain) {
                array.push(c);
            }

            for (var i = array.length - 1; i >= 0; i--) {
                c = array[i];
                c.collectActions(actions, fields);
            }

            return actions;
        },

        /**
         * Return shared data by specified key
         * @memberof DPO.bll.ActionChain#
         * @param {string} key
         * @returns {*}
         */
        getData: function getData(key) {
            return sharedData[key];
        },

        /**
         * Store shared data with specified key
         * @memberof DPO.bll.ActionChain#
         * @param {string} key
         * @param {*} data
         */
        setData: function getData(key, data) {
            sharedData[key] = data;
        },

        /**
         * Clears shared data
         * @memberof DPO.bll.ActionChain#
         */
        clearData: function clearData() {
            sharedData = {};
        },

        /**
         * Filters active actions
         * @memberof DPO.bll.ActionChain#
         * @param {object} actions
         * @returns {object}
         */
        getActiveAction: function getActiveAction(actions) {
            var result = {},
                keys = Object.keys(actions);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i],
                    params = actions[key];
                if (!params.disabled) {
                    result[key] = params;
                }
            }

            return result;
        },

        /**
         * Performs action with specified parameters
         * @memberof DPO.bll.ActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} [params]
         * @param {string} [source]
         * @returns {boolean}
         */
        performAction: function performAction(fields, action, params, source) {
            var performed = false,
                visited = [];

            for (var c = this; !performed && c && visited.indexOf(c) === -1; c = c.nextChain) {
                visited.push(c);
                performed = c.execute(fields, action, params, source);
            }
            return performed;
        },

        /**
         * Performs action with specified parameters
         * @memberof DPO.bll.ActionChain#
         * @protected
         * @abstract
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} [params]
         * @param {string} [source]
         * @returns {boolean}
         */
        execute: function execute(fields, action, params, source) {
            return false;
        }
    });

    return ActionChain;
});
DPO.def('bll.ProjectActionChain', function () {
    /**
     * Creates project action chain
     * @class DPO.bll.ProjectActionChain
     * @memberof DPO.bll
     * @extends DPO.bll.ActionChain
     * @param {DPO.render.Context} ctx
     * @property {DPO.render.Context} ctx
     * @constructor
     */
    function ProjectActionChain(ctx) {
        var me = this;
        me.$super.constructor.call(me);
        me.ctx = ctx;
    }

    DPO.inherit(ProjectActionChain, DPO.bll.ActionChain);
    DPO.mixin(ProjectActionChain.prototype, {
        /**
         * Collects actions
         * @memberof DPO.bll.ActionChain#
         * @protected
         * @param {object} actions
         * @param {DPO.model.Field[]} fields
         */
        collectActions: function collectActions(actions, fields) {
            var me = this,
                pt = this.ctx.projectTransformer,
                clipboard = me.getData('clipboard') || [],
                disabled = fields.length === 0,
                lessThenTwo = fields.length < 2,
                bg = null;
            for (var i = 0; !bg && i < fields.length; i++) {
                if (fields[i] instanceof DPO.model.Background) {
                    bg = fields[i];
                }
            }

            DPO.mixin(actions, {
                actionCopy: {disabled: disabled},
                actionCut: {disabled: disabled},
                actionDelete: {disabled: disabled},
                actionPaste: {disabled: !clipboard.length},
                actionRedo: {disabled: !pt.canRedo()},
                actionUndo: {disabled: !pt.canUndo()},
                alignObjectsLeft: {disabled: lessThenTwo || !!bg},
                alignObjectsRight: {disabled: lessThenTwo || !!bg},
                alignObjectsToBottom: {disabled: lessThenTwo || !!bg},
                alignObjectsToCenter: {disabled: lessThenTwo || !!bg},
                alignObjectsToMiddle: {disabled: lessThenTwo || !!bg},
                alignObjectsToTop: {disabled: lessThenTwo || !!bg},
                alignObjectToCenter: {disabled: disabled || !!bg},
                alignObjectToMiddle: {disabled: disabled || !!bg},
                alignObjectToMiddleAndCenter: {disabled: disabled || !!bg},
                fieldTranslate: {disabled: disabled || !!bg},
                fieldScale: {disabled: disabled || !lessThenTwo},
                fieldRotate: {disabled: disabled || !lessThenTwo}
            });
        },

        /**
         * Performs action with specified parameters
         * @memberof DPO.bll.ProjectActionChain#
         * @protected
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} [params]
         * @param {string} [source]
         * @returns {boolean}
         */
        execute: function execute(fields, action, params, source) {
            params = params || [];

            var me = this,
                ctx = me.ctx,
                pt = ctx.projectEditor;
            switch (action) {
                case 'actionCopy':
                    me.setData('clipboard', pt.clone(fields));
                    break;
                case 'actionCut':
                    me.setData('clipboard', pt.clone(fields));
                    pt.beginUpdates();
                    pt.deleteFields(fields);
                    pt.endUpdates();
                    break;
                case 'actionDelete':
                    pt.beginUpdates();
                    pt.deleteFields(fields);
                    pt.endUpdates();
                    break;
                case 'actionPaste':
                    pt.beginUpdates();
                    pt.pasteFields(me.getData('clipboard'), params.panel);
                    pt.endUpdates();
                    break;
                case 'actionRedo':
                    pt.redo();
                    break;
                case 'actionUndo':
                    pt.undo();
                    break;
                case 'fieldTranslate':
                    pt.beginUpdates();
                    pt.translateFields(fields, params.dx, params.dy);
                    pt.endUpdates();
                    break;
                case 'fieldScale':
                    pt.beginUpdates();
                    pt.scaleFields(fields, params.sx, params.sy, params.origin);
                    pt.endUpdates();
                    break;
                case 'fieldRotate':
                    pt.beginUpdates();
                    pt.rotateField(fields, params.deg, params.origin);
                    pt.endUpdates();
                    break;
                default:
                    return false;
            }

            return true;
        }
    });

    return ProjectActionChain;
});
DPO.def('bll.EditorActionChain', function () {
    /**
     * Creates editor action chain
     * @class DPO.bll.EditorActionChain
     * @memberof DPO.bll
     * @extends DPO.bll.ActionChain
     * @param {DPO.render.Context} ctx
     * @param {DPO.render.Editor} editor
     * @param {DPO.render.Preview} preview
     * @property {DPO.render.Context} ctx
     * @property {DPO.render.Editor} editor
     * @property {DPO.render.Preview} preview
     * @constructor
     */
    function EditorActionChain(ctx, editor, preview) {
        var me = this;
        me.$super.constructor.call(me);
        me.ctx = ctx;
        me.editor = editor;
        me.preview = preview;
    }

    DPO.inherit(EditorActionChain, DPO.bll.ActionChain);
    DPO.mixin(EditorActionChain.prototype, {
        /**
         * Collects actions
         * @memberof DPO.bll.ActionChain#
         * @protected
         * @param {object} actions
         * @param {DPO.model.Field[]} fields
         */
        collectActions: function collectActions(actions, fields) {
            var me = this,
                editor = me.editor,
                tt = editor.transformTool,
                panel = editor.panel,
                order = me.ctx.selector.getFieldOrder(panel),
                panelFields = order.getFields(),
                clipboard = me.getData('clipboard') || [],
                selector = me.ctx.selector,
                sheets = selector.selectSheets(),
                disabled = fields.length === 0,
                isSingleImage = fields.length === 1 && fields[0] instanceof DPO.model.Image,
                hasLockedBackground = me.ctx.project.masterPanels[0].backgrounds.length > 0 && me.ctx.project.masterPanels[0].backgrounds[0].editable === false,
                isSingleBackground = fields.length === 1 && fields[0] instanceof DPO.model.Background,
                lockRatio = false;
            if (isSingleBackground) {
                var field = fields[0];
                var rect = new DPO.math.Rect(
                    field.position.x,
                    field.position.y,
                    field.position.x + field.width,
                    field.position.y + field.height
                );
                lockRatio = !selector.insideBackgroundArea(editor.panel, rect);
            }

            var panelBg = null,
                bg = null,
                i;

            for (i = 0; !panelBg && i < panelFields.length; i++) {
                if (panelFields[i] instanceof DPO.model.Background) {
                    panelBg = panelFields[i];
                }
            }

            for (i = 0; !bg && i < fields.length; i++) {
                if (fields[i] instanceof DPO.model.Background) {
                    bg = fields[i];
                }
            }

            var bgColor = panelBg && panelBg.color;

            DPO.mixin(actions, {
                actionDelete: {disabled: disabled},
                actionPaste: {disabled: !clipboard.length},
                createDrawing: {},
                imageCrop: {disabled: !isSingleImage || !!bg},
                backgroundColor: {value: DPO.model.Color.fromHex(bgColor || '#FFFFFF', bgColor ? 1 : 0), disabled: hasLockedBackground},
                backgroundLockRatio: {disabled: hasLockedBackground || !isSingleBackground, value: lockRatio},
                canvasZoom: {value: editor.zoom * 100},
                canvasFlip: {value: editor.rotation !== 0},
                canvasGrid: {value: editor.gridVisible()},
                canvasItemNumber: {value: editor.itemNumberVisible()},
                canvasBoxOutlines: {value: tt && tt.displayOutlines},
                drawingFillColor: {disabled: true},
                drawingLineColor: {disabled: true},
                drawingOutlineWidth: {disabled: true},
                fieldSelect: {},
                fieldTranslate: {disabled: disabled || !!bg},
                fieldTransparency: {
                    disabled: disabled,
                    value: disabled ? 0 : selector.getMinTransparency(fields) * 100
                },
                sheetAdd: {},
                sheetRemove: {disabled: sheets.length < 2},
                sendObjectBackward: {disabled: disabled || !!bg},
                sendObjectForward: {disabled: disabled || !!bg},
                sendToBack: {disabled: disabled || !!bg},
                sendToFront: {disabled: disabled || !!bg},
                rotateAngle: {
                    disabled: disabled,
                    value: disabled || (!tt || tt.disabled ? 0 : tt.transformInfo.rotation)
                },
                rotateLeft: {disabled: disabled || !!bg},
                rotateRight: {disabled: disabled || !!bg},
                rotateSelectedFields: {disabled: disabled},
                textAlignBottom: {disabled: true},
                textAlignCenter: {disabled: true},
                textAlignLeft: {disabled: true},
                textAlignMiddle: {disabled: true},
                textAlignRight: {disabled: true},
                textAlignTop: {disabled: true},
                textAngle: {disabled: true},
                textBold: {disabled: true},
                textColor: {disabled: true},
                textFontName: {disabled: true},
                textFontSize: {disabled: true},
                textItalic: {disabled: true},
                textOverflow: {disabled: true},
                textRotateSense: {disabled: true},
                textUnderline: {disabled: true},
                toolPan: {value: tt && tt.panMode()},
                toolSelect: {value: tt && !tt.panMode()},
                toolSelectNextField: {},
                toolSnapToEdge: {value: tt && tt.snapToEdgeEnabled},
                transformToBackground: {disabled: !isSingleImage || hasLockedBackground},
                transformToImage: {disabled: !isSingleBackground}
            }, me.getTextActions(fields), me.getDrawingActions(fields));
        },

        getDrawingActions: function getDrawingActions(fields) {
            var isDrawingObject = fields.length > 0;
            for (var i = 0; isDrawingObject && i < fields.length; i++) {
                isDrawingObject = fields[i].constructor === DPO.model.Drawing;
            }

            if (!isDrawingObject) {
                return {};
            }

            var me = this,
                selector = me.ctx.selector;
            return {
                drawingFillColor: {
                    value: selector.getFillColor(fields)
                },
                drawingLineColor: {
                    value: selector.getOutlineColor(fields)
                },
                drawingOutlineWidth: {
                    value: selector.getMinOutlineWidth(fields) / 20
                }
            };
        },

        getTextBlockActions: function getTextBlockActions(fields) {
            var me = this,
                isTextBlockObject = fields.length > 0,
                editor = me.editor,
                tt = editor.transformTool;
            for (var i = 0; isTextBlockObject && i < fields.length; i++) {
                isTextBlockObject = fields[i].constructor === DPO.model.TextBlock;
            }

            if (!isTextBlockObject || !tt) {
                return {};
            }

            var tra = tt.collectRichTextAttributes();
            return {
                textAlignBottom: {value: tra.verticalTextAlignment.indexOf('bottom') === 0},
                textAlignCenter: {value: tra.textAlignment.indexOf('center') === 0},
                textAlignLeft: {value: tra.textAlignment.indexOf('left') === 0},
                textAlignMiddle: {value: tra.verticalTextAlignment.indexOf('middle') === 0},
                textAlignRight: {value: tra.textAlignment.indexOf('right') === 0},
                textAlignTop: {value: tra.verticalTextAlignment.indexOf('top') === 0},
                textOverflow: {value: fields[0].textStyle.overflow}
            };
        },

        getTextPathActions: function getTextPathActions(fields) {
            var isTextPathObject = fields.length > 0,
                selector = this.ctx.selector;
            for (var i = 0; isTextPathObject && i < fields.length; i++) {
                isTextPathObject = fields[i].constructor === DPO.model.TextPath;
            }

            if (!isTextPathObject) {
                return {};
            }

            return {
                textAngle: {value: selector.getTextAngle(/** @type DPO.model.TextPath[]*/fields)},
                textRotateSense: {value: fields[0].rotateSense}
            };
        },

        /**
         * Returns available text action map
         * @param {DPO.model.Field[]} fields
         * @returns {object}
         */
        getTextActions: function getTextActions(fields) {
            var me = this,
                editor = me.editor,
                tt = editor.transformTool,
                isTextBlockInstance = fields.length > 0,
                isTextPathInstance = false;
            for (var i = 0; isTextBlockInstance && i < fields.length; i++) {
                isTextBlockInstance = fields[i] instanceof DPO.model.TextBlock;
                isTextPathInstance = fields[i] instanceof DPO.model.TextPath;
            }

            if (!isTextBlockInstance || !tt) {
                var textDefaults = editor.masterPanel.textDefaults[0],
                    style = textDefaults.textStyle;
                return {
                    textBold: {value: false, disabled: true},
                    textColor: {value: style.textColor, disabled: true},
                    textFontName: {value: style.typeface, disabled: true},
                    textFontSize: {value: style.pointSize, disabled: true},
                    textItalic: {value: false, disabled: true},
                    textUnderline: {value: false, disabled: true}
                };
            }

            var tra = tt.collectRichTextAttributes(),
                styles = DPO.text.DefaultMetrics.getFontsStylesIntersection(tra.fonts);
            return DPO.mixin({
                textBold: {value: !!tra.bold, disabled: styles.indexOf('Bold') === -1},
                textColor: {value: tra.colors[0]},
                textFontName: {value: tra.fonts[0]},
                textFontSize: {value: tra.sizes[0]},
                textItalic: {value: !!tra.italic, disabled: styles.indexOf('Italic') === -1},
                textUnderline: {value: !!tra.underline, disabled: isTextPathInstance}
            }, me.getTextBlockActions(fields), me.getTextPathActions(fields));
        },

        /**
         * Performs action for text block fields
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} [params]
         * @returns {boolean}
         */
        performTextFieldAction: function performTextFieldAction(fields, action, params) {
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (!(f instanceof DPO.model.TextBlock)) {
                    return false;
                }
            }

            var selectionActions = ['textUnderline', 'textItalic', 'textFontSize', 'textFontName', 'textColor', 'textBold'];

            var me = this,
                editor = me.editor,
                tt = editor.transformTool;

            var cfg = tt.textEditCfg;
            if (cfg.textEditor && selectionActions.indexOf(action) !== -1) {
                cfg.textArea.focus();
            }

            switch (action) {
                case 'textAlignBottom':
                    tt.applyVerticalTextAlignment('bottom');
                    break;
                case 'textAlignCenter':
                    tt.applyTextAlignment('center');
                    break;
                case 'textAlignLeft':
                    tt.applyTextAlignment('left');
                    break;
                case 'textAlignMiddle':
                    tt.applyVerticalTextAlignment('middle');
                    break;
                case 'textAlignRight':
                    tt.applyTextAlignment('right');
                    break;
                case 'textAlignTop':
                    tt.applyVerticalTextAlignment('top');
                    break;
                case 'textAngle':
                    editor.setTextAngle(/** @type DPO.model.TextPath[] */ fields, params.value, true);
                    break;
                case 'textBold':
                    tt.applyStyle({
                        fontWeight: params.value ? 'bold' : 'normal'
                    });
                    break;
                case 'textColor':
                    tt.applyStyle({
                        color: params.value
                    });
                    break;
                case 'textFontName':
                    var dm = DPO.text.DefaultMetrics,
                        styleSet = dm.getFontsStylesIntersection([params.value]),
                        style = dm.getRequiredStyles(styleSet);
                    style.fontFamily = params.value;
                    tt.applyStyle(style);
                    break;
                case 'textFontSize':
                    tt.applyStyle({
                        fontSize: params.value
                    });
                    break;
                case 'textItalic':
                    tt.applyStyle({
                        fontStyle: params.value ? 'italic' : 'normal'
                    });
                    break;
                case 'textOverflow':
                    tt.applyTextOverflow(params.value);
                    break;
                case 'textRotateSense':
                    tt.applyRotateSense(params.value);
                    break;
                case 'textUnderline':
                    tt.applyStyle({
                        textDecoration: params.value ? 'underline' : 'none'
                    });
                    break;
                default:
                    return false;
            }

            return true;
        },

        /**
         * Performs action for text block fields
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} [params]
         * @returns {boolean}
         */
        performDrawingFieldAction: function performDrawingFieldAction(fields, action, params) {
            var me = this,
                editor = me.editor;
            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (!(f instanceof DPO.model.Drawing)) {
                    return false;
                }
            }
            switch (action) {
                case 'drawingFillColor':
                    editor.setFillColor(fields, params.value);
                    break;
                case 'drawingLineColor':
                    editor.setOutlineColor(fields, params.value);
                    break;
                case 'drawingOutlineWidth':
                    var width = params.value * 20;
                    editor.changeDrawingOutlineWidth(width, true);
                    break;
                default:
                    return false;
            }
            return true;
        },

        /**
         * Performs arrange action
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @returns {boolean}
         */
        performArrangeFieldAction: function performArrangeFieldAction(fields, action) {
            var me = this,
                editor = me.editor;
            switch (action) {
                case 'sendObjectBackward':
                    editor.sendBackward(fields);
                    break;
                case 'sendObjectForward':
                    editor.bringForward(fields);
                    break;
                case 'sendToBack':
                    editor.sendToBack(fields);
                    break;
                case 'sendToFront':
                    editor.bringToFront(fields);
                    break;
                default:
                    return false;
            }
            return true;
        },

        /**
         * Performs align action
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @returns {boolean}
         */
        performAlignFieldAction: function performAlignFieldAction(fields, action) {
            var me = this,
                editor = me.editor;
            switch (action) {
                case 'alignObjectsLeft':
                    editor.alignFields(fields, 'left', true);
                    break;
                case 'alignObjectsRight':
                    editor.alignFields(fields, 'right', true);
                    break;
                case 'alignObjectsToBottom':
                    editor.alignFields(fields, 'bottom', true);
                    break;
                case 'alignObjectsToCenter':
                    editor.alignFields(fields, 'center', true);
                    break;
                case 'alignObjectsToMiddle':
                    editor.alignFields(fields, 'middle', true);
                    break;
                case 'alignObjectsToTop':
                    editor.alignFields(fields, 'top', true);
                    break;
                case 'alignObjectToCenter':
                    editor.centerFields(fields, false, true, true);
                    break;
                case 'alignObjectToMiddle':
                    editor.centerFields(fields, true, false, true);
                    break;
                case 'alignObjectToMiddleAndCenter':
                    editor.centerFields(fields, true, true, true);
                    break;
                default:
                    return false;
            }

            return true;
        },

        /**
         * Performs canvas action
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} params
         * @returns {boolean}
         */
        performCanvasActions: function performCanvasActions(fields, action, params) {
            var me = this,
                editor = me.editor,
                preview = me.preview,
                tt = editor.transformTool;
            switch (action) {
                case 'canvasFlip':
                    editor.rotate(90 - this.editor.rotation, true);
                    break;
                case 'canvasGrid':
                    editor.gridVisible(!!params.value);
                    break;
                case 'canvasItemNumber':
                    editor.itemNumberVisible(!!params.value);
                    preview.itemNumberVisible(!!params.value);
                    break;
                case 'canvasBoxOutlines':
                    tt.displayOutlines = !tt.displayOutlines;
                    tt.updateFieldsBounds();
                    break;
                case 'canvasZoom':
                    editor.zoom = params.value / 100;
                    break;
                default:
                    return false;
            }

            return true;
        },

        /**
         * Performs rotation action
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} params
         * @returns {boolean}
         */
        performFieldTransformationAction: function performFieldTransformationAction(fields, action, params) {
            var editor = this.editor,
                pt = this.ctx.projectEditor,
                tt = editor.transformTool;
            switch (action) {
                case 'fieldTranslate':
                    tt.selectFields(fields);
                    tt.translate(params.dx, params.dy);
                    break;
                case 'fieldTransparency':
                    pt.beginUpdates();
                    pt.setOpacity(fields, 1 - params.value / 100);
                    pt.endUpdates();
                    editor.updateFields(fields, 'dpoUpdateStyle');
                    break;
                case 'rotateAngle':
                    tt.rotate(params.value - tt.transformInfo.rotation);
                    break;
                case 'rotateLeft':
                    pt.beginUpdates();
                    pt.rotateField(fields, 90);
                    pt.endUpdates();
                    break;
                case 'rotateRight':
                    pt.beginUpdates();
                    pt.rotateField(fields, -90);
                    pt.endUpdates();
                    break;
                case 'rotateSelectedFields':
                    tt.rotate(params.deg);
                    break;
                default:
                    return false;
            }

            return true;
        },

        /**
         * Performs background action
         * @memberof DPO.bll.EditorActionChain#
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} params
         * @returns {boolean}
         */
        performBackgroundAction: function performBackgroundAction(fields, action, params) {
            var editor = this.editor;
            switch (action) {
                case 'backgroundColor':
                    var color = params.value;
                    editor.setBackgroundColor(color);
                    break;
                case 'backgroundLockRatio':
                    if (params.value) {
                        editor.restoreBackgroundAspect(fields[0], true);
                    } else {
                        editor.placeBackground(fields[0], true);
                    }
                    break;
                case 'transformToImage':
                    var field = fields[0];
                    editor.transformBackgroundToImage(/** @type DPO.model.Background */field);
                    break;
                default:
                    return false;
            }

            return true;
        },

        /**
         * Performs action with specified parameters
         * @memberof DPO.bll.EditorActionChain#
         * @protected
         * @param {DPO.model.Field[]} fields
         * @param {string} action
         * @param {object} [params]
         * @param {string} [source]
         * @returns {boolean}
         */
        execute: function execute(fields, action, params, source) {
            var me = this,
                editor = me.editor,
                selector = me.ctx.selector,
                tt = editor.transformTool,
                pt = me.ctx.projectEditor,
                performed = false, sheets, sheet;
            switch (action) {
                case 'createDrawing':
                    editor.createDrawing(params.path, params.cx, params.cy);
                    break;
                case 'actionDelete':
                    tt.editTextBlock(null, true);
                    tt.cropImage(null);
                    pt.beginUpdates();
                    pt.deleteFields(fields);
                    pt.endUpdates();
                    break;
                case 'actionPaste':
                    editor.pasteFields(me.getData('clipboard'));
                    break;
                case 'fieldSelect':
                    tt.selectFields(fields);
                    break;
                case 'imageCrop':
                    tt.cropImage(/** @type DPO.model.Image*/ fields[0]);
                    break;
                case 'sheetAdd':
                    pt.beginUpdates();
                    pt.addSheets();
                    pt.endUpdates();
                    break;
                case 'sheetRemove':
                    sheets = selector.selectSheets();
                    sheet = params.index === undefined ? selector.getSheet(me.editor.page) : sheets[params.index];
                    pt.beginUpdates();
                    pt.removeSheet(sheet.front);
                    pt.endUpdates();
                    break;
                case 'toolPan':
                    tt.panMode(params.value);
                    break;
                case 'toolSelect':
                    tt.panMode(!params.value);
                    break;
                case 'toolSelectNextField':
                    tt.selectNextField();
                    break;
                case 'toolSnapToEdge':
                    tt.snapToEdgeEnabled = !!params.value;
                    break;
                case 'transformToBackground':
                    editor.transformImageToBackground(/** @type DPO.model.Image */fields[0], params.keepAspect);
                    break;
                default:
                    performed = performed || me.performFieldTransformationAction(fields, action, params);
                    performed = performed || me.performCanvasActions(fields, action, params);
                    performed = performed || me.performTextFieldAction(fields, action, params);
                    performed = performed || me.performDrawingFieldAction(fields, action, params);
                    performed = performed || me.performArrangeFieldAction(fields, action);
                    performed = performed || me.performAlignFieldAction(fields, action);
                    performed = performed || me.performBackgroundAction(fields, action, params);
                    return performed;
            }

            return true;
        }
    });

    return EditorActionChain;
});

DPO.def('bll.SuppressActionChain', function () {
    /**
     * Creates suppress action chain
     * @class DPO.bll.SuppressActionChain
     * @memberof DPO.bll
     * @extends DPO.bll.ActionChain
     * @property {string[]} editableAction
     * @property {string[]} movableActions
     * @property {string[]} styleableActions
     * @param {DPO.fc.Configuration} [fc]
     * @constructor
     */
    function SuppressActionChain(fc) {
        var me = this;
        me.disabledActions = {};
        me._fc = fc;
        me.updateDisabledActions();
        me.$super.constructor.call(me);
    }

    DPO.inherit(SuppressActionChain, DPO.bll.ActionChain);
    DPO.mixin(SuppressActionChain.prototype, {
        editableAction: [
            'actionDelete',
            'actionCut',
            'actionCopy'
        ],

        movableActions: [
            'sendObjectBackward',
            'sendObjectForward',
            'sendToBack',
            'sendToFront',
            'alignObjectToMiddle',
            'alignObjectToCenter',
            'alignObjectToMiddleAndCenter',
            'rotateLeft',
            'rotateRight',
            'rotateAngle',
            'fieldTranslate',
            'rotateSelectedFields'
        ],

        styleableActions: [
            'drawingFillColor',
            'drawingLineColor',
            'drawingOutlineWidth',
            'textFontName',
            'textFontSize',
            'textColor',
            'textBold',
            'textUnderline',
            'textItalic',
            'textOverflow',
            'textAngle',
            'textRotateSense',
            'textAlignTop',
            'textAlignMiddle',
            'textAlignBottom',
            'textAlignLeft',
            'textAlignRight',
            'textAlignCenter'
        ],
        /**
         * Collects actions
         * @memberof DPO.bll.SuppressActionChain#
         * @protected
         * @param {object} actions
         * @param {DPO.model.Field[]} fields
         */
        collectActions: function collectActions(actions, fields) {
            var me = this,
                editable = true,
                styleable = true,
                movable = true,
                suppressed = Object.keys(me.disabledActions),
                i;
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                editable = editable && field.editable;
                styleable = styleable && field.styleable;
                movable = movable && field.movable;
            }

            if (!editable) {
                suppressed = suppressed.concat(me.editableAction);
            }
            if (!styleable) {
                suppressed = suppressed.concat(me.styleableActions);
            }
            if (!movable) {
                suppressed = suppressed.concat(me.movableActions);
            }

            for (i = 0; i < suppressed.length; i++) {
                var name = suppressed[i],
                    params = actions[name] || {};
                params.disabled = true;
                actions[name] = params;
            }
        },

        /**
         * Updates disabled actions map
         * @private
         * @memberof DPO.bll.SuppressActionChain#
         */
        updateDisabledActions: function updateDisabledActions() {
            var me = this;
            if (!me.fc) {
                me.disabledActions = {};
                return;
            }

            var fcActions = me.fc.actions,
                disabledActions = {};
            for (var i = 0; fcActions && i < fcActions.items.length; i++) {
                var action = fcActions.items[i];
                if (action.disabled) {
                    disabledActions[action.id] = true;
                }
            }

            me.disabledActions = disabledActions;
        }
    });

    Object.defineProperty(SuppressActionChain.prototype, 'fc', {
        get: function get() {
            return this._fc;
        },

        set: function set(value) {
            this._fc = value;
            this.updateDisabledActions();
        }
    });

    return SuppressActionChain;
});

DPO.def('bll.SplitActionChain', function () {
    /**
     * Creates split action chain
     * @class DPO.bll.EditorActionChain
     * @memberof DPO.bll
     * @extends DPO.bll.ActionChain
     * @param {DPO.render.Context} ctx
     * @param {DPO.render.Editor} editor
     * @property {DPO.render.Context} ctx
     * @property {DPO.render.Editor} editor
     * @constructor
     * @constructor
     */
    function SplitActionChain(ctx, editor) {
        var me = this;
        me.$super.constructor.call(me);
        me.ctx = ctx;
        me.editor = editor;
    }

    DPO.inherit(SplitActionChain, DPO.bll.ActionChain);
    DPO.mixin(SplitActionChain.prototype, {
        collectActions: function collectActions(actions) {
            var textAngle = actions.textAngle || {disabled: true},
                textRotateSense = actions.textRotateSense || {disabled: true},
                rotateSelectedFields = actions.rotateSelectedFields || {disabled: true},
                fieldTranslate = actions.fieldTranslate || {disabled: true},
                canvasZoom = actions.canvasZoom || {disabled: true};
            DPO.mixin(actions, {
                canvasZoomIn: {disabled: canvasZoom.disabled},
                canvasZoomOut: {disabled: canvasZoom.disabled},
                rotateLeftByStep: {disabled: rotateSelectedFields.disabled},
                rotateRightByStep: {disabled: rotateSelectedFields.disabled},
                textAngleRight: {disabled: textAngle.disabled, value: textAngle.value === 0},
                textAngleLeft: {disabled: textAngle.disabled, value: textAngle.value === 180},
                textAngleTop: {disabled: textAngle.disabled, value: textAngle.value === 270},
                textAngleBottom: {disabled: textAngle.disabled, value: textAngle.value === 90},
                textRotateSenseCW: {disabled: textRotateSense.disabled, value: textRotateSense.value === 'cw'},
                textRotateSenseCCW: {disabled: textRotateSense.disabled, value: textRotateSense.value === 'ccw'},
                translateDown: {disabled: fieldTranslate.disabled},
                translateDownSmall: {disabled: fieldTranslate.disabled},
                translateLeft: {disabled: fieldTranslate.disabled},
                translateLeftSmall: {disabled: fieldTranslate.disabled},
                translateRight: {disabled: fieldTranslate.disabled},
                translateRightSmall: {disabled: fieldTranslate.disabled},
                translateUp: {disabled: fieldTranslate.disabled},
                translateUpSmall: {disabled: fieldTranslate.disabled}
            });
        },

        execute: function execute(fields, action) {
            var me = this,
                next = me.nextChain;
            switch (action) {
                case 'canvasZoomIn':
                case 'canvasZoomOut':
                    var zoom = me.editor.zoom * 100 + (action === 'canvasZoomOut' ? 5 : -5);
                    return next.performAction(fields, 'canvasZoom', {value: zoom});
                case 'rotateLeftByStep':
                case 'rotateRightByStep':
                    return next.performAction(fields, 'rotateSelectedFields', {
                        deg: action.indexOf('Left') === -1 ? -5 : 5
                    });
                case 'textAngleRight':
                    return next.performAction(fields, 'textAngle', {value: 0});
                case 'textAngleLeft':
                    return next.performAction(fields, 'textAngle', {value: 180});
                case 'textAngleTop':
                    return next.performAction(fields, 'textAngle', {value: 270});
                case 'textAngleBottom':
                    return next.performAction(fields, 'textAngle', {value: 90});
                case 'textRotateSenseCW':
                    return next.performAction(fields, 'textRotateSense', {value: 'cw'});
                case 'textRotateSenseCCW':
                    return next.performAction(fields, 'textRotateSense', {value: 'ccw'});
                case 'translateLeft':
                case 'translateRight':
                case 'translateUp':
                case 'translateDown':
                case 'translateLeftSmall':
                case 'translateRightSmall':
                case 'translateUpSmall':
                case 'translateDownSmall':
                    var dx = 0, dy = 0;
                    if (action.indexOf('Right') !== -1) {
                        dx = 100;
                    }
                    if (action.indexOf('Left') !== -1) {
                        dx = -100;
                    }
                    if (action.indexOf('Up') !== -1) {
                        dy = -100;
                    }
                    if (action.indexOf('Down') !== -1) {
                        dy = 100;
                    }
                    if (action.indexOf('Small') !== -1) {
                        dx /= 10;
                        dy /= 10;
                    }

                    return next.performAction(fields, 'fieldTranslate', {
                        dx: dx,
                        dy: dy
                    });
                default:
                    return false;
            }
        }
    });

    return SplitActionChain;
});
DPO.def('bll.Context', function() {
    /**
     * Creates new context for render components
     * @class DPO.bll.Context
     * @extends DPO.render.Context
     * @memberof DPO.bll
     * @param {DPO.mode.Project} project
     * @param {object} storage
     * @param {DPO.project.DataSourceProvider} provider
     * @param {DPO.text.LayoutManager} layoutManager
     * @param {DPO.dto.ProjectData} projectData
     * @param {DPO.dal.DAL} endpoint
     * @param {DPO.render.DeviceColorSpace} [colorSpace]
     * @param {DPO.fc.Configuration} [flowConfig]
     * @property {object} state
     * @property {DPO.model.Project} project
     * @property {DPO.dto.ProjectData} projectData
     * @property {DPO.text.LayoutManager} layoutManager
     * @property {object} storage
     * @property {DPO.project.DataSourceProvider} provider
     * @property {DPO.project.Transformer} projectTransformer
     * @property {DPO.model.Selector} selector
     * @property {DPO.project.Binder} binder
     * @property {DPO.fc.Configuration} flowConfig
     * @property {Array} autoSaveImages
     * @constructor
     */
    function Context(project, layoutManager, storage, provider, projectData, endpoint, colorSpace, flowConfig) {
        var me = this;
        me.state = {};
        me._projectData = projectData;
        me._endpoint = endpoint;
        me._flowConfig = flowConfig;
        me._autoSaveImages = [];
        DPO.render.Context.apply(me, [project, layoutManager, storage, provider, colorSpace]);
    }

    DPO.inherit(Context, DPO.render.Context);
    DPO.mixin(Context.prototype, {
        /**
         * Invokes after project changing
         * @protected
         * @memberof DPO.bll.Context#
         */
        afterProjectChanged: function afterProjectChanged() {
            var me = this,
                fc = me.flowConfig;
            if (!fc || !me.project) {
                return;
            }

            me.validator.panelSafelineRenderLimit = fc.productGeometryCharacteristic.panelSafelineRenderLimit;
        },

        /**
         * Returns project type if project data is available; otherwise null
         * @memberof DPO.bll.Context#
         * @returns {?string}
         */
        getProjectType: function getProjectType() {
            var me = this;
            if (!me.projectData) {
                return null;
            }

            var productType = me.projectData.product.productType;
            productType = productType && productType.split('_')[0] || '';
            switch (productType) {
                case 'Card':
                    return 'card';
                case 'DividerInsert':
                    return 'divider';
                default:
                    return 'sheet';
            }
        },

        /**
         * Check if current product is for DIFY
         * @returns {boolean}
         */
        isDifyProduct: function isDifyProduct() {
            if (!this.projectData) {
                return false;
            }

            var product = this.projectData.product;
            return product.productProfile !== 'DEFAULT';
        },

        /**
         * Check if current product is Roll Label
         * @returns {boolean}
         */
        isRollLabelProduct: function isRollLabelProduct() {
            if (!this.projectData) {
                return;
            }

            return this.projectData.product.productProfile === 'Avery Roll Labels Service';
        },

        /**
         * Return amount of print unit per page
         * @memberof DPO.bll.Context#
         * @returns {number}
         */
        getPrintUnitPerPage: function getPrintUnitPerPage() {
            var me = this,
                i;
            if (!me.project) {
                return -1;
            }

            var page = me.project.pages[0],
                map = {};
            for (i = 0; i < page.panels.length; i++) {
                var panel = page.panels[i],
                    mp = me.selector.selectMasterPanel(panel);
                map[mp.id] = map[mp.id] || 0;
                map[mp.id]++;
            }

            var count = 0,
                keys = Object.keys(map);
            for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                count = Math.max(count, map[key]);
            }

            return count;
        },

        /**
         * Returns warnings for specified project
         * @memberof DPO.bll.Context#
         * @returns {DPO.dto.Error[]}
         */
        getProjectWarnings: function getProjectWarnings() {
            var warnings = [],
                project = this.project,
                validator = this.validator,
                selector = this.selector;

            function pushError(type, code) {
                var exists = false;
                for (var i = 0; !exists && i < warnings.length; i++) {
                    var w = warnings[i];
                    exists = w.code === code;
                }

                if (!exists) {
                    warnings.push({
                        errorType: type,
                        errorCode: code,
                        errorMessage: ''
                    });
                }
            }

            function checkEmptyPanels() {
                for (var i = 0; i < project.pages.length; i++) {
                    var page = project.pages[i];
                    for (var j = 0; j < page.panels.length; j++) {
                        var panel = page.panels[j],
                            fields = selector.selectPanelFields(panel);
                        if (fields.length === 0) {
                            pushError(DPO.dto.ErrorType.CAUTION, DPO.dto.ErrorCode.DEFAULT_TEXT_PRESENT);
                            return;
                        }
                    }
                }
            }

            function checkValidationError() {
                var errors = validator.validateProject();
                for (var i = 0; i < errors.length; i++) {
                    var error = errors[i];
                    switch (error.messageCode) {
                        case 'shape-outside-safe-area':
                            pushError(DPO.dto.ErrorType.CAUTION, DPO.dto.ErrorCode.INVALID_DRAWING);
                            break;
                        case 'image-outside-safe-area':
                            pushError(DPO.dto.ErrorType.WARNING, DPO.dto.ErrorCode.INVALID_IMAGE);
                            break;
                        case 'text-outside-safe-area':
                        case 'text-intersect-cutout':
                            pushError(DPO.dto.ErrorType.WARNING, DPO.dto.ErrorCode.INVALID_TEXT);
                            break;
                        case 'barcode-outside-safe-area':
                        case 'barcode-intersect-cutout':
                            pushError(DPO.dto.ErrorType.WARNING, DPO.dto.ErrorCode.INVALID_BARCODE);
                            break;
                        case 'text-size':
                            pushError(DPO.dto.ErrorType.CAUTION, DPO.dto.ErrorCode.SMALL_FONT_SIZE);
                            break;
                        case 'caution-extra-spaces':
                            pushError(DPO.dto.ErrorType.CAUTION, DPO.dto.ErrorCode.CONSECUTIVE_SPACES);
                            break;
                        case 'text-color-white':
                            pushError(DPO.dto.ErrorType.NOTE, DPO.dto.ErrorCode.WHITE_COLOR_USED);
                            break;
                    }
                }
            }

            checkEmptyPanels();
            checkValidationError();
            return warnings;
        },

        /**
         * Creates new context for specified project
         * @memberof DPO.bll.Context#
         * @param {DPO.mode.Project} project
         * @param {DPO.dto.ProjectData} projectData
         * @param {?DPO.project.DataSourceProvider} [provider]
         * @param {DPO.render.DeviceColorSpace} [colorSpace]
         * @param {DPO.fc.Configuration} [flowConfig]
         * @returns {DPO.bll.Context}
         */
        createNew: function create(project, projectData, provider, colorSpace, flowConfig) {
            var me = this,
                storage = new DPO.bll.HttpProjectStorage(me.endpoint, projectData);
            provider = provider || me.provider;
            storage.imageType = projectData.product.productProfile === 'DEFAULT' ? 'low' : 'cmyk';
            colorSpace = colorSpace === undefined ? me.colorSpace : colorSpace;
            return new Context(project, me.layoutManager, storage, provider, projectData, me.endpoint, colorSpace, flowConfig || me.flowConfig);
        }
    });

    Object.defineProperty(Context.prototype, 'projectData', {
        get: function get() {
            return this._projectData;
        }
    });

    Object.defineProperty(Context.prototype, 'endpoint', {
        get: function get() {
            return this._endpoint;
        }
    });

    Object.defineProperty(Context.prototype, 'flowConfig', {
        get: function get() {
            return this._flowConfig;
        },

        set: function set(fc) {
            var me = this;
            if (me._flowConfig === fc) {
                return;
            }

            me._flowConfig = fc;
            me.afterProjectChanged();
        }
    });

    Object.defineProperty(Context.prototype, 'autoSaveImages', {
        get: function get() {
            return this._autoSaveImages;
        },

        set: function set(images) {
            var imagesArr = images instanceof Array ? images : [images];
            this._autoSaveImages = imagesArr;
        }
    });

    return Context;
});
DPO.def('bll.BaseFlow', function () {
    /**
     * Creates new Select Product Flow
     * @class DPO.bll.BaseFlow
     * @extends DPO.mixins.Observable
     * @property {DPO.dal.DAL} endpoint
     * @param {DPO.dal.DAL} endpoint
     * @fires loading:started
     * @fires loading:finished
     * @fires error:occurred
     * @constructor
     */
    function BaseFlow(endpoint) {
        var me = this;
        me.endpoint = endpoint;
        me.requestCount = 0;
        me.resetObservable();
    }

    DPO.mixin(BaseFlow.prototype, DPO.mixins.Observable);
    DPO.mixin(BaseFlow.prototype, {
        /**
         * Increment request counter
         * @memberof DPO.bll.BaseFlow#
         */
        incRequestCount: function incRequestCount() {
            var me = this;
            me.requestCount++;
            if (me.requestCount === 1) {
                me.fire('loading:started', [me]);

                me.progress = DPO.progressCalculator(function() {
                    me.fire('loading:progress', arguments);
                });
            }
        },

        /**
         * Decrement request counter
         * @memberof DPO.bll.BaseFlow#
         */
        decRequestCount: function decRequestCount() {
            var me = this;
            me.requestCount--;
            if (me.requestCount === 0) {
                if(me.progress) {
                    me.progress.done(function() {
                        me.fire('loading:finished', [me]);
                    });
                } else {
                    me.fire('loading:finished', [me]);
                }
            }
        },

        /**
         * Handle Data Access Errors
         * @memberof DPO.bll.BaseFlow#
         * @param {*} error
         */
        onFails: function onFails(error) {
            var me = this;
            me.fire('error:occurred', [me, error]);
            me.decRequestCount();
        }
    });

    return BaseFlow;
});

DPO.def('bll.RollLabelsCalculator', function () {
    /**
     * Creates new RollLabelsCalculator <br/>
     * @class DPO.bll.RollLabelsCalculator
     * @extends DPO.dal.Endpoint
     * @memberof DPO.bll
     * @param {string} url RollLabels API URL
     * @property {string} url RollLabels API URL
     * @property {object[]} shapes
     * @property {object[]} sizes
     * @property {object[]} materials
     * @property {object} attributes
     * @constructor
     */
    function RollLabelsCalculator(url) {
        DPO.dal.Endpoint.apply(this, arguments);
        this.requestCount = 0;
    }

    RollLabelsCalculator.UnwindType = {
        OutsideWound: {
            TopEdge: 1,
            BottomEdge: 2,
            LeftEdge: 3,
            RightEdge: 4
        },
        InsideWound: {
            TopEdge: 5,
            BottomEdge: 6,
            LeftEdge: 7,
            RightEdge: 8
        }
    };

    RollLabelsCalculator.ArtworkSource = {
        Upload: 'upload',
        DPO: 'dpo',
        reuse: 'reuse'
    };

    RollLabelsCalculator.ProofType = {
        Hard: 'hard',
        Soft: 'soft',
        None: 'none'
    };

    RollLabelsCalculator.ApplyType = {
        ByHand: 1,
        WithMachine: 0
    };

    DPO.inherit(RollLabelsCalculator, DPO.dal.Endpoint);
    DPO.mixin(RollLabelsCalculator.prototype, {
        /**
         * Builds full REST URL.
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {string} resource
         * @param {object} [query]
         * @returns {string}
         */
        buildUrl: function buildUrl(resource, query) {
            return this.url + resource + this.params(query);
        },

        /**
         * Fetches roll labels shapes
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchShapes: function fetchDieSizes(success, fail, scope) {
            return this.fetch(this.buildUrl('shapes'), success, fail, scope);
        },

        /**
         * Fetches roll labels sizes
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchDieSizes: function fetchDieSizes(params, success, fail, scope) {
            return this.fetch(this.buildUrl('die/sizes', params), success, fail, scope);
        },

        /**
         * Fetches roll labels attributes
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchRollAttributes: function fetchRollAttributes(success, fail, scope) {
            return this.fetch(this.buildUrl('catalog/attributes'), success, fail, scope);
        },

        /**
         * Fetches core product attributes
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {string} coreProduct
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchProductAttributes: function fetchRollAttributes(coreProduct, success, fail, scope) {
            return this.fetch(this.buildUrl('catalog/product/' + coreProduct), success, fail, scope);
        },

        /**
         * Fetches roll labels materials
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchMaterials: function fetchMaterials(success, fail, scope) {
            var me = this,
                url = me.buildUrl('catalog/attribute/materials', {
                    show_on_frontend: 1 // jshint ignore:line
                });

            return me.fetch(url, success, fail, scope);
        },

        /**
         * Fetches roll labels products
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object} params
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchRollProducts: function fetchRollProducts(params, success, fail, scope) {
            return this.fetch(this.buildUrl('catalog/products', params), success, fail, scope);
        },

        /**
         * Fetches roll labels quote
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object} payload
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         * @returns {{method: string, url: string, xhr: XMLHttpRequest, scope: *}}
         */
        fetchQuote: function fetchQuote(payload, success, fail, scope) {
            var me = this,
                url = this.buildUrl('calculator/quote'),
                xhr = new XMLHttpRequest();
            xhr.addEventListener('error', me.errorHandler(fail, scope));
            xhr.addEventListener('load', me.requestHandler(success, fail, scope));
            xhr.open('POST', url, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.send(JSON.stringify(payload));
            return {
                method: 'POST',
                url: url,
                xhr: xhr,
                scope: scope
            };
        },

        /**
         * Increment request counter
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {number} count
         */
        incRequestCount: function incRequestCount(count) {
            var me = this;
            if (me.requestCount === 0) {
                me.fire('loading:started', [me]);
            }

            me.requestCount += count || 1;
        },

        /**
         * Decrement request counter
         * @memberof DPO.bll.RollLabelsCalculator#
         */
        decRequestCount: function decRequestCount() {
            var me = this;
            me.requestCount--;
            if (me.requestCount === 0) {
                me.fire('loading:finished', [me]);
            }
        },

        /**
         * @private
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object} error
         */
        onError: function onError(error) {
            var me = this;
            me.fire('error:occurred', [me, error]);
            me.decRequestCount();
        },

        /**
         * @private
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object[]} response
         */
        onSizesFetched: function onSizesFetched(response) {
            var me = this;
            me.sizes = response;
            me.fire('fetched:sizes', [me, response]);
            me.decRequestCount();
        },

        /**
         * @private
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object} response
         */
        onAttributesFetched: function onAttributesFetched(response) {
            var me = this;
            me.attributes = response;
            me.fire('fetched:attributes', [me, response]);
            me.decRequestCount();
        },

        /**
         * @private
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object[]} response
         */
        onMaterialsFetched: function onMaterialsFetched(response) {
            var me = this;
            me.materials = response;
            me.fire('fetched:materials', [me, response]);
            me.decRequestCount();
        },

        /**
         * @private
         * @memberof DPO.bll.RollLabelsCalculator#
         * @param {object[]} response
         */
        onShapesFetched: function onShapesFetched(response) {
            var me = this,
                shapes;
            shapes = response.filter(function(shape) { return !shape.is_custom; });
            me.shapes = shapes;
            me.fire('fetched:shapes', [me, shapes]);
            me.decRequestCount();
        },

        /**
         * Fetches roll labels data
         * @memberof DPO.bll.RollLabelsCalculator#
         */
        fetchData: function fetchData() {
            var me = this;
            me.incRequestCount(3);
            me.fetchShapes(me.onShapesFetched, me.onError, me);
            me.fetchDieSizes({}, me.onSizesFetched, me.onError, me);
            me.fetchMaterials(me.onMaterialsFetched, me.onError, me);
        }
    });

    return RollLabelsCalculator;
});

DPO.def('bll.ProjectFlow', function () {
    /**
     * Creates new Project Flow
     * @class DPO.bll.ProjectFlow
     * @extends DPO.bll.BaseFlow
     * @memberof DPO.bll
     * @param {DPO.dal.DAL} endpoint
     * @property (DPO.model.Project) project
     * @property (object) projectData
     * @property {string} productId
     * @property {string} predesignId
     * @property {object[]} autoSaveImages
     * @property {DPO.project.DataSourceProvider} provider
     * @property {DPO.bll.HttpProjectStorage} storage
     * @fires project:created
     * @fires project:loaded
     * @fires project:archived
     * @fires project:restored
     * @fires project:saved
     * @constructor
     */
    function ProjectFlow(endpoint) {
        var me = this;
        DPO.bll.BaseFlow.call(me, endpoint);
        me.autoSaveImages = [];
    }

    DPO.inherit(ProjectFlow, DPO.bll.BaseFlow);
    DPO.mixin(ProjectFlow, {
        /**
         * Check if project's product is WePrint
         * @param projectData
         * @returns {boolean}
         */
        isWePrintProduct: function isWePrintProduct(projectData) {
            if (!projectData || !projectData.product) {
                return false;
            }

            return projectData.product.productProfile !== 'DEFAULT';
        }
    });

    DPO.mixin(ProjectFlow.prototype, {
        /**
         * Creates new project based of specified product & predesign
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} productId
         * @param {string} predesignId
         * @param {object} [margeData]
         */
        createProject: function createProject(productId, predesignId, margeData) {
            var me = this,
                params = {
                    productId: productId,
                    predesignId: predesignId
                };
            me.incRequestCount();
            me.productId = productId;
            me.predesignId = predesignId;

            if (margeData) {
                DPO.mixin(params, margeData);
                me.endpoint.mergeDataToProject(params, me.onProjectInfoReceived, me.onFails, me);
            } else {
                me.endpoint.createProject(params, me.onProjectInfoReceived, me.onFails, me);
            }
        },

        /**
         * Replaces project predsign
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} productId
         * @param {string} predesignId
         * @param {string} storage
         * @param {string} path
         */
        replaceProjectPredesign: function replaceProjectPredesign(productId, predesignId, storage, path) {
            var me = this,
                params = {
                    productId: productId,
                    predesignId: predesignId,
                    relativePath: path,
                    storageId: storage
                };
            me.incRequestCount();
            me.productId = productId;
            me.predesignId = predesignId;
            me.endpoint.replacePredesign(params, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Creates new project based of specified product & gallery image
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} productId
         * @param {string} imageId
         */
        createProjectWithImg: function createProject(productId, imageId) {
            var me = this,
                params = {
                    productId: productId,
                    imageId: imageId
                };
            me.incRequestCount();
            me.productId = productId;

            me.endpoint.createProjectWithImg(params, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Creates new project based of specified product & design source
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} productId
         * @param {string} predesignId
         */
        createProjectWithDesignSource: function createProjectWithPredesign(productId, predesignId) {
            var me = this,
                params = {
                    productId: productId,
                    predesignId: predesignId
                };
            me.incRequestCount();
            me.productId = productId;
            me.predesignId = predesignId;
            me.endpoint.createProjectWithDesignSource(params, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Creates new project based on saved user project
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} productId
         * @param {string} projectId
         */
        applyProjectDesign: function applyProjectDesign(productId, projectId) {
            var me = this;
            me.incRequestCount();
            me.endpoint.applyPredesign(productId, {id: projectId}, null, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Loads project by it's identifier
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} id
         */
        loadProjectById: function loadProjectById(id) {
            var me = this;
            me.incRequestCount();
            me.endpoint.fetchProjectData(id, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Loads snapshot project by it's identifier
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} id
         */
        loadSnapshotById: function loadSnapshotById(id) {
            var me = this;
            me.incRequestCount();
            me.endpoint.cloneProject(id, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Loads project by storage & relative path
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} storage
         * @param {string} path
         */
        loadProjectByPath: function loadProjectByPath(storage, path) {
            var me = this;
            me.incRequestCount();
            me.endpoint.fetchProjectInfo({
                storageId: storage,
                relativePath: path
            }, me.onProjectInfoReceived, me.onFails, me);
        },

        /**
         * Loads project
         * @memberof DPO.bll.ProjectFlow#
         * @param {object} projectData
         */
        loadProject: function loadProject(projectData) {
            var me = this;
            me.projectData = projectData;
            me.endpoint.loadProject(me.projectData.uriXML, me.onProjectLoaded, me.onFails, me);
            me.incRequestCount();
        },

        /**
         * Prepares project data
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} [name]
         * @returns {object}
         */
        prepareProjectData: function prepareProjectData(name) {
            var me = this,
                serializer = new DPO.model.Serializer({normalizeDefaultsValues: false}),
                ds = me.provider.getDataSource(),
                xml = serializer.serializeToXML(me.project),
                mmd = ds.totalRecords() ? ds.getData().toObject() : null,
                data = DPO.mixin({}, me.projectData, {
                    content: xml,
                    mailMergeData: ds.totalRecords() ? mmd : null
                });
            if (name) {
                data.name = name;
            }

            return data;
        },

        /**
         * Saves project images
         * @memberof DPO.bll.ProjectFlow#
         */
        saveProjectImages: function saveProjectImages() {
            var me = this,
                images = [].concat(me.autoSaveImages),
                files = [],
                selector = new DPO.model.Selector(me.project),
                fields = selector.selectFields(function (f) {
                    return !!f.source;
                }),
                usedImages = {},
                i;
            for (i = 0; i < fields.length; i++) {
                usedImages[fields[i].source] = true;
            }

            for (i = 0; i < me.autoSaveImages.length; i++) {
                var d = me.autoSaveImages[i],
                    used = usedImages[d.name];
                if (used) {
                    files.push({
                        name: d.name,
                        originalName: d.originalName,
                        override: true
                    });
                }
            }

            function imagesCopied() {
                me.decRequestCount();
                me.fire('images:copied', [me, files]);
            }

            me.autoSaveImages = [];

            if (files.length) {
                me.incRequestCount();
                me.endpoint.copyImagesToUserContent(files, me.projectData, imagesCopied, me.onFails, me);
            }
        },

        /**
         * Applies DIFY product to current project
         * @memberof DPO.bll.ProjectFlow#
         */
        applyDifyProduct: function applyDifyProduct() {
            var me = this,
                data = me.prepareProjectData();
            me.incRequestCount();
            me.endpoint.applyDifyProduct(data, me.onDifyProjectCreated, me.onFails, me);
        },

        /**
         * Updates anonymous project on remote storage
         * @memberof DPO.bll.ProjectFlow#
         */
        updateProject: function updateProject() {
            var me = this,
                data = me.prepareProjectData();
            me.endpoint.updateProject(data, me.onProjectUpdated, me.onFails, me);
        },

        /**
         * Saves project to current account storage
         * @memberof DPO.bll.ProjectFlow#
         * @param {?string} [name]
         * @param {boolean} [saveMailMerge]
         * @param {boolean} [override]
         */
        saveProject: function saveProject(name, saveMailMerge, override) {
            var me = this,
                data = me.prepareProjectData(name),
                params = {
                    saveMailMerge: !!saveMailMerge,
                    override: !!override
                };
            me.incRequestCount();
            me.saveProjectImages();
            me.endpoint.saveProject(params, data, me.onProjectSaved, me.onFails, me);
        },

        /**
         * Creates archive for current project
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} [name]
         */
        archiveProject: function archiveProject(name) {
            var me = this,
                data = me.prepareProjectData(name);
            me.incRequestCount();
            me.endpoint.archiveProject(data, me.onProjectArchived, me.onFails, me);
        },

        /**
         * Delete project by identifier
         * @memberof DPO.bll.ProjectFlow#
         * @param {string} id
         * @param {function} success
         * @param {function} fail
         * @param {object} [scope]
         */
        deleteProject: function deleteProject(id, success, fail, scope) {
            this.endpoint.deleteProject(id, success, fail, scope);
        },

        /**
         * Restores project from specified file
         * @memberof DPO.bll.ProjectFlow#
         * @param {File} file
         */
        restoreProject: function restoreProject(file) {
            var me = this,
                formData = new FormData();

            //noinspection JSCheckFunctionSignatures
            formData.append('file', file, file.name);
            me.incRequestCount();
            me.endpoint.restoreProject(formData, me.onProjectRestored, me.onFails, me);
        },

        /**
         * Expands project
         * @memberof DPO.bll.ProjectFlow#
         * @param {DPO.project.Context} context
         * @param {function} callback
         * @param {*} scope
         * @returns {DPO.project.Expander}
         */
        expandProject: function expandProject(context, callback, scope) {
            var me = this,
                expander = new DPO.project.Expander(context);

            function projectExpanded(expander, project) {
                callback.call(scope, project);
                me.decRequestCount();
                expander.resetObservable();
            }

            me.incRequestCount();
            expander.on('project:expanded', projectExpanded, me);
            expander.expandProject();
            return expander;
        },

        /**
         * @protected
         * @memberof DPO.bll.ProjectFlow#
         * @param {object} response
         */
        onProjectInfoReceived: function onProjectInfoReceived(response) {
            var me = this;
            me.fire('project:created', [me, response.data]);
            me.decRequestCount();
        },

        /**
         * @protected
         * @memberof DPO.bll.ProjectFlow#
         * @param {DPO.model.Project} project
         */
        onProjectLoaded: function onProjectLoaded(project) {
            var me = this,
                provider = new DPO.mmd.DataSourceProvider();
            me.project = project;
            me.provider = provider;
            me.storage = new DPO.bll.HttpProjectStorage(me.endpoint, me.projectData);
            me.storage.imageType = me.projectData.product.productProfile === 'DEFAULT' ? 'low' : 'cmyk';

            if (me.projectData.mailMergeData) {
                var data = DPO.mmd.Data.fromObject(me.projectData.mailMergeData),
                    ds = new DPO.mmd.MergeMailDataSource(data);
                provider.setDataSource(ds);
            }

            me.fire('project:loaded', [me, me.project]);
            me.decRequestCount();
        },

        /**
         * @protected
         * @memberof DPO.bll.ProjectFlow#
         */
        onProjectUpdated: function onProjectUpdated() {
            this.fire('project:updated', [this]);
        },

        /**
         * @protected
         * @param {object} response
         * @memberof DPO.bll.ProjectFlow#
         */
        onDifyProjectCreated: function onDifyProjectCreated(response) {
            var me = this;
            me.transformDifyProject = true;
            me.projectData = response.data;
            me.fire('project:dify:created', [me, response.data]);
            me.decRequestCount();
        },

        /**
         * @protected
         * @param {object} response
         * @memberof DPO.bll.ProjectFlow#
         */
        onProjectSaved: function onProjectSaved(response) {
            var me = this;
            me.projectData = response.data;
            me.fire('project:saved', [me, response.data]);
            me.decRequestCount();
        },

        /**
         * @protected
         * @memberof DPO.bll.ProjectFlow#
         * @param {object} response
         */
        onProjectArchived: function onProjectArchived(response) {
            var me = this;
            me.fire('project:archived', [me, response.data]);
            me.decRequestCount();
        },

        /**
         * @protected
         * @memberof DPO.bll.ProjectFlow#
         * @param {object} response
         */
        onProjectRestored: function onProjectRestored(response) {
            var me = this;
            me.fire('project:restored', [me, response.data]);
            me.decRequestCount();
        },

        /**
         * Check if current project's product is WePrint
         * @returns {boolean}
         */
        isWePrintProduct: function isWePrintProduct() {
            return ProjectFlow.isWePrintProduct(this.projectData);
        }
    });

    return ProjectFlow;
});

DPO.def('bll.PreviewFlow', function () {
    /**
     * Creates new Preview Flow
     * @class DPO.bll.PreviewFlow
     * @extends DPO.bll.ProjectFlow
     * @memberof DPO.bll
     * @constructor
     */
    function PreviewFlow(endpoint) {
        var me = this;
        DPO.bll.ProjectFlow.call(me, endpoint);
    }

    DPO.inherit(PreviewFlow, DPO.bll.ProjectFlow);
    DPO.mixin(PreviewFlow.prototype, {});

    return PreviewFlow;
});

DPO.def('bll.SelectProductFlow', function () {
    /**
     * Creates new select product flow
     * @class DPO.bll.SelectProductFlow
     * @extends DPO.bll.BaseFlow
     * @memberof DPO.bll
     * @param {DPO.dal.DAL} endpoint
     * @property {?string} categoryId
     * @property {object} defaultCategory
     * @property {object[]} categories
     * @property {object[]} products
     * @property {string} search
     * @constructor
     */
    function SelectProductFlow(endpoint) {
        var me = this;
        DPO.bll.BaseFlow.call(me, endpoint);
        me.categoryId = null;
        me.categoryType = null;
        me.categories = null;
        me.products = [];
        me.currentProducts = [];
        me.allProducts = null;
        me.search = '';
        me.order = 'sku';
        me.productProfile = null;
        me.ascending = true;
        me.relevances = {};
    }

    var categoryTypes = {
        MULTIPLE: 'MULTY_GROUP',
        SINGLE: 'SINGLE_GROUP',
        ROLL_LABELS: 'ROLL_CALCULATOR'
    };

    var sorters = {
        /**
         * @param {{sku: string}} a
         * @param {{sku: string}} b
         * @returns {number}
         */
        'sku': function sku(a, b) {
            var sa = a.sku.toLowerCase() || '';
            var sb = b.sku.toLowerCase() || '';

            function alphanumSort(a, b) {
                var aNum = Number(a);
                var bNum = Number(b);
                if ((aNum || aNum === 0) && (bNum || bNum === 0)) {
                    return aNum - bNum;
                }
                if (aNum && !bNum) {
                    return -1;
                }
                if (!aNum && bNum) {
                    return 1;
                }
                if (!aNum && !bNum) {
                    return a >= b;
                }
                return 0;
            }

            return alphanumSort(sa, sb);
            // return /** @type number */ -1 * s.localeCompare(b.sku || '', 'standard', {
            //     numeric: true,
            //     usage: 'sort'
            // });
        },

        /**
         * @param {{description: string}} a
         * @param {{description: string}} b
         * @returns {number}
         */
        'description': function description(a, b) {
            var s = a.description || '';
            return /** @type number */ s.localeCompare(b.description || '');
        },

        /**
         * @param {{shortDescription: string}} a
         * @param {{shortDescription: string}} b
         * @returns {number}
         */
        'shortDescription': function shortDescription(a, b) {
            var s = a.shortDescription || '';
            return /** @type number */ s.localeCompare(b.shortDescription || '');
        },

        /**
         * @param {{descriptionSize: string}} a
         * @param {{descriptionSize: string}} b
         * @returns {number}
         */
        'size': function size(a, b) {
            var s = a.descriptionSize || '';
            return /** @type number */ s.localeCompare(b.descriptionSize || '');
        },

        /**
         * @param {{colorDescription: string}} a
         * @param {{colorDescription: string}} b
         * @returns {number}
         */
        'color': function color(a, b) {
            var s = a.colorDescription || '';
            return /** @type number */ s.localeCompare(b.colorDescription || '');
        }
    };

    DPO.inherit(SelectProductFlow, DPO.bll.BaseFlow);
    DPO.mixin(SelectProductFlow.prototype, {
        /**
         * @private
         * @memberof DPO.bll.SelectProductFlow#
         */
        onCategoriesLoaded: function onCategoriesLoaded(response) {
            var me = this;
            me.categories = response.data;
            me.defaultCategory = me.findDefaultCategory(me.categories);
            me.categoryId = me.categoryId || me.defaultCategory.id;
            me.loadProducts(me.categoryId);
            me.fire('fetched:categories', [me, me.categories]);
            me.decRequestCount();
        },

        /**
         * Searches default category
         * @memberof DPO.bll.SelectProductFlow#
         * @param {object[]} categories
         * @returns {object}
         */
        findDefaultCategory: function findDefaultCategory(categories) {
            for (var i = 0; i < categories.length; i++) {
                var c = categories[i];
                if (c.defaultCategory) {
                    return c;
                }

                c = this.findDefaultCategory(c.children || []);
                if (c && c.defaultCategory) {
                    return c;
                }
            }

            return categories[0] || null;
        },

        /**
         * @private
         * @memberof DPO.bll.SelectProductFlow#
         * @param {string} productProfile
         */
        loadCategories: function loadCategories(productProfile) {
            var me = this;
            me.incRequestCount();
            me.endpoint.fetchProductsCategories({productProfile: productProfile}, me.onCategoriesLoaded, me.onFails, me);
        },

        /**
         * @private
         * @memberof DPO.bll.SelectProductFlow#
         */
        onProductsLoaded: function onProductsLoaded(response) {
            var me = this;
            me.currentProducts = response.data;
            me.filterProducts(me.search, me.exactMatch);
            me.decRequestCount();
        },

        /**
         * @private
         * @memberof DPO.bll.SelectProductFlow#
         * @param {string} categoryId
         */
        loadProducts: function loadProducts(categoryId) {
            var me = this;

            if(me.hasProducts(categoryId)) {
                me.incRequestCount();
                me.endpoint.fetchProducts({productProfile: me.productProfile, categoryId: categoryId}, me.onProductsLoaded, me.onFails, me);
            }
        },

        /**
         * @private
         * @memberof DPO.bll.SelectProductFlow#
         */
        onAllProductsLoaded: function onAllProductsLoaded(response) {
            var me = this;
            me.allProducts = response.data;
            me.filterProducts(me.search, me.exactMatch);
            me.decRequestCount();
        },

        /**
         * Loads default products
         * @memberof DPO.bll.SelectProductFlow#
         */
        loadAllProducts: function loadAllProducts() {
            var me = this;
            me.incRequestCount();
            me.endpoint.fetchProducts({
                productProfile: me.productProfile
            }, me.onAllProductsLoaded, me.onFails, me);
        },

        /**
         * Loads categories & products
         * @memberof DPO.bll.SelectProductFlow#
         * @param {?string} [productProfile]
         * @param {string} [categoryId]
         */
        loadData: function loadData(productProfile, categoryId) {
            var me = this,
                prevProfile = me.productProfile,
                canLoadCatProducts = me.categories && categoryId && (me.categoryId !== categoryId),
                switchedProfile;

            me.categoryId = categoryId;

            me.productProfile = productProfile || 'YouPrint';
            switchedProfile = prevProfile !== me.productProfile;

            if (!me.allProducts || switchedProfile) {
                me.allProducts = [];
                me.loadAllProducts();
            }

            if (!me.categories || switchedProfile) {
                me.categories = [];
                me.loadCategories(me.productProfile);
            }

            if (canLoadCatProducts) {
                me.loadProducts(categoryId);
            } else {
                me.filterProducts(me.search, me.exactMatch);
            }
        },

        /**
         * Sorts products by specific criteria & direction
         * @memberof DPO.bll.SelectProductFlow#
         * @param {string} [order]
         * @param {boolean} [ascending]
         * @returns {DPO.bll.SelectProductFlow}
         */
        sortProducts: function sortProducts(order, ascending) {
            var me = this,
                asc = ascending === undefined ? me.ascending : ascending;
            me.order = order || me.order;
            me.ascending = asc;

            var sorter = sorters[me.order],
                d = asc ? 1 : -1;

            function compare(a, b) {
                return d * sorter(a, b);
            }

            me.products.sort(compare);

            if (me.search) {
                DPO.stableSort(me.products, function (a, b) {
                    var ar = me.relevances[a.id],
                        br = me.relevances[b.id];
                    return ar - br;
                });
            }

            me.fire('fetched:products', [me, me.products]);
            return this;
        },

        /**
         * Filters current products by specified string
         * @memberof DPO.bll.SelectProductFlow#
         * @param {string} search
         * @param {boolean} [exactMatch]
         * @returns {DPO.bll.SelectProductFlow}
         */
        filterProducts: function filterProducts(search, exactMatch) {
            var me = this;
            search = (search || '').trim();
            me.search = search;
            if (search) {
                me.products = this.filterProductsArray(me.allProducts, search, exactMatch);
            } else {
                me.products = [].concat(me.currentProducts);
            }

            me.sortProducts();
            return this;
        },

        /**
         * Creates filter function for specifies search string
         * @memberof DPO.bll.SelectProductFlow#
         * @param {string} search
         * @param {boolean} [exactMatch]
         * @returns {function[]}
         */
        createMatches: function createMatches(search, exactMatch) {
            var escapeRegExp = /[\-\[\]\/\{}\(\)\*\+\?\.\\\^\$\|]/g,
                escaped = search.replace(escapeRegExp, '\\$&'),
                exp = exactMatch ? '^\\s*' + escaped + '\\s*$' : escaped,
                containsRegExp = new RegExp(exp, 'i'),
                result = [], matches, regexp;

            // Full International SKU
            // 0. Full string
            // 1. SKU
            // 2. Color suffix
            // 2. Color digits
            // 3. Quantity suffix
            matches = search.match(/^\s*([A-Z]+[\d]+)([A-Z]+)?([0-9]*)?(-.*)?/i);

            if (matches) {
                var sku = matches[1].replace(escapeRegExp, '\\$&'),
                    colorSuffix = (matches[2] || '').replace(escapeRegExp, '\\$&'),
                //colorDigits = (matches[3] || '').replace(escapeRegExp, '\\$&'),
                    quantitySuffix = (matches[4] || '').replace(escapeRegExp, '\\$&').replace(/\d+/, '');
                if (quantitySuffix && colorSuffix) {
                    regexp = sku + colorSuffix;
                } else if (colorSuffix) {
                    regexp = sku + colorSuffix;
                } else {
                    regexp = sku;
                }

                regexp = new RegExp(regexp, 'i');
                result.push(function (product) {
                    var value = product.sku,
                        profile = product.productProfile || 'DEFAULT';
                    return {input: value, matches: profile === 'DEFAULT' ? value.match(regexp) : null};
                });
            } else {
                result.push(function (product) {
                    var value = product.sku,
                        profile = product.productProfile || 'DEFAULT';
                    return {input: value, matches: profile === 'DEFAULT' ? value.match(containsRegExp) : null};
                });
            }

            result.push(function (product) {
                var value = product.description || '';
                return {input: value, matches: value.match(containsRegExp)};
            });
            result.push(function (product) {
                var value = product.shortDescription || '',
                    profile = product.productProfile || 'DEFAULT';
                return {input: value, matches: profile === 'DEFAULT' ? null : value.match(containsRegExp)};
            });
            result.push(function (product) { // colors
                var value = product.colorDescription || '';
                return {input: value, matches: value.match(containsRegExp)};
            });
            result.push(function (product) { // size
                var value = product.descriptionSize || '';
                return {input: value, matches: value.match(containsRegExp)};
            });
            return result;
        },

        /**
         * Calculate search relevance for specific
         * @memberof DPO.bll.SelectProductFlow#
         * @private
         * @param {object} product
         * @param {object} matching
         * @param {string} search
         */
        calculateRelevance: function calculateRelevance(product, matching, search) {
            var id = product.id,
                relevance = this.relevances[id],
                input = matching.input,
                matches = matching.matches;
            if (relevance == null) {
                relevance = Infinity;
            }

            for (var i = 0; i < matches.length; i++) {
                var m = matches[i],
                    leading = input.indexOf(m),
                    ending = input.length - m.length - leading,
                    r = leading * 5 + ending + 1;
                relevance = Math.min(r, relevance);
            }

            relevance = Math.min(relevance, input === search ? 0 : relevance);
            this.relevances[id] = relevance;
        },

        /**
         * Filters product by specified filter criteria
         * @memberof DPO.bll.SelectProductFlow#
         * @private
         * @param {object[]} products
         * @param {string} search
         * @param {boolean} [exactMatch]
         * @returns {object[]}
         */
        filterProductsArray: function filterProductsArray(products, search, exactMatch) {
            var me = this;
            me.relevances = {};

            var result = [],
                matches = me.createMatches(search, exactMatch);
            for (var i = 0; i < products.length; i++) {
                var add = false;
                for (var j = 0; j < matches.length; j++) {
                    var product = products[i],
                        res = matches[j].call(me, product);
                    if (res.matches) {
                        add = true;
                        me.calculateRelevance(product, res, search);
                    }
                }
                if (add) {
                    result.push(products[i]);
                }
            }

            return result;
        },

        hasProducts: function hasProducts(categoryId) {
            var me = this;

            me.categoryType = me.findCategoryType(categoryId);

            return !me.categoryType || [categoryTypes.SINGLE, categoryTypes.MULTIPLE].indexOf(me.categoryType) !== -1;
        },

        findCategoryType: function findCategoryType(categoryId) {
            var me = this;

            for (var i = 0; i < me.categories.length; i++) {
                var c = me.categories[i];
                if (c.id === categoryId) {
                    return c.type;
                }
            }

            return undefined;
        }
    });

    return SelectProductFlow;
});

DPO.def('bll.SelectPredesignFlow', function () {
    /**
     * Creates new select predesign flow
     * @class DPO.bll.SelectPredesignFlow
     * @extends DPO.bll.BaseFlow
     * @memberof DPO.bll
     * @param {DPO.dal.DAL} endpoint
     * @property {?string} productId
     * @property {?string} categoryId
     * @property {?string} theme
     * @property {object} defaultCategory
     * @property {object[]} categories
     * @property {object[]} predesigns
     * @constructor
     */
    function SelectPredesignFlow(endpoint) {
        var me = this;
        DPO.bll.ProjectFlow.call(me, endpoint);
        me.categoryId = null;
        me.productId = null;
        me.theme = null;
        me.categories = null;
        me.predesigns = [];
        me.currentPredesigns = [];
        me.allPredesigns = [];
        me.order = 'name';
        me.ascending = true;
    }

    var sorters = {
        /**
         * @param {{name: string}} a
         * @param {{name: string}} b
         * @returns {number}
         */
        'name': function name(a, b) {
            var s = a.name || '';
            return /** @type number */ s.localeCompare(b.name || '');
        }
    };

    DPO.inherit(SelectPredesignFlow, DPO.bll.ProjectFlow);

    DPO.mixin(SelectPredesignFlow, {
        normalizeSearchParam: function normalizeSearchParam(param) {
            return (param || '').trim().toLowerCase();
        }
    });

    DPO.mixin(SelectPredesignFlow.prototype, {
        /**
         * Returns default category
         * @memberof DPO.bll.SelectPredesignFlow#
         * @param {object[]} categories
         * @returns {object}
         */
        findDefaultCategory: function findDefaultCategory(categories) {
            for (var i = 0; i < categories.length; i++) {
                var c = categories[i];
                if (c.defaultCategory) {
                    return c;
                }

                c = this.findDefaultCategory(c.children || []);
                if (c && c.defaultCategory) {
                    return c;
                }
            }

            return categories[0] || null;
        },

        /**
         * @private
         * @memberof DPO.bll.SelectPredesignFlow#
         */
        onCategoriesLoaded: function onCategoriesLoaded(response) {
            var me = this;
            me.categories = response.data;
            me.defaultCategory = me.findDefaultCategory(me.categories);
            me.fire('fetched:categories', [me, me.categories]);
            me.loadPredesigns();
            me.decRequestCount();
        },

        /**
         * @private
         * @memberof DPO.bll.SelectPredesignFlow#
         */
        onPredesignsLoaded: function onPredesignsLoaded(response) {
            var me = this;
            me.currentPredesigns = response.data;
            me.filterPredesigns(me.search);
            me.fire('fetched:predesigns', [me, me.predesigns]);
            me.decRequestCount();
        },

        /**
         * Loads pre-designs categories
         * @memberof DPO.bll.SelectPredesignFlow#
         */
        loadCategories: function loadCategories() {
            var me = this;
            me.incRequestCount();
            me.endpoint.fetchPredesignsCategories({
                productId: me.productId
            }, me.onCategoriesLoaded, me.onFails, me);
        },

        /**
         * Loads pre-designs data
         * @memberof DPO.bll.SelectPredesignFlow#
         */
        loadPredesigns: function loadPredesigns() {
            var me = this;

            me.incRequestCount();

            if (me.allPredesigns && me.allPredesigns.length) {
                me.loadCurrentPredesigns();
            } else {
                me.loadAllPredesigns();
            }
        },

        /**
         * Loads all pre-designs data
         * @memberof DPO.bll.SelectPredesignFlow#
         */
        loadAllPredesigns: function loadAllPredesigns() {
            var me = this;

            me.endpoint.fetchPredesigns({productId: me.productId}, function(response) {
                me.allPredesigns = response.data;

                if (me.categoryId || me.theme) {
                    me.loadCurrentPredesigns();
                } else {
                    me.onPredesignsLoaded(response);
                }

            }, me.onFails, me);
        },

        /**
         * Loads current pre-designs data
         * @memberof DPO.bll.SelectPredesignFlow#
         */
        loadCurrentPredesigns: function loadCurrentPredesigns() {
            var me = this;

            me.endpoint.fetchPredesigns({
                productId: me.productId,
                categoryId: me.categoryId,
                designThemeName: me.theme
            }, me.onPredesignsLoaded, me.onFails, me);
        },

        /**
         * Loads all pre-designs data
         * @memberof DPO.bll.SelectPredesignFlow#
         * @param {string} productId
         * @param {?string} [categoryId]
         * @param {string} [theme]
         */
        loadData: function loadData(productId, categoryId, theme) {
            var me = this,
                prevCategoryId = me.categoryId,
                prevProductId = me.productId,
                prevTheme = me.theme,
                reloadCategories = prevProductId !== productId || !me.categories,
                isNewProductID = prevProductId !== null && reloadCategories,
                isNewCategoryID = prevCategoryId!== null && prevCategoryId !== categoryId,
                isNewTheme = prevTheme !== null && prevTheme !== theme,
                reloadPredesigns = isNewProductID || isNewCategoryID || isNewTheme;

            me.productId = productId;
            me.categoryId = categoryId;
            me.theme = theme;

            if (reloadCategories) {
                me.categories = [];
                me.loadCategories();
            } else {
                me.fire('fetched:categories', [me, me.categories]);
            }

            if (reloadPredesigns) {
                me.loadPredesigns();
            } else {
                me.filterPredesigns(me.search);
            }
        },

        /**
         * Filter predesigns by specified string
         * @memberof DPO.bll.SelectPredesignFlow#
         * @param search - search string
         */
        filterPredesigns: function filterPredesigns(search) {
            var me = this;

            if(search && typeof search === 'string') {
                var searchWords = search.split(' '),
                    result = [],
                    match,
                    predesign,
                    keyWords,
                    keyWord,
                    searchWord,
                    i, j, k;

                for (i = 0; i < me.allPredesigns.length; i++) {
                    predesign = me.allPredesigns[i];
                    keyWords = predesign.keywords || [];

                    for (j = 0; j < searchWords.length; j++) {
                        match = false;
                        searchWord = SelectPredesignFlow.normalizeSearchParam(searchWords[j]);

                        for (k = 0; k < keyWords.length; k++) {
                            keyWord = SelectPredesignFlow.normalizeSearchParam(keyWords[k]);
                            match = match || (keyWord.indexOf(searchWord) !== -1);
                        }

                        if (!match) {
                            break;
                        }
                    }

                    if (match) {
                        result.push(predesign);
                    }
                }
                me.predesigns = result;
            } else {
                me.predesigns = me.currentPredesigns;
            }

            //me.sortPredesigns();
        },

        /**
         * Sorts predesigns by specific criteria & direction
         * @memberof DPO.bll.SelectPredesignFlow#
         * @param {string} [order]
         * @param {boolean} [ascending]
         */
        sortPredesigns: function sortPredesigns(order, ascending) {
            var me = this,
                asc = ascending === undefined ? me.ascending : ascending;
            me.order = order || me.order;
            me.ascending = asc;

            var sorter = sorters[me.order],
                d = asc ? 1 : -1;

            function compare(a, b) {
                return d * sorter(a, b);
            }

            me.predesigns.sort(compare);
        }
    });

    return SelectPredesignFlow;
});


DPO.def('bll.CustomizeFlow', function () {
    /**
     * @property {DPO.bll.CustomizeFlow} flow
     * @param {DPO.bll.CustomizeFlow} flow
     * @constructor
     */
    function CustomizeFlowActionChain(flow) {
        this.flow = flow;
    }

    DPO.inherit(CustomizeFlowActionChain, DPO.bll.ActionChain);
    DPO.mixin(CustomizeFlowActionChain.prototype, {
        collectActions: function collectActions(actions) {
            DPO.mixin(actions, {
                createBarcode: {},
                createImageContent: {},
                createImageData: {},
                createImageGallery: {},
                createImageFile: {},
                createImageURL: {},
                createSequentialNumber: {},
                createTextBlock: {},
                createTextPath: {},
                updateBarcode: {},
                updateSequentialNumber: {}
            });
        },

        createImage: function createImage(params, response) {
            var data = response.data,
                me = this,
                flow = me.flow,
                editor = flow.editor,
                images = [],
                img;
            data = data instanceof Array ? data : [data];
            for (var i = 0; i < data.length; i++) {
                var f = data[i],
                    high = f.highResolution,
                    x = params.cx || (params.x == null ? null : params.x + i * 10),
                    y = params.cy || (params.y == null ? null : params.y + i * 10),
                    width = params.width || high.width,
                    height = params.height || high.height,
                    preventSizeProcessing = params.cx !== undefined && params.cy !== undefined && params.width !== undefined && params.height !== undefined;
                if (params.autoSave) {
                    flow.autoSaveImages.push(f);    // TODO: use context state instead flow
                }
                img = editor.createImage(f.name, x, y, width, height, preventSizeProcessing);
                images.push(img);
            }

            flow.fire('images:added', [me, images, data]);
            flow.decRequestCount();
        },

        replaceImage: function replaceImage(params, fields, response) {
            var data = response.data,
                me = this,
                flow = me.flow,
                pt = flow.editor.projectEditor,
                images = [],
                imgInfo;
            data = data instanceof Array ? data : [data];
            imgInfo = data[0];
            if (params.autoSave) {
                flow.autoSaveImages.push(data); // TODO: use context state instead flow
            }

            pt.beginUpdates();

            for (var i = 0; i < fields.length; i++) {
                var f = fields[i];
                if (f instanceof DPO.model.Image) {
                    images.push(f);
                    pt.setProperties(f, {
                        source: imgInfo.name
                    });
                }
            }

            pt.endUpdates();
            flow.fire('images:changed', [me, images, data]);
            flow.decRequestCount();
        },

        createBackground: function createBackground(params, response) {
            var data = response.data,
                me = this,
                flow = me.flow,
                editor = flow.editor,
                highRes = data.highResolution || data[0].highResolution,
                imageSettings = params.imageSettings || [],
                name = data.name || data[0].name,
                keepAspect = imageSettings.length === 2 && imageSettings[1].name === 'lockAspectRatio',
                result = editor.createBackground(name, highRes.width, highRes.height, keepAspect);

            if(result.transformBackgrounds.length){
                editor.transformBackgroundToImage(result.transformBackgrounds[0]);
            }

            flow.fire('images:added', [me, result.background, [data]]);
            flow.decRequestCount();
        },

        getImageCallback: function getImageCallback(params, fields) {
            var me = this,
                callback;
            if (params.imageSettings && params.imageSettings.length && params.imageSettings[0].name === 'setAsBackground') {
                callback = me.createBackground.bind(me, params);
            } else if (params.replaceSource) {
                callback = me.replaceImage.bind(me, params, fields);
            } else {
                callback = me.createImage.bind(me, params);
            }

            return callback;
        },

        onFails: function onFails() {
            this.flow.onFails.apply(this.flow, arguments);
        },

        execute: function execute(fields, action, params) {
            var me = this,
                flow = me.flow,
                provider = flow.provider,
                editor = flow.editor,
                pt = editor.projectEditor,
                endpoint = flow.endpoint,
                barcode, mp, cb, formData;
            switch (action) {
                case 'createBarcode':
                    mp = editor.context.selector.selectMasterPanel(pt.panel);
                    pt.beginUpdates();
                    if (params.dataSource) {
                        provider.setDataSource(params.dataSource);
                        pt.adjustSheetForDataBinding(mp, params.dataSource.totalRecords());
                    }
                    pt.addFieldToPanel(params.barcode, pt.panel);
                    pt.centerFields([params.barcode], true, true, {
                        x: 0,
                        y: 0,
                        width: mp.width,
                        height: mp.height
                    });
                    pt.endUpdates();
                    editor.transformTool.selectFields([params.barcode]);
                    break;
                case 'updateBarcode':
                    mp = editor.context.selector.selectMasterPanel(pt.panel);
                    barcode = editor.context.selector.getField(params.barcode.id);
                    pt.beginUpdates();
                    if (params.dataSource) {
                        provider.setDataSource(params.dataSource);
                        pt.adjustSheetForDataBinding(mp, params.dataSource.totalRecords());
                    }
                    DPO.mixin(barcode, params.barcode);
                    pt.fireAccumulativeEvent('changed:field:content', [barcode]);
                    pt.endUpdates();
                    break;
                case 'createImageContent':
                    cb = me.getImageCallback(params, fields);
                    flow.incRequestCount();
                    endpoint.copyUserImageToProject(params.id, flow.projectData, cb, me.onFails, me);
                    break;
                case 'createImageGallery':
                    cb = me.getImageCallback(params, fields);
                    flow.incRequestCount();
                    endpoint.copyGalleryImageToProject(params.id, flow.projectData, cb, me.onFails, me);
                    break;
                case 'createImageFile':
                    formData = new FormData();
                    cb = me.getImageCallback(params, fields);
                    for (var i = 0; i < params.files.length; i++) {
                        var f = params.files[i];
                        //noinspection JSCheckFunctionSignatures,JSCheckFunctionSignatures
                        formData.append('images[]', f, f.name);
                    }

                    flow.incRequestCount();
                    endpoint.uploadImages(formData, flow.projectData, cb, me.onFails, me);
                    break;
                case 'createImageData':
                    cb = me.getImageCallback(params, fields);
                    cb({data: params.imageData});
                    break;

                case 'createImageURL':
                    cb = me.getImageCallback(params, fields);
                    flow.incRequestCount();
                    endpoint.copyRemoteImage(params.url, flow.projectData, cb, me.onFails, me);
                    break;

                case 'createSequentialNumber':
                    editor.createSerialNumber(params, params.cx, params.cy);
                    break;
                case 'createTextPath':
                    editor.createTextPath(params.cx, params.cy);
                    break;
                case 'createTextBlock':
                    editor.createTextBlock(params.cx, params.cy);
                    break;
                case 'updateSequentialNumber':
                    editor.updateSerialNumber(params.id, params);
                    break;
                default:
                    return false;
            }

            return true;
        }
    });

    /**
     * Creates new Customize Flow
     * @class DPO.bll.CustomizeFlow
     * @extends DPO.bll.ProjectFlow
     * @memberof DPO.bll
     * @param {DPO.dal.DAL} endpoint
     * @param {DPO.render.Editor} editor
     * @param {DPO.render.Preview} preview
     * @property {DPO.render.Editor} editor
     * @property {DPO.render.Preview} preview
     * @property {object} projectData
     * @property {object} storage
     * @property {object} storage
     * @fires actions:changed
     * @fires images:changed
     * @constructor
     */
    function CustomizeFlow(endpoint, editor, preview) {
        var me = this;
        me.projectData = null;
        me.storage = new DPO.project.Storage();
        me.editor = editor;
        me.preview = preview;
        me.clipboard = [];
        me.chain = new CustomizeFlowActionChain(me);
        DPO.bll.ProjectFlow.call(me, endpoint);
    }

    DPO.inherit(CustomizeFlow, DPO.bll.ProjectFlow);

// -----------------------------------------------------------------------------------------------------------------
// -- Public Methods
// -----------------------------------------------------------------------------------------------------------------
//noinspection OverlyComplexFunctionJS,FunctionTooLongJS
    DPO.mixin(CustomizeFlow.prototype, {
        /** Returns field name for localization
         * @memberof DPO.bll.CustomizeFlow#
         * @param {DPO.model.Field} field
         * @returns {string}
         */
        getFieldName: function getFieldName(field) {
            switch (field.constructor) {
                case DPO.model.Barcode:
                    return 'object-barcode';
                case DPO.model.TextBlock:
                    return 'object-text-block';
                case DPO.model.TextPath:
                    return 'object-text-path';
                case DPO.model.Drawing:
                    return 'object-drawing';
                case DPO.model.Image:
                    return 'object-image';
                case DPO.model.Background:
                    return 'object-background';
                default:
                    return 'object';
            }
        },

        /** Returns field index
         * @memberof DPO.bll.CustomizeFlow#
         * @param {string} name
         * @param {object} indexes
         * @returns {number}
         */
        getFieldIndex: function getFieldIndex(name, indexes) {
            if (!(name in indexes)) {
                indexes[name] = 0;
            }

            return ++indexes[name];
        },

        getTypesMap: function getTypesMap() {
            var editor = this.editor,
                fields = editor.context.selector.selectPanelFields(editor.panel),
                types = {},
                indexes = {},
                field, name, index;

            fields = fields.sort(function (a, b) {
                return a.id - b.id;
            });

            for (var i = 0; i < fields.length; i++) {
                field = fields[i];
                name = this.getFieldName(field);
                index = this.getFieldIndex(name, indexes);

                types[field.id] = {
                    name: name,
                    index: index
                };
            }

            return types;
        },

        /**
         * Returns models for object list component
         * @memberof DPO.bll.CustomizeFlow#
         */
        getObjectListModels: function getObjectListModels() {
            if (!this.editor) {
                return [];
            }

            var models = [],
                editor = this.editor,
                selected = this.editor.selectedFields,
                locked = editor.getLockedFields(),
                hidden = editor.getHiddenFields(),
                order = editor.context.selector.getFieldOrder(editor.panel),
                types = this.getTypesMap();

            order.items.reverse();
            for (var i = order.items.length - 1; i >= 0; i--) {
                var f = order.items[i].field;
                if (!f.editable || f instanceof DPO.model.Background) {
                    continue;
                }
                models.push(DPO.mixin({
                    field: f,
                    selected: selected.indexOf(f) > -1,
                    visible: hidden.indexOf(f) === -1,
                    locked: locked.indexOf(f) !== -1
                }, types[f.id]));
            }
            models.reverse();
            return models;
        },

        setFieldState: function setFieldState(model) {
            var me = this;
            if (model.selected) {
                me.editor.transformTool.selectFields(model.selected);

                var field = model.selected.length === 1 ? model.selected[0] : null;
                if (field instanceof DPO.model.TextBlock) {
                    me.editor.transformTool.editTextBlock(field);
                }
            }
            if (model.visible) {
                me.editor.showFields(/** @type DPO.model.Field[] */model.visible);
            }
            if (model.hidden) {
                me.editor.hideFields(/** @type DPO.model.Field[] */model.hidden);
            }
            if (model.locked) {
                me.editor.lockFields(/** @type DPO.model.Field[] */model.locked);
            }
            if (model.unlocked) {
                me.editor.unlockFields(/** @type DPO.model.Field[] */model.unlocked);
            }
        },

        setFieldOrder: function setFieldOrder(fields) {
            var me = this,
                pt = me.editor.projectEditor,
                order = pt.selector.getFieldOrder(me.editor.panel),
                zOrder = order.items.length - 1;
            for (var i = 0; i < fields.length; i++) {
                order.setZOrder(fields[i], zOrder--);
            }

            pt.beginUpdates();
            pt.applyFieldOrder(order);
            pt.endUpdates();
        }
    });

    return CustomizeFlow;
});

DPO.def('bll.ProjectStorage', function () {

    /**
     * @class DPO.bll.ProjectStorage
     * @extends DPO.mixins.Observable
     * @memberof DPO.bll
     * @param {DPO.dto.ProjectData} projectData
     * @property {DPO.dal.DAL} endpoint
     * @property {DPO.model.Project} project
     * @property {DPO.dto.ProjectData} projectData
     * @constructor
     */
    function ProjectStorage(projectData) {
        var me = this;
        me.resetObservable();
        me.projectData = projectData;
    }

    DPO.mixin(ProjectStorage.prototype, DPO.mixins.Observable);
    DPO.mixin(ProjectStorage.prototype, {
        /**
         *
         * @param {DPO.xml.Model} model
         * @param {function} callback
         * @param {object} [scope]
         */
        requestForModel: DPO.emptyFn
    });

    return ProjectStorage;
});
DPO.def('bll.HttpProjectStorage', function () {
    /**
     * @class DPO.bll.HttpProjectStorage
     * @extends DPO.bll.ProjectStorage
     * @memberof DPO.bll
     * @param {DPO.dal.DAL} endpoint
     * @param {DPO.dto.ProjectData} projectData
     * @property {DPO.dal.DAL} endpoint
     * @property {DPO.model.Project} project
     * @property {DPO.dto.ProjectData} projectData
     * @property {string} imageType
     * @property {string} loadingImgURL
     * @fires image:generated
     * @fires error:occurred
     * @constructor
     */
    function HttpProjectStorage(endpoint, projectData) {
        var me = this;
        DPO.bll.ProjectStorage.call(me, projectData);
        me.imageType = 'low';
        me.endpoint = endpoint;
        me.barcodeGenerator = new DPO.project.BarcodeGenerator(9);
        me.projectPath = projectData.uriXML ? projectData.uriXML.replace(/[\-a-zA-z0-9]+\.xml$/i, '') : '';
        me.urlRedefinition = {};
        me.lowImgMap = {};
        me.cmykImgMap = {};
        me.progress = {};
    }

    DPO.inherit(HttpProjectStorage, DPO.bll.ProjectStorage);
    DPO.mixin(HttpProjectStorage.prototype, {
        loadingImgURL: 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==',

        /**
         * Resets storage state
         * @memberof DPO.bll.HttpProjectStorage#
         */
        reset: function reset() {
            this.lowImgMap = {};
            this.cmykImgMap = {};
            this.progress = {};
        },

        /**
         * Redefine URL for specified field
         * @memberof DPO.bll.HttpProjectStorage#
         * @param {DPO.model.Field} field
         * @param {string} url
         */
        redefineUrl: function redefinitionUrl(field, url) {
            this.urlRedefinition[field.id] = url;
        },

        /**
         * Resets all URL redefinitions
         * @memberof DPO.bll.HttpProjectStorage#
         */
        resetUrlRedefinition: function resetUrlRedefinition() {
            this.urlRedefinition = {};
        },

        /**
         * Check if all images are generated
         * @memberof DPO.bll.HttpProjectStorage#
         * @returns {boolean}
         */
        isReady: function isReady() {
            var me = this,
                keys = Object.keys(me.lowImgMap),
                ready = true,
                i, key;
            for (i = 0; ready && i < keys.length; i++) {
                key = keys[i];
                ready = !!me.lowImgMap[key];
            }

            keys = Object.keys(me.cmykImgMap);
            for (i = 0; ready && i < keys.length; i++) {
                key = keys[i];
                ready = !!me.cmykImgMap[key];
            }
            return ready;
        },

        /**
         * Creates absolute path to image
         * @memberof DPO.bll.HttpProjectStorage#
         * @param {DPO.model.Image||DPO.model.Background|string} fieldOrName
         * @param {string} [type]
         * @param {boolean} [skipRedefinition]
         * @returns {string}
         */
        urlForImage: function urlForImage(fieldOrName, type, skipRedefinition) {
            var me = this,
                name = fieldOrName.source || fieldOrName,
                url = me.urlRedefinition[fieldOrName.id];
            if (url && !skipRedefinition) {
                return url;
            }
            type = type || me.imageType;
            switch (type) {
                case 'low':
                    me.requestLowImgIfNeeded(name);
                    return me.getPath(me.lowImgMap, name);
                case 'cmyk':
                    me.requestCmykImgIfNeeded(name);
                    return me.getPath(me.cmykImgMap, name);
                default:
                    return me.projectPath + 'HighRes/' + name;
            }
        },

        /**
         * Extracts image URL from specified map
         * @memberof DPO.bll.HttpProjectStorage#
         * @param {object} map
         * @param {string} name
         * @returns {string}
         */
        getPath: function getPath(map, name) {
            var info = map[name];
            return (info ? info.uri : null) || this.loadingImgURL;
        },

        requestLowImgIfNeeded: function requestLowImgIfNeeded(name) {
            var me = this,
                projectData = me.projectData,
                dal = me.endpoint;

            function lowResPolling(response) {
                var data = response.data,
                    low = data.lowResolution;
                if (low) {
                    me.lowImgMap[name] = low;
                    var needCmyk = me.requestCmykImgIfNeeded(name);

                    if (needCmyk) {
                        me.fire('image:generated', [me, name, 'low', low]);
                    } else {
                        me.stopProgress(name, function () {
                            me.fire('image:generated', [me, name, 'low', low]);
                        });
                    }

                    return;
                }

                setTimeout(function () {
                    dal.requestLowResImage(name, false, projectData, lowResPolling, Failed);
                }, data.interval);
            }

            function Failed() {
                delete me.lowImgMap[name];

                me.stopProgress(name, function () {
                    me.fire('error:occurred', [me, name]);
                });
            }

            if (me.lowImgMap[name] === undefined && me.imageType !== 'high') {
                me.lowImgMap[name] = false;

                me.startProgress(name);

                dal.requestLowResImage(name, false, projectData, lowResPolling, Failed);
            } else {
                me.fire('image:fetched', [me, name, 'low', me.lowImgMap[name]]);
            }
        },

        requestCmykImgIfNeeded: function requestCmykImgIfNeeded(name) {
            var me = this,
                projectData = me.projectData,
                dal = me.endpoint;
            if (me.imageType !== 'cmyk' || me.cmykImgMap[name] !== undefined) {
                return false;
            }

            function cmykPolling(response) {
                var data = response.data,
                    low = data.lowResolution;
                if (low) {
                    me.cmykImgMap[name] = low;

                    me.stopProgress(name, function () {
                        me.fire('image:generated', [me, name, 'cmyk', low]);
                    });

                    return;
                }

                setTimeout(function () {
                    dal.requestLowResImage(name, true, projectData, cmykPolling, Failed);
                }, data.interval);
            }

            function generationStarted() {
                dal.requestLowResImage(name, true, projectData, cmykPolling, Failed);
            }

            function Failed() {
                delete me.cmykImgMap[name];

                me.stopProgress(name, function () {
                    me.fire('error:occurred', [me, name]);
                });
            }

            if (!me.lowImgMap[name]) {
                me.requestLowImgIfNeeded(name);
                return false;
            }

            me.cmykImgMap[name] = false;

            me.startProgress(name);

            dal.requestImageInColorSpace([name], projectData, generationStarted, Failed);

            return true;
        },

        startProgress: function startProgress(name) {
            var me = this;

            if (!me.progress[name] && me.eventMap['image:progress']) {
                me.progress[name] = DPO.progressCalculator(function (current, total) {
                    me.fire('image:progress', [name, current, total]);
                });
            }
        },

        stopProgress: function stopProgress(name, onStop) {
            var me = this;

            if (me.progress[name] && me.eventMap['image:progress']) {
                me.progress[name].done(function () {
                    delete me.progress[name];
                    onStop.call(me);
                });
            } else {
                onStop.call(me);
            }
        },

        /**
         * Return URL for specified field's resource
         * @memberof DPO.bll.HttpProjectStorage#
         * @param {DPO.model.Field} field
         * @returns {string}
         */
        urlForField: function urlForField(field) {
            var me = this,
                url = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

            if (field.constructor === DPO.model.Image) {
                url = me.urlForImage(/** @type DPO.model.Image */field);
            }

            if (field.constructor === DPO.model.Background) {
                url = me.urlForImage(/** @type DPO.model.Background */field);
            }

            if (field.constructor === DPO.model.Barcode) {
                var data = me.barcodeGenerator.getBarcodeData(/** @type DPO.model.Barcode*/ field);
                if (data.error) {
                    url = null;
                } else {
                    url = me.endpoint.buildBarcodeUrl(data);
                }
            }

            return url;
        }
    });

    return HttpProjectStorage;
});

DPO.def('bll.FlickrClient', function () {
    /**
     * Creates new FlickrClient object
     * @class DPO.bll.FlickrClient
     * @memberof DPO.bll
     * @param {DPO.dal.DAL} dal
     * @param {object} cfg
     * @constructor
     */
    function FlickrClient(dal, cfg) {
        var me = this;
        me.dal = dal;
        me.accessor = null;
        me.user = null;
        me.requestToken = null;
        me.onError = this.onError.bind(me);
        me.onStorageChanged = this.onStorageChanged.bind(me);
        me.sha1 = new DPO.crypto.SHA1();
        DPO.mixin(me, cfg);
        me.resetObservable();
        me.init();
    }

    DPO.mixin(FlickrClient.prototype, DPO.mixins.Observable);
    DPO.mixin(FlickrClient.prototype, {
        restUrl: 'https://api.flickr.com/services/rest',
        tokenKey: 'flickr-authorize-token',
        consumerKey: '2754c5f1cfcc0634b41259d9ff8cc5cf',
        consumerSecret: 'c4f2cfafb166662b',
        callbackUrl: null,

        popupCenter: function popupCenter(url, title, w, h) {
            var dualScreenLeft = window.screenLeft,
                dualScreenTop = window.screenTop,
                width = window.innerWidth,
                height = window.innerHeight,
                left = (width - w) / 2 + dualScreenLeft,
                top = (height - h) / 2 + dualScreenTop;
            return window.open(url, title, 'width=' + w + ', height=' + h + ', top=' + top + ', left=' + left);
        },

        nonce: function nonce(length) {
            var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz',
                result = '';
            for (var i = 0; i < length; ++i) {
                var index = Math.floor(Math.random() * chars.length);
                result += chars.substring(index, index + 1);
            }
            return result;
        },

        percentEncode: function percentEncode(value) {
            var s = encodeURIComponent(value);
            // Now replace the values which encodeURIComponent doesn't do
            // encodeURIComponent ignores: - _ . ! ~ * ' ( )
            // OAuth dictates the only ones you can ignore are: - _ . ~
            // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
            s = s.replace(/!/g, '%21');
            s = s.replace(/'/g, '%27');
            s = s.replace(/\*/g, '%2A');
            s = s.replace(/\(/g, '%28');
            s = s.replace(/\)/g, '%29');
            return s;
        },

        formEncode: function formEncode(list) {
            var form = '';
            for (var p = 0; p < list.length; ++p) {
                var value = list[p][1];
                if (form !== '') {
                    form += '&';
                }
                form += this.percentEncode(list[p][0]) + '=' + this.percentEncode(value);
            }
            return form;
        },

        getBaseString: function getBaseString(message) {
            var me = this,
                sortable = [],
                params = message.parameters,
                i;
            for (i = 0; i < params.length; ++i) {
                var p = params[i];
                sortable.push([me.percentEncode(p[0]) + ' ' + me.percentEncode(p[1]), p]);
            }
            sortable.sort();

            var sorted = [];
            for (i = 0; i < sortable.length; i++) {
                sorted.push(sortable[i][1]);
            }

            var str = message.method.toUpperCase() + '&';
            str += me.percentEncode(me.restUrl) + '&';
            str += me.percentEncode(me.formEncode(sorted));
            return str;
        },

        getURL: function getURL(message) {
            var me = this;
            message.parameters = message.parameters.concat([
                ['oauth_consumer_key', me.consumerKey],
                ['oauth_token', this.accessor.token],
                ['oauth_version', '1.0'],
                ['oauth_timestamp', (new Date()).getTime()],
                ['oauth_nonce', me.nonce(6)],
                ['oauth_signature_method', 'HMAC-SHA1']
            ]);

            var data = me.getBaseString(message),
                key = me.percentEncode(me.consumerSecret) + '&' + me.percentEncode(me.accessor.tokenSecret),
                hash = me.sha1.hmac(key, data),
                signature = me.sha1.base64(hash);
            message.parameters = message.parameters.concat([
                ['oauth_signature', signature]
            ]);

            var query = me.formEncode(message.parameters);
            return message.action + '?' + query;
        },

        fetch: function flickrMethod(method, params, success, fail) {
            var message = {
                method: 'GET',
                action: this.restUrl,
                parameters: [
                    ['nojsoncallback', '1'],
                    ['format', 'json'],
                    ['method', method]
                ].concat(params)
            };
            var url = this.getURL(message);
            this.dal.fetch(url, success, fail);
        },

        start: function start() {
            var me = this,
                accessor = localStorage.getItem('flickr-accessor');
            if (this.accessor) {
                me.login();
                return;
            }

            this.requestFlickrToken();
        },

        login: function login() {
            var me = this;
            me.fetch('flickr.test.login', [], function (response) {
                me.user = response.user;
                me.fire('user:fetched', [me, me.user]);
                me.fetchPhotos();
                me.fetchAlbums();
            }, me.onError);
        },

        fetchPhotos: function fetchPhotos() {
            var me = this,
                params = [
                    ['user_id', me.user.id],
                    ['extras', 'url_s,url_o']
                ];
            me.fetch('flickr.people.getPhotos', params, function (response) {
                me.photos = response.photos.photo;
                me.fire('photos:fetched', [me, me.photos]);
            }, me.onError);
        },

        fetchAlbums: function fetchAlbums() {
            var me = this,
                params = [
                    ['user_id', me.user.id]
                ];
            me.fetch('flickr.photosets.getList', params, function (response) {
                me.albums = response.photosets.photoset;
                me.fire('albums:fetched', [me, me.albums]);
            }, me.onError);
        },

        fetchAlbumsPhotos: function fetchAlbumsPhotos(albumId, callback) {
            var me = this,
                params = [
                    ['user_id', me.user.id],
                    ['photoset_id', albumId],
                    ['extras', 'url_s,url_o']
                ];
            me.fetch('flickr.photosets.getPhotos', params, function (response) {
                callback(response.photoset.photo);
            }, me.onError);
        },

        parseToken: function parseToken(response) {
            var array = response.split('&'),
                params = {};
            for (var i = 0; i < array.length; i++) {
                var value = array[i],
                    b = value.split('=');
                params[b[0]] = b[1];
            }

            return params;
        },

        requestFlickrToken: function requestFlickrToken() {
            var me = this;
            me.dal.requestFlickrToken(me.callbackUrl, function (response) {
                me.requestToken = response.data;

                var url = response.data.loginURL;
                me.popupCenter(url, null, 1150, 650);
            }, me.onError);
        },

        onError: function onError(error) {
            this.fire('error:occurred', [this, error]);
        },

        onStorageChanged: function onStorageChanged(event) {
            if (event.key !== 'flickr-authorize-token') {
                return;
            }

            var me = this,
                params = me.parseToken(event.newValue);

            function tokenReceived(response) {
                var accessToken = response.data;
                me.accessor = {
                    consumerKey: me.consumerKey,
                    consumerSecret: me.consumerSecret,
                    token: accessToken.token,
                    tokenSecret: accessToken.tokenSecret
                };
                localStorage.setItem('flickr-accessor', JSON.stringify(me.accessor));
                me.login();
            }

            me.dal.accessFlickrToken({
                frob: params.oauth_verifier, // jshint ignore:line
                requestToken: me.requestToken.token,
                requestTokenSecret: me.requestToken.tokenSecret
            }, tokenReceived, me.onError);
        },

        init: function init() {
            window.addEventListener('storage', this.onStorageChanged);

            var accessor = localStorage.getItem('flickr-accessor');
            if (accessor) {
                this.accessor = JSON.parse(accessor);
            }
        },

        destroy: function destroy() {
            window.removeEventListener('storage', this.onStorageChanged);
        }
    });

    return FlickrClient;
});

DPO.def('bll.FlowConfigLoader', function () {
    /**
     * Creates new Flow Config Loader
     * @class DPO.bll.FlowConfigLoader
     * @extends DPO.bll.BaseFlow
     * @memberof DPO.bll
     * @property {DPO.dal.DAL} endpoint
     * @property {DPO.dto.ProjectData} projectData
     * @property {DPO.fc.Configuration} fc
     * @property {DPO.model.Project} project
     * @constructor
     */
    function FlowConfigLoader(endpoint, projectData) {
        var me = this;
        me.endpoint = endpoint;
        me.projectData = projectData;
        me.project = undefined;
        me.resetObservable();
    }

    DPO.inherit(FlowConfigLoader, DPO.bll.BaseFlow);
    DPO.mixin(FlowConfigLoader.prototype, {
        /**
         * @memberof DPO.bll.FlowConfigLoader#
         * @param {DPO.fc.Configuration} fc
         */
        onFlowConfigReceived: function onFlowConfigReceived(fc) {
            var me = this;
            me.fc = fc;
            me.fire('fc:loaded', [me, fc]);
            me.decRequestCount();
        },

        /**
         * @memberof DPO.bll.FlowConfigLoader#
         * @param response
         */
        onProjectInfoReceived: function onProjectInfoReceived(response) {
            var me = this;
            me.projectData = response.data;
            me.tryFetchFlowConfig();
            me.tryLoadProject();
            me.decRequestCount();
        },

        /**
         * @memberof DPO.bll.FlowConfigLoader#
         * @param {DPO.model.Project} project
         */
        onProjectLoaded: function onProjectLoaded(project) {
            var me = this;
            me.project = project;
            me.tryFetchFlowConfig();
            me.decRequestCount();
        },

        /**
         * @memberof DPO.bll.FlowConfigLoader#
         */
        tryFetchFlowConfig: function tryFetchFlowConfig() {
            var me = this,
                designTheme = me.project && me.project.designTheme,
                productId = me.projectData.product && me.projectData.product.id;
            if (!designTheme || !productId) {
                return;
            }

            me.incRequestCount();
            me.endpoint.fetchFlowConfiguration({
                productId: productId,
                designTheme: designTheme
            }, me.onFlowConfigReceived, me.onFails, me);
        },

        /**
         * @memberof DPO.bll.FlowConfigLoader#
         */
        tryLoadProject: function tryLoadProject() {
            var me = this;
            if (me.project !== undefined || !me.projectData.uriXML) {
                return;
            }

            me.project = null;
            me.incRequestCount();
            me.endpoint.loadProject(me.projectData.uriXML, me.onProjectLoaded, me.onFails, me);
        },

        /**
         * Loads flow configuration
         * @memberof DPO.bll.FlowConfigLoader#
         */
        load: function load() {
            var me = this,
                hasData = me.projectData.product && me.projectData.product.id && me.projectData.uriXML;
            if (!hasData) {
                if (me.projectData.id) {
                    me.incRequestCount();
                    me.endpoint.fetchProjectData(me.projectData.id, me.onProjectInfoReceived, me.onFails, me);
                } else {
                    var location = me.projectData.projectLocation;
                    me.incRequestCount();
                    me.endpoint.fetchProjectInfo({
                        storageId: location.storageId,
                        relativePath: location.relativePath
                    }, me.onProjectInfoReceived, me.onFails, me);
                }
            }

            me.tryLoadProject();
        }
    });

    return FlowConfigLoader;
});

return DPO;
}));
